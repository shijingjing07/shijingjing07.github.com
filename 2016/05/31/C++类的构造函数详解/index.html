<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>C++类的构造函数详解 | 迪米特</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="迪米特">
  
  
    <meta name="description" content="1.默认构造函数1) 当没有定义任何构造函数时，编译器会提供默认构造函数，可以直接使用。2) 如果定义了带参数的构造函数，又需要使用默认构造函数，此时，必须显式定义无参构造函数，这和C#中有很大的不同。例如有一个蔬菜类Veg：Veg(const char* name,int num,double price);//声明了带三个参数的构造函数要初始化Veg对象，可使用Veg veg(“tomato”">
  
  <meta name="description" content="1.默认构造函数1) 当没有定义任何构造函数时，编译器会提供默认构造函数，可以直接使用。2) 如果定义了带参数的构造函数，又需要使用默认构造函数，此时，必须显式定义无参构造函数，这和C#中有很大的不同。例如有一个蔬菜类Veg：Veg(const char* name,int num,double price);//声明了带三个参数的构造函数要初始化Veg对象，可使用Veg veg(“tomato”">
<meta property="og:type" content="article">
<meta property="og:title" content="C++类的构造函数详解">
<meta property="og:url" content="https://shijingjing07.github.io/2016/05/31/C++类的构造函数详解/index.html">
<meta property="og:site_name" content="迪米特">
<meta property="og:description" content="1.默认构造函数1) 当没有定义任何构造函数时，编译器会提供默认构造函数，可以直接使用。2) 如果定义了带参数的构造函数，又需要使用默认构造函数，此时，必须显式定义无参构造函数，这和C#中有很大的不同。例如有一个蔬菜类Veg：Veg(const char* name,int num,double price);//声明了带三个参数的构造函数要初始化Veg对象，可使用Veg veg(“tomato”">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/300946/201605/300946-20160531152939571-1620287468.png">
<meta property="og:updated_time" content="2017-01-12T01:35:39.317Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++类的构造函数详解">
<meta name="twitter:description" content="1.默认构造函数1) 当没有定义任何构造函数时，编译器会提供默认构造函数，可以直接使用。2) 如果定义了带参数的构造函数，又需要使用默认构造函数，此时，必须显式定义无参构造函数，这和C#中有很大的不同。例如有一个蔬菜类Veg：Veg(const char* name,int num,double price);//声明了带三个参数的构造函数要初始化Veg对象，可使用Veg veg(“tomato”">
<meta name="twitter:image" content="http://images2015.cnblogs.com/blog/300946/201605/300946-20160531152939571-1620287468.png">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">迪米特</a></h1>
    <p><a href="/">路过秋天</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/about">About</a></li>
      
        <li><a href="/atom.xml">rss</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/05/31/C++类的构造函数详解/">
  <time datetime="2016-05-30T23:30:00.000Z">
    2016-05-31
  </time>
</a>
    
    
  
    <h1 class="title">C++类的构造函数详解</h1>
  

  </header>
  
  <div class="entry">
    
      <p><strong>1.默认构造函数</strong><br>1) 当没有定义任何构造函数时，编译器会提供默认构造函数，可以直接使用。<br>2) 如果定义了带参数的构造函数，又需要使用默认构造函数，此时，必须显式定义无参构造函数，这和C#中有很大的不同。例如有一个蔬菜类Veg：<br>Veg(const char* name,int num,double price);//声明了带三个参数的构造函数<br>要初始化Veg对象，可使用<br>Veg veg(“tomato”,15,3.5);</p>
<p>3) 定义了带参数的构造函数的同时，又需要使用Veg veg;若带参数的构造函数，参数全部用默认值，如：</p>
<p>Veg(const char* name=”NONE”,int num=0,double price=0.0);<br>则可成功初始化对象，否则将报错，<br>若要使用默认构造函数，必须显式声明<br>Veg veg();//声明了默认构造函数</p>
<p><strong>2.创建并初始化对象的几种方式</strong><br>1)Veg veg(“tomato”,15,3.5);<br>在栈中，创建一个名为veg的Veg对象，并调用构造函数初始化<br>2)Veg veg=Veg(“tomato”,15,3.5);<br>和方法一原理一样<br>3)Veg veg;<br>无参构造函数或参数全部有默认值的构造函数的初始化</p>
<p>以上三种方式创建的对象，是放在栈中的，当作用域结束时，析构函数将被隐式调用，对象将被释放。</p>
<p>4)Veg *p = new veg(“tomato”,15,3.5);<br>在堆中，创建一个Veg对象，并调用构造函数初始化，并返回指向该对象的指针p<br>关于new的详细介绍，可参考 <a href="http://www.cnblogs.com/shijingjing07/p/5519153.html" target="_blank" rel="external">C++<br>new操作符详解</a></p>
<p>堆中创建的对象，在不需要使用时，要使用delete关键字，删除指针，此时析构函数会立即被隐式调用，指针指向的对象将被释放，<br>否则的话，将造成内存泄漏。</p>
<p><strong>3.对象赋值</strong><br>Veg veg1=Veg(“tomato”,15,3.5);<br>Veg veg2 = veg2;<br>属于值传递，对象中每个数据成员的值都将复制到目标对象相应的数据成员。</p>
<p><strong>4.关于只带一个参数的构造函数</strong></p>
<p>只有一个惨的构造函数初始化时，可以将对象初始化为该参数，语法如下：<br>Classname object= value;</p>
<p>编程时，我们使用了很多此种初始化方式，简洁明了，如：<br>int a(10)=&gt;int a = 10;<br>string a(“hello”)=&gt;string a= “hello”;</p>
<p>然而，很多时候，此种初始化方式，是不对的。如：<br>针对构造函数Veg(const char<em> name);我们可以直接初始化为：<br>Veg veg = name;<br>显然，Veg对象并不是一个char</em>类型的字符串，那么如何避免误用此种初始化方式呢？<br>可在构造函数声明时，加上explicit关键字，如：explicit Veg(const char* name);<br>explicit关键字的详细介绍，可参考 <a href="http://www.cnblogs.com/shijingjing07/p/5525800.html" target="_blank" rel="external">C++ explicit关键字
</a></p>
<p>5.构造函数使用示例</p>
<p>如下例所示，定义了一个蔬菜类Veg，main函数中演示了几种构造函数初始化方式。</p>
<p>Veg.h</p>
<pre><code>#pragma once
#include&lt;iostream&gt;
#include&lt;string&gt;
class Veg
{
private:
    std::string name;
    int num;
    double price;
    double total;
    void set_tot(){total = num*price;}
public:
    Veg();
    Veg(const std::string &amp;name);
    Veg(const std::string &amp;name,int num=0,double price = 0.0);
    ~Veg();
    void show();
};
</code></pre><p>Veg.cpp</p>
<pre><code>#include &quot;Veg.h&quot;
Veg::Veg()
{
    name=&quot;NONE&quot;;
    num = 0;
    price = 0.0;
    total = 0.0;
}
Veg::Veg(const std::string &amp;name)
{
    this-&gt;name=name;
}
Veg::Veg(const std::string &amp;name,int num,double price)
{
    this-&gt;name = name;
    this-&gt;num = num;
    this-&gt;price  = price;
    set_tot();
}
Veg::~Veg()
{
    std::cout&lt;&lt;&quot;~Veg()&quot;&lt;&lt;std::endl;
}
void Veg::show()
{
    std::cout&lt;&lt;&quot;name:&quot;&lt;&lt;name&lt;&lt;&quot; num:&quot;&lt;&lt;num&lt;&lt;&quot; price:&quot;&lt;&lt;price&lt;&lt;&quot; total:&quot;&lt;&lt;total&lt;&lt;std::endl;
}
</code></pre><p>useveg.cpp</p>
<pre><code>#include &quot;Veg.h&quot;
int main()
{
    Veg veg1;
    Veg veg2(&quot;tomato&quot;,15,3.5);
    Veg veg3=Veg(&quot;potato&quot;,8,2.0);
    Veg *p=new Veg(&quot;tomato&quot;,15,3.5);
    veg1.show();
    veg2.show();
    veg3.show();
    veg2 = veg3;
    veg2.show();
    veg3.show();
    delete p;
    p=NULL;
    return 0;
}
</code></pre><p>运行结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201605/300946-20160531152939571-1620287468.png" alt=""></p>
<p>参考资料：《C++ Primer.Plus》 pp.352-363</p>

    
  </div>
  <footer>
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


<section id="comment">
<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="2016/05/31/C++类的构造函数详解/" data-title="C++类的构造函数详解" data-url="https://shijingjing07.github.io/2016/05/31/C++类的构造函数详解/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"shijingjing07"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->
</section>
</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2017 <a href="/">迪米特</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
  var duoshuoQuery = { short_name: 'shijingjing07' };
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';
    ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>