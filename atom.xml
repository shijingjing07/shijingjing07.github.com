<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>迪米特</title>
  <subtitle>路过秋天</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shijingjing07.github.io/"/>
  <updated>2017-01-16T09:41:42.807Z</updated>
  <id>https://shijingjing07.github.io/</id>
  
  <author>
    <name>迪米特</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webapi应用架构详解</title>
    <link href="https://shijingjing07.github.io/2017/01/16/webapi%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"/>
    <id>https://shijingjing07.github.io/2017/01/16/webapi应用架构详解/</id>
    <published>2017-01-16T09:23:46.000Z</published>
    <updated>2017-01-16T09:41:42.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webapi适用场景"><a href="#webapi适用场景" class="headerlink" title="webapi适用场景"></a>webapi适用场景</h2><p>常见的应用包括以下四类，PC客户端程序，APP程序，网站程序，H5程序。<br>这些应用需要的数据，服务可由同一个接口服务程序提供，这样，大大提高了产品多平台设计开发的效率，避免了重复的编码。</p>
<h2 id="什么是webapi"><a href="#什么是webapi" class="headerlink" title="什么是webapi"></a>什么是webapi</h2><p>webapi一般采用restful风格。以tornado为例,url路由配置如下：  </p>
<pre><code>url = [
    (r&apos;/test&apos;, testfc.testHandler)
]
</code></pre><p>业务逻辑层,返回数据一般为json格式：  </p>
<pre><code>class testHandler(RequestHandler):
    def get(self):
        self.post()
    def post(self):
        result={}
        if True:
            result[&quot;code&quot;]=&quot;200&quot;
            result[&quot;status&quot;]=&quot;true&quot;
            result[&quot;result&quot;]=&quot;success&quot;
        else:
            result[&quot;code&quot;]=&quot;300&quot;
            result[&quot;status&quot;]=&quot;false&quot;
            result[&quot;result&quot;]=&quot;fail&quot;
        self.write(json_encode(result))
        return
</code></pre><p>webapi访问方式如下：</p>
<pre><code>http://127.0.0.1:9999/test
</code></pre><p>返回结果：</p>
<pre><code>{&quot;status&quot;: &quot;true&quot;, &quot;code&quot;: &quot;200&quot;, &quot;result&quot;: &quot;success&quot;}
</code></pre><h2 id="webapi架构设计"><a href="#webapi架构设计" class="headerlink" title="webapi架构设计"></a>webapi架构设计</h2><p>如何确认一个app能够访问webapi?<br>使用AppID验证app访问webapi的合法性，AppID为服务端给出的一个ID标志。<br>我们可以为web/app/winform分别分配一个ID，从而可以确定访问的合法性，和访问的渠道。  </p>
<p>如何保证app参数的正确性，没有被篡改？<br>客户端使用AppID对应的AppSecert，对参数进行签名(MD5/SHA等)<br>服务端使用同样的方式签名，和客户端签名校验。  </p>
<p>如何防止webapi url被截获，重新访问？<br>客户端访问webapi时带上时间戳参数，服务端对时间戳进行校验，如10分钟内的访问才是有效的。  </p>
<p>涉及具体用户的操作时，如何验证用户？<br>可以使用username,psw参数的方式访问webapi。但是这种方式很不安全。<br>使用授权token是很好的解决办法。在用户登录成功时，服务端生成一个授权码，对应用户信息。<br>访问时带上token参数，服务端查询token有效性，和token对应的用户信息。  </p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>登录代码如下：  </p>
<pre><code>import uuid
import redis
class testLoginHandler(BaseHandler):
    def get(self):
        self.post()
    def post(self):
        #获取url参数
        args=self.request.arguments
        data={}
        for key in args:
            data[key]=self.get_argument(key,&quot;&quot;)
        #验证url参数
        valiResult=valiUrldata(data)
        if valiResult[&quot;code&quot;]==&quot;300&quot;:
            self.write(json_encode(valiResult).decode(&quot;unicode_escape&quot;))
            return
        username=self.get_argument(&quot;username&quot;,&quot;&quot;)
        psw=self.get_argument(&quot;psw&quot;,&quot;&quot;)
        if username==&quot;shijingjing07&quot; and psw==&quot;123456&quot;:
            token = uuid.uuid1()
            redisPool = redis.ConnectionPool(host=&apos;127.0.0.1&apos;,password=&apos;123456&apos;, port=6379, db=0)
            cache = redis.Redis(connection_pool=redisPool)
            cache.setex(token,username,300)
            result[&quot;code&quot;] = 200
            result[&quot;status&quot;] = &quot;true&quot;
            result[&quot;result&quot;] = token
        else:
            result[&quot;code&quot;] = 300
            result[&quot;status&quot;] = &quot;false&quot;
            result[&quot;result&quot;] = &quot;account illegal&quot;
        self.write(json_encode(result))
</code></pre><p>返回结果：  </p>
<pre><code>{&quot;status&quot;: &quot;true&quot;, &quot;code&quot;: 200, &quot;result&quot;: &quot;5720c334-dbcc-11e6-84f1-00163e001071&quot;}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;webapi适用场景&quot;&gt;&lt;a href=&quot;#webapi适用场景&quot; class=&quot;headerlink&quot; title=&quot;webapi适用场景&quot;&gt;&lt;/a&gt;webapi适用场景&lt;/h2&gt;&lt;p&gt;常见的应用包括以下四类，PC客户端程序，APP程序，网站程序，H5程序。&lt;b
    
    </summary>
    
      <category term="架构" scheme="https://shijingjing07.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>cookie欺骗</title>
    <link href="https://shijingjing07.github.io/2017/01/06/cookie%E6%AC%BA%E9%AA%97/"/>
    <id>https://shijingjing07.github.io/2017/01/06/cookie欺骗/</id>
    <published>2017-01-05T23:55:00.000Z</published>
    <updated>2017-01-12T01:35:13.340Z</updated>
    
    <content type="html"><![CDATA[<p>1.什么是cookie欺骗<br>改变cookie的值，发给服务器，就是cookie欺骗。<br>正常情况下，受浏览器的内部cookie机制所限，每个cookie只能被它的原服务器所访问，我们操作不了原服务器。</p>
<p>2.cookie使用示例</p>
<p>index.html 写入cookie {‘username’:’zhangsan’,’psw’:’123’}</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;jquery.cookie.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        $.cookie(&apos;username&apos;, &quot;zhangsan&quot;);
        $.cookie(&apos;psw&apos;, &quot;123&quot;);
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>运行index.html,通过Chrome F12开发者工具，可以看到cookie信息。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201701/300946-20170106155059847-848303078.png" alt=""></p>
<p>可以看到cookie要和domain域名对应。每个cookie只能被对应的域名所访问，其他域名无法访问。</p>
<p>3.如何进行cookie欺骗</p>
<p>修改hosts，将域名(dev.test.com)对应的ip转为自己的ip(121.43.113.200)，写在自己的ip下修改cookie，会发现域名对应的cookie更改了。<br>步骤：<br>1)修改host<br>121.43.113.200 dev.test.com<br>2)将index.html放入服务器121.43.113.200<br>3)访问url:dev.test.com/index.html<br>4)查看cookie信息<br><img src="http://images2015.cnblogs.com/blog/300946/201701/300946-20170106155240675-1380622233.png" alt=""><br>5)还原host  </p>
<p>#121.43.113.200 dev.test.com<br>6)访问url:dev.test.com，会发现dev.test.com中的cookie已被修改。</p>
<p>4.cookie欺骗防止<br>随机码防止cookie欺骗<br>原理：在服务端生成唯一随机码，每次提交cookie时带上随机码，和服务端的随机码校验。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.什么是cookie欺骗&lt;br&gt;改变cookie的值，发给服务器，就是cookie欺骗。&lt;br&gt;正常情况下，受浏览器的内部cookie机制所限，每个cookie只能被它的原服务器所访问，我们操作不了原服务器。&lt;/p&gt;
&lt;p&gt;2.cookie使用示例&lt;/p&gt;
&lt;p&gt;inde
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nginx文件目录权限设置</title>
    <link href="https://shijingjing07.github.io/2016/12/30/nginx%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/"/>
    <id>https://shijingjing07.github.io/2016/12/30/nginx文件目录权限设置/</id>
    <published>2016-12-30T01:43:00.000Z</published>
    <updated>2017-01-12T01:35:13.372Z</updated>
    
    <content type="html"><![CDATA[<p>1.有时我们web服务器上的某个文件夹只允许特定人员访问，这时我们需要在nginx配置文件中配置该文件夹的访问权限。</p>
<p>2.生成用户名单<br>在nginx中我们使用htpasswd来生成用户名单<br>下载这个python文件：<a href="http://trac.edgewall.org/export/10770/trunk/contrib/htpasswd.py" target="_blank" rel="external">http://trac.edgewall.org/export/10770/trunk/contrib/htpasswd.py</a><br>（nginx wiki里推荐的）<br>运行示例：</p>
<pre><code>chmod 777 htpasswd.py
./htpasswd.py -c -b htpasswd username password
</code></pre><p>#-c为生成文件 htpasswd为文件名</p>
<p>nginx 的 http auth basic 的密码是用 crypt(3) 加密的<br>我们把生成的htpasswd文件放到/etc/nginx目录中，修改权限chmod 400 htpasswd来保护一下该文件。</p>
<p>3.修改nginx配置文件</p>
<pre><code>server {
server_name www.test.com;
root /usr/share/nginx/html;
location /devdoc {
autoindex on;#显示文件列表
index index.html index.htm;#默认首页
charset utf-8;#编码
auth_basic &quot;Restricted&quot;;#访问权限类型
auth_basic_user_file /etc/nginx/htpasswd;#用户名单
}
}
</code></pre><p>重启nginx即可。访问网站www.test.com/devdoc，需要输入我们设置的用户名密码登录才能访问文件。如下图所示：<br><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161230174155304-2076405830.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.有时我们web服务器上的某个文件夹只允许特定人员访问，这时我们需要在nginx配置文件中配置该文件夹的访问权限。&lt;/p&gt;
&lt;p&gt;2.生成用户名单&lt;br&gt;在nginx中我们使用htpasswd来生成用户名单&lt;br&gt;下载这个python文件：&lt;a href=&quot;http://
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSRF攻击</title>
    <link href="https://shijingjing07.github.io/2016/12/30/CSRF%E6%94%BB%E5%87%BB/"/>
    <id>https://shijingjing07.github.io/2016/12/30/CSRF攻击/</id>
    <published>2016-12-29T19:00:00.000Z</published>
    <updated>2017-01-12T01:35:13.408Z</updated>
    
    <content type="html"><![CDATA[<p>1.什么是CSRF攻击<br>CSRF(Cross-site request forgery)，跨站请求伪造。<br>CSRF攻击的原理如下：<br>1)用户登录正常的网站A后，在本地生成Cookie<br>2)在不登出A的情况下，访问了危险网站B<br>3)网站B中含有网站A的链接，点击网站A的链接，会调用本地cookie验证，自动登录网站A。</p>
<p>CSRF攻击源于WEB的隐式身份验证机制，WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。</p>
<p>2.原理图如下：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161230105937070-1267632684.png" alt=""></p>
<p>3.CSRF的防御<br>1)Cookie Hashing(所有表单都包含同一个伪随机值)：<br>CSRF的问题在于网站验证cookie存在的情况下，黑客可以直接登录网站。<br>我们可以在访问网站时，生成一个伪随机数，访问网站每个页面时带上这个伪随机数，服务端验证cookie和伪随机数是否一致。<br>这样可以确保网站A的链接不是由第三方网站直接跳转过来的，因为第三方网站是无法获得网站的cookie伪随机数的。</p>
<p>2)验证码<br>登录网站时设置验证码，是很常用的方式，可以完全解决CSRF的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.什么是CSRF攻击&lt;br&gt;CSRF(Cross-site request forgery)，跨站请求伪造。&lt;br&gt;CSRF攻击的原理如下：&lt;br&gt;1)用户登录正常的网站A后，在本地生成Cookie&lt;br&gt;2)在不登出A的情况下，访问了危险网站B&lt;br&gt;3)网站B中含有网
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP长连接和短连接</title>
    <link href="https://shijingjing07.github.io/2016/12/28/HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5/"/>
    <id>https://shijingjing07.github.io/2016/12/28/HTTP长连接和短连接/</id>
    <published>2016-12-28T03:21:00.000Z</published>
    <updated>2017-01-12T01:35:13.464Z</updated>
    
    <content type="html"><![CDATA[<p>1.HTTP协议的五大特点<br>1)支持客户/服务器模式<br>2)简单快速<br>3)灵活<br>4)无连接<br>每次连接只处理一个请求，服务器处理完客户的请求，并受到客户的应答后，断开连接。<br>5)无状态<br>协议不会记录服务器客户端状态。</p>
<p>2.保持HTTP连接状态的两种方式<br>1)Cookie<br>在访问统一网站时，可以将信息写入cookie，方便在不同的页面间提取信息。</p>
<p>2)Session<br>Session保存在服务器上，同时将标识Session的SessionId传递给客户端浏览器，保存在cookie中，浏览器关闭后，这个cookie就会被清掉。</p>
<p>浏览器每次请求都会额外加上这个参数值，服务器根据这个SessionId，就能取得客户端的数据信息。</p>
<p>3.什么是HTTP长连接，短连接<br>HTTP的长连接，短连接本质上是TCP长连接，短连接。</p>
<p>在HTTP/1.0中，默认使用的是短连接。<br>即浏览器和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。这样，如果一个网页中包含其他的web资源，如JavaScript文件，图像文件，CSS文件等，都需要建立连接。</p>
<p>从HTTP/1.1起，默认使用长连接。我们可以看到响应头有这样一行代码：Connection:keep-alive<br>当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这条已经建立的连接。</p>
<p>4.长连接短连接操作过程<br>短连接的操作步骤是：<br>建立连接—-数据传输—-关闭连接…建立连接—-数据传输—-关闭连接<br>长连接的操作步骤是：<br>建立连接—-数据传输…（保持连接）…数据传输—-关闭连接</p>
<p>5.长连接短连接的优缺点<br>长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。<br>Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭长时间没有读写事件的连接；限制每个客户端的最大长连接数。<br>短连接对服务器来说管理较为简单，存在的连接都是有用的连接。但如果客户请求频繁，将在TCP的建立和关闭上浪费时间和带宽。</p>
<p>6.长连接短连接使用场合<br>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。如数据库的连接。<br>而像web网站的http服务一般用短连接，因为长连接对于服务端来说会耗费一定的资源，而像web网站这么频繁的成千上万甚至上亿客户端的连接用短连接更省资源，如果用长连接，而且同时有成千上万的用户。如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作的情况下用短连接好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.HTTP协议的五大特点&lt;br&gt;1)支持客户/服务器模式&lt;br&gt;2)简单快速&lt;br&gt;3)灵活&lt;br&gt;4)无连接&lt;br&gt;每次连接只处理一个请求，服务器处理完客户的请求，并受到客户的应答后，断开连接。&lt;br&gt;5)无状态&lt;br&gt;协议不会记录服务器客户端状态。&lt;/p&gt;
&lt;p&gt;2.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>类与类之间的关系-依赖，关联，聚合，组合，继承泛化的区别</title>
    <link href="https://shijingjing07.github.io/2016/12/28/%E7%B1%BB%E4%B8%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB-%E4%BE%9D%E8%B5%96%EF%BC%8C%E5%85%B3%E8%81%94%EF%BC%8C%E8%81%9A%E5%90%88%EF%BC%8C%E7%BB%84%E5%90%88%EF%BC%8C%E7%BB%A7%E6%89%BF%E6%B3%9B%E5%8C%96%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://shijingjing07.github.io/2016/12/28/类与类之间的关系-依赖，关联，聚合，组合，继承泛化的区别/</id>
    <published>2016-12-27T18:16:00.000Z</published>
    <updated>2017-01-12T01:35:13.545Z</updated>
    
    <content type="html"><![CDATA[<p>1)依赖<br>依赖关系是类与类之间的联接。一个类依赖于另一个类的定义。如，一个人(Person)可以买车(Car)和房子(House),Person类依赖于Car和House的定义，因为Person引入了Car和House。与关联不同的是，Person类中没有Car和House的属性，Car和House的实例是以参量的方式传入到buy()方法中的。一般而言，依赖关系在Java语言中体现为局部变量，方法形参，或者对静态方法的调用。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161228101136961-696404574.png" alt=""></p>
<p>2)关联<br>关联是类与类之间的联接，使一个类知道另一个类的属性和方法。关联可以是双向，也可以是单向的。一般使用成员变量来实现。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161228101151773-384156678.png" alt=""></p>
<p>3)聚合<br>聚合是一种强的关联关系。是整体和个体之间的关系。例如，汽车类与引擎类，轮胎类之间的关系就是整体与个体之间的关系。与关联关系一样，聚合关系也是通过实例变量实现的。但是关联关系涉及的两个类在同一层次，而聚合关系中两个类处在不平等的层次上，一个代表整体，一个代表部分。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161228101335851-1483683152.png" alt=""></p>
<p>4)组合<br>组合也是关联关系的一种，一种比聚合关系强的关系。组合关系中的部分类不能独立于整体类存在。整体类和部分类有相同的生命周期。如Person类和Leg类。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161228101350570-1896750592.png" alt=""></p>
<p>5)继承/泛化<br>泛化和继承其实是一个逆过程 泛化就是有子类抽象出一个父类 而继承就是由父类具体化一个子类 例如足球比联赛跟什么西甲 意甲 英超之间就是泛化/继承的关系</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161228101408773-94063945.png" alt=""></p>
<p>6)组合和聚合的区别<br>组合和聚合都属于关联，所以它们之间难免有相似之处，区别举例来说明：<br>程老师的《大话》里举大那个大雁的例子很贴切 在此我就借用一下 大雁喜欢热闹害怕孤独 所以它们一直过着群居的生活 这样就有了雁群 每一只大雁都有自己的雁群<br>每个雁群都有好多大雁 大雁与雁群的这种关系就可以称之为聚合 另外每只大雁都有两只翅膀 大雁与雁翅的关系就叫做组合 有此可见 聚合的关系明显没有组合紧密<br>大雁不会因为它们的群主将雁群解散而无法生存 而雁翅就无法脱离大雁而单独生存—-组合关系的类具有相同的生命周期<br>聚合关系图：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161228101435898-1130053478.png" alt=""></p>
<p>聚合关系图：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161228101455429-49000952.png" alt=""></p>
<p>雁群类：</p>
<pre><code>public class GooseGroup
{
    publi Goose goose;
    public GooseGroup(Goose goose){
        this.goose=goose;
    }
}
</code></pre><p>大雁类：</p>
<pre><code>public class Goose{
    public Wings wings;
    public Goose()
    {
        wings=new Wings();
    }
}    
</code></pre><p>从构造函数来看，GooseGroup的构造函数要用到Goose作为参数把值传进来，Goose可以脱离GooseGroup独立存在。<br>组合关系中整体类含有部分类的实例化，Goose在实例化之前，一定要先实例化Wings，两个类紧密耦合在一起，它们有相同的生命周期，Wings不能独立于Goose存在。</p>
<p>从信息封装来看，聚合关系中，客户端同时了解GooseGroup和Goose，因为它们是独立的。<br>而在组合关系中，客户端只认识大雁类，根本不知道翅膀类的存在，因为翅膀类被严密封装在大雁类中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1)依赖&lt;br&gt;依赖关系是类与类之间的联接。一个类依赖于另一个类的定义。如，一个人(Person)可以买车(Car)和房子(House),Person类依赖于Car和House的定义，因为Person引入了Car和House。与关联不同的是，Person类中没有Car和Ho
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式六大原则</title>
    <link href="https://shijingjing07.github.io/2016/12/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>https://shijingjing07.github.io/2016/12/27/设计模式六大原则/</id>
    <published>2016-12-27T06:19:00.000Z</published>
    <updated>2017-01-12T01:35:14.551Z</updated>
    
    <content type="html"><![CDATA[<p>1.设计模式的目的<br>设计模式是为了更好的代码重用性，可读性，可靠性，可维护性。</p>
<p>2.常用的六大设计模式<br>1)单一职责原则<br>2)里氏替换原则<br>3)依赖倒转原则<br>4)接口隔离原则<br>5)迪米特法则<br>6)开闭原则</p>
<p>3.单一职责原则<br>该原则是针对类来说的，即一个类应该只负责一项职责。<br>如类T负责两个不同职责：职责P1，职责P2。当职责P1需求变更而改变T时，可能造成职责P2发生故障，所以需要将类T的粒度分解为T1，T2。<br>示例如下：<br>用一个类秒数动物呼吸这个场景</p>
<pre><code>class Animal {
    public void breathe(string animal)
    {
        Console.WriteLine(animal+&quot;呼吸空气&quot;);
    }
}
class Program
{
    static void Main(string[] args)
    {
        Animal animal = new Animal();
        animal.breathe(&quot;牛&quot;);
        animal.breathe(&quot;羊&quot;);
        animal.breathe(&quot;猪&quot;);
        animal.breathe(&quot;鱼&quot;);
        Console.ReadLine();
    }
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161227221245086-1277429426.png" alt=""></p>
<p>我们发现不是所有动物都是呼吸空气的，比如鱼就是呼吸水的，根据单一职责原则，我们将Animal类细分为陆生动物类和水生动物类，如下所示：</p>
<pre><code>class Terrestrial
{
    public void breathe(string animal)
    {
        Console.WriteLine(animal+&quot;呼吸空气&quot;);
    }
}
class Aquatic
{
    public void breathe(string animal)
    {
        Console.WriteLine(animal + &quot;呼吸水&quot;);
    }
}
class Program
{
    static void Main(string[] args)
    {
        Terrestrial terrestrial = new Terrestrial();
        terrestrial.breathe(&quot;牛&quot;);
        terrestrial.breathe(&quot;羊&quot;);
        terrestrial.breathe(&quot;猪&quot;);
        Aquatic aquatic = new Aquatic();
        aquatic.breathe(&quot;鱼&quot;);
        Console.ReadLine();
    }
}
</code></pre><p>我们发现这样修改的花销很大，既要将原来的类分解，又要修改客户端。而直接修改Animal类虽然违背了单一职责原则，但花销小的多，如下所示：</p>
<pre><code>class Animal
{
    public void breathe(string animal)
    {
        if (&quot;鱼&quot;.Equals(animal))
        {
            Console.WriteLine(animal + &quot;呼吸水&quot;);
        }
        else {
            Console.WriteLine(animal + &quot;呼吸空气&quot;);
        }
    }
}
class Program
{
    static void Main(string[] args)
    {
        Animal animal = new Animal();
        animal.breathe(&quot;牛&quot;);
        animal.breathe(&quot;羊&quot;);
        animal.breathe(&quot;猪&quot;);
        animal.breathe(&quot;鱼&quot;);
        Console.ReadLine();
    }
}
</code></pre><p>可以看到，这种修改方式简单的多。但却存在隐患，一天需要将鱼分为淡水鱼，海水鱼，又需要修改Animal类的breathe方法。可能给”猪牛羊”等相关功能带来风险，这种修改直接在代码级别违背了单一职责原则，虽然修改起来最简单，但隐患最大。还有一种修改方式：</p>
<pre><code>class Animal
{
    public void breathe(string animal)
    {
         Console.WriteLine(animal + &quot;呼吸空气&quot;);
    }
    public void breathe2(string animal)
    {
        Console.WriteLine(animal + &quot;呼吸水&quot;);
    }
}
class Program
{
    static void Main(string[] args)
    {
        Animal animal = new Animal();
        animal.breathe(&quot;牛&quot;);
        animal.breathe(&quot;羊&quot;);
        animal.breathe(&quot;猪&quot;);
        animal.breathe2(&quot;鱼&quot;);
        Console.ReadLine();
    }
} 
</code></pre><p>这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然违背了单一职责原则，但在方法级别上却是符合单一职责原则的。那么在实际编程中，采用哪一种呢？我的原则是，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，才可以在方法级别违反单一职责原则。</p>
<p>遵循单一职责的优点：<br>1)降低类的复杂度，一个类只负责一项职责。<br>2)提高类的可读性，可维护性<br>3)降低变更引起的风险。</p>
<p>4.里氏替换原则<br>该原则是在1988年，由麻省理工学院的以为姓里的女士提出的。<br>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。<br>换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</p>
<p>由定义可知，在使用继承时，遵循里氏替换原则，在子类中尽量不要重写和重载父类的方法。<br>继承包含这样一层含义：父类中凡是已经实现好的方法（相对抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。<br>继承作为面向对象三大特性之一，在给程序设计带来巨大遍历的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。<br>举例说明继承的风险，我们需要完成一个两数相减的功能，由类A来负责。</p>
<pre><code>class A{
    public int func1(int a,int b){
        return a-b;
    }
}
public class Client{
    public static void main(string[] args){
        A a=new A();
        System.out.println(&quot;100-50=&quot;+a.func1(100,50));
        System.out.println(&quot;100-80=&quot;+a.func1(100,80));
    }
}
</code></pre><p>运行结果：</p>
<p>100-50=50<br>100-80=20</p>
<p>后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。</p>
<pre><code>Class B extends A{
    public int func1(int a,int b){
        return a+b;
    }
    public int func2(int a,int b){
        return func1(a,b)+100;
    }
}
public class Client{
    public static void main(string[] args){
        B a=new B();
        System.out.println(&quot;100-50=&quot;+b.func1(100,50));
        System.out.println(&quot;100-80=&quot;+b.func1(100,80));
        System.out.println(&quot;100+20+100=&quot;+b.func2(100,20));
    }
}
</code></pre><p>运行结果：</p>
<p>100-50=150<br>100-80=180<br>100+20+100=220</p>
<p>我们发现原来运行正常的相减功能发生了错误。原因就是类B无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候，如果非要重写父类的方法，通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替。</p>
<p>5.依赖倒转原则<br>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。<br>类A直接依赖类B，如果要将类A改为依赖类C，则必须通过修改类A的代码来达成。此时，类A一般是高层模块，负责复杂的业务逻辑，类B和类C是低层模块，负责基本的原子操作；修改A会给程序带来风险。<br>将类A修改未依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或类C发生联系，则会大大降低修改类A的记几率。<br>依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类，使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。<br>依赖倒置的中心思想是面向接口编程。</p>
<p>代码示例如下：</p>
<pre><code>class Book {
    public string getContent() {
        return &quot;很久很久以前。。。。。&quot;;
    }
}
class Mother {
    public void narrate(Book book)
    {
        Console.WriteLine(book.getContent());
    }
}
class Program
{
    static void Main(string[] args)
    {
        Mother monther = new Mother();
        monther.narrate(new Book());
        Console.ReadLine();
    }
}
</code></pre><p>运行结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161227221502773-795863634.png" alt=""></p>
<p>如果读的对象是报纸，杂志，却发现客户端不适用了。<br>我们引入一个抽象的接口IReader,代表读物</p>
<pre><code>interface IReader{
    public string getContent();
}
</code></pre><p>这样Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，修改代码如下：</p>
<pre><code>interface IReader {
         string getContent();
    }
    class Newspaper: IReader
    {
    public string getContent()
    {
        return &quot;切尔西豪取12连胜&quot;;
    }
}
class Book:IReader
{

    public string getContent()
{
    return &quot;很久很久以前。。。。&quot;;
}
}
class Mother
{
    public void narrate(IReader reader)
    {
        Console.WriteLine(reader.getContent());
    }
}
class Program
{
    static void Main(string[] args)
    {
        Mother monther = new Mother();
        monther.narrate(new Book());
        monther.narrate(new Newspaper());
        Console.ReadLine();
    }
}
</code></pre><p>运行结果:</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161227221546539-427144726.png" alt=""></p>
<p>采用依赖倒置原则给多人并行开发带来极大的便利，比如上列中Mother类与Book类直接耦合，Mother必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序可以同时开工，互不影响。<br>依赖关系的传递有三种方式，接口传递，构造方法传递和setter方法传递。<br>接口传递：</p>
<pre><code>interface IDriver{
    public void drive(ICar car);
}
public class Driver:IDriver{
    public void drive(ICar car){
        car.run();
    }
}
</code></pre><p>构造方法传递：</p>
<pre><code>interface IDriver{
    public void drive();
}
public class Driver implements IDriver{
    public ICar car;
    public Driver(ICar _car){
        this.car=_car;
    }
    public void drive(){
        this.car.run();
    }
}
</code></pre><p>setter方式传递：</p>
<pre><code>interface IDriver{
    public void setCar(ICar car);
    public void drive();
}
public class Driver:IDriver{
    PRIVATE ICar car;
    public void setCar(ICar car){
        this.car=car;
    }
    public void drive(){
        this.car.run();
    }
}
</code></pre><p>在实际编程中，一般需要做到如下3点：<br>低层模块尽量都要有抽象类或接口，或者两者都有。<br>变量的声明类型尽量是抽象类或接口。<br>使用继承时遵循里氏替换原则</p>
<p>6.接口隔离原则<br>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。<br>类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类C来说不是最小接口，则类B和类D必须去实现他们不需要的方法。<br>将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。<br>举例说明接口隔离原则：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161227221656132-1065812137.png" alt=""></p>
<p>这个图的意思是：类A依赖接口I中的方法1，方法2，方法3，类B是对类A依赖的实现；类C依赖接口I中的方法1，方法4，方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然存在用不到的方法（红色标记所示），但由于实现了接口I，所以也必须要实现这些用不到的方法。代码如下：</p>
<pre><code>interface I{
    void method1();
    void method2();
    void method3();
    void method4();
    void method5();
}
class A{
    public void depend1(I i){
        i.method1();
    }
    public void depend2(I i){
        i.method2();
    }
    public void depend3(I i){
        i.method3();
    }
}
class C{
    public void depend1(I i){
        i.method1();
    }
    public void depend2(I i){
        i.method4();
    }
    public void depend3(I i){
        i.method5();
    }
}
class B:I{
    public void method1(){
        Console.WriteLine(&quot;类B实现接口I的方法1&quot;);
    }
    public void method2(){
        Console.WriteLine(&quot;类B实现接口I的方法2&quot;);
    }
    public void method3(){
        Console.WriteLine(&quot;类B实现接口I的方法3&quot;);
    }
    public void method4(){}
    public void method5(){}
}
class D:I{
    public void method1(){
        Console.WriteLine(&quot;类B实现接口I的方法1&quot;);
    }
    public void method2(){}
    public void method3(){}
    public void method4(){
        Console.WriteLine(&quot;类B实现接口I的方法4&quot;);
    }
    public void method5(){
        Console.WriteLine(&quot;类B实现接口I的方法5&quot;);
    }
}
class Program
{
    static void Main(string[] args)
    {
        A a=new A();
        a.depend1(new B());
        a.depend2(new B());
        a.depend3(new B());

        C c=new C();
        c.depend1(new D());
        c.depend2(new D());
        c.depend3(new D());
        Console.ReadLine();
    }
}
</code></pre><p>可以看到，接口中出现的方法，不管对依赖于它的类有没有作用，实现类中都必须去实现这些方法。于是我们将原接口I拆分为三个接口：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161227221732117-1230926316.png" alt=""></p>
<p>代码如下所示：</p>
<pre><code>interface I1{
    void method1();
}
interface I2{
    void method2();
    void method3();
}
interface I3{
    void method4();
    void method5();
}
class A{
    public void depend1(I1 i){
        i.method1();
    }
    public void depend2(I2 i){
        i.method2();
    }
    public void depend3(I2 i){
        i.method3();
    }
}
class C{
    public void depend1(I1 i){
        i.method1();
    }
    public void depend2(I3 i){
        i.method4();
    }
    public void depend3(I3 i){
        i.method5();
    }
}
class B:I1,I2{
    public void method1(){
        Console.WriteLine(&quot;类B实现接口I1的方法1&quot;);
    }
    public void method2(){
        Console.WriteLine(&quot;类B实现接口I2的方法2&quot;);
    }
    public void method3(){
        Console.WriteLine(&quot;类B实现接口I2的方法3&quot;);
    }
}
class D:I1,I3{
    public void method1(){
        Console.WriteLine(&quot;类B实现接口I的方法1&quot;);
    }
    public void method4(){
        Console.WriteLine(&quot;类B实现接口I的方法4&quot;);
    }
    public void method5(){
        Console.WriteLine(&quot;类B实现接口I的方法5&quot;);
    }
}
class Program
{
    static void Main(string[] args)
    {
        A a=new A();
        a.depend1(new B());
        a.depend2(new B());
        a.depend3(new B());

        C c=new C();
        c.depend1(new D());
        c.depend2(new D());
        c.depend3(new D());
        Console.ReadLine();
    }
}
</code></pre><p>说到这里，可能会觉得接口隔离原则和之前的单一职责原则很相似，其实不然。一，单一职责注重职责，而接口隔离原则注重对接口依赖的隔离；二，单一职责是约束类，其次是方法，针对的是程序中的实现和细节；而接口隔离原则约束的是接口，针对的是抽象，程序整体框架的构建。</p>
<p>7.迪米特法则<br>一个对象应该对其他对象保持最少的了解。<br>类与类关系越密切，耦合度越大。<br>迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public<br>方法，不对外泄露任何信息。<br>迪米特法则还有个更简单的定义：只与直接的朋友通信。<br>什么是直接的朋友：每个对象都会与其他对象由耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。<br>举例额说明如下，有一个集团公司，下属单位有分公司和直属部门，现要求打印出所有下属单位的员工ID。</p>
<pre><code>class Employee{
    private string id;
    public void setId(string id){
        this.id=id;
    }
    public string getId(){
        return id;
    }
}
class SubEmployee{
    private string id;
    public void setId(string id){
        this.id=id;
    }
    public string getId(){
        return id;
    }
}
class SubCompanyManager{
    public List&lt;SubEmployee&gt; getAllEmployee(){
        List&lt;SubEmployee&gt; list=new ArrayList(SubEmployee);
        for(int i=0;i&lt;100;i++){
            SubEmployee emp=new SubEmployee();
            emp.setId(&quot;分公司&quot;+i);
            list.add(emp);
        }
        return list;
    }
}
class CompanyManager{
    public List&lt;Employee&gt; getAllEmployee(){
        List&lt;Employee&gt; list=new ArrayList&lt;Employee&gt;();
        for(int i=0;i&lt;30;i++)
        {
            Employee emp=new Employee();
            emp.setId(&quot;总公司&quot;+i);
            list.add(emp);
        }
        return list;
    }
    publi void printAllEmployee(SubCompanyManager sub){
        List&lt;SubEmployee&gt; list1=sub.getAllEmployee();
        foreach(SubEmployee e in list1){
            Console.WriteLine(e.getId());
        }
        List&lt;Employee&gt; list2=this.getAllEmployee();
        foreach(Employee e in list2){
            Console.WriteLine(e.getId());
        }
    }
}
class Program
{
    static void Main(string[] args)
    {
        CompanyManager e=new CompanyManager();
        e.printAllEmployee(new SubCompanyManager());
        Console.ReadLine();
    }
}
</code></pre><p>这个设计的问题在于CompanyManager中，SubEmployee类并不是CompanyManager类的直接朋友，按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:</p>
<pre><code>class SubCompanyManager{
    public List&lt;SubEmployee&gt; getAllEmployee(){
        List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;();
        for(int i=0; i&lt;100; i++){
            SubEmployee emp = new SubEmployee();
            //为分公司人员按顺序分配一个ID
            emp.setId(&quot;分公司&quot;+i);
            list.add(emp);
        }
        return list;
    }
    public void printEmployee(){
        List&lt;SubEmployee&gt; list = this.getAllEmployee();
        for(SubEmployee e:list){
            System.out.println(e.getId());
        }
    }
}
class CompanyManager{
    public List&lt;Employee&gt; getAllEmployee(){
        List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();
        for(int i=0; i&lt;30; i++){
            Employee emp = new Employee();
            //为总公司人员按顺序分配一个ID
            emp.setId(&quot;总公司&quot;+i);
            list.add(emp);
        }
        return list;
    }

    public void printAllEmployee(SubCompanyManager sub){
        sub.printEmployee();
        List&lt;Employee&gt; list2 = this.getAllEmployee();
        for(Employee e:list2){
            System.out.println(e.getId());
        }
    }
}
</code></pre><p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。</p>
<p>8.开闭原则<br>一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节。<br>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。<br>当我们遵循前面介绍的5大原则，以及使用23中设计模式的目的就是遵循开闭原则。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.设计模式的目的&lt;br&gt;设计模式是为了更好的代码重用性，可读性，可靠性，可维护性。&lt;/p&gt;
&lt;p&gt;2.常用的六大设计模式&lt;br&gt;1)单一职责原则&lt;br&gt;2)里氏替换原则&lt;br&gt;3)依赖倒转原则&lt;br&gt;4)接口隔离原则&lt;br&gt;5)迪米特法则&lt;br&gt;6)开闭原则&lt;/p&gt;
&lt;p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【python】多进程锁multiprocess.Lock</title>
    <link href="https://shijingjing07.github.io/2016/12/20/%E3%80%90python%E3%80%91%E5%A4%9A%E8%BF%9B%E7%A8%8B%E9%94%81multiprocess.Lock/"/>
    <id>https://shijingjing07.github.io/2016/12/20/【python】多进程锁multiprocess.Lock/</id>
    <published>2016-12-20T05:42:00.000Z</published>
    <updated>2017-01-12T01:35:15.023Z</updated>
    
    <content type="html"><![CDATA[<p>#<br><a href="http://blog.csdn.net/moxiaomomo/article/details/11640439" target="_blank" rel="external">【python】多进程锁multiprocess.Lock</a></p>
<p>2013-09-13 13:48 11613人阅读<br><a href="http://blog.csdn.net/moxiaomomo/article/details/11640439#comments" target="_blank" rel="external">评论</a>(2) 收藏<br><a href="http://blog.csdn.net/moxiaomomo/article/details/11640439#report" title="举报" target="_blank" rel="external">举报</a></p>
<p><img src="http://static.blog.csdn.net/images/category_icon.jpg" alt=""> 分类：</p>
<p>Python（38） <img src="http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg" alt=""></p>
<p>同步的方法基本与多线程相同。</p>
<p>1) Lock</p>
<p>当多个进程需要访问共享资源的时候，Lock可以用来避免访问的冲突。</p>
<p><strong>[python]</strong> <a href="http://blog.csdn.net/moxiaomomo/article/details/11640439#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/moxiaomomo/article/details/11640439#" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li>import multiprocessing  </li>
<li>import sys  </li>
<li></li>
<li>def worker_with(lock, f):  </li>
<li>with lock:  </li>
<li>fs = open(f,”a+”)  </li>
<li>fs.write(‘Lock acquired via with\n’)  </li>
<li>fs.close()  </li>
<li></li>
<li>def worker_no_with(lock, f):  </li>
<li>lock.acquire()  </li>
<li>try:  </li>
<li>fs = open(f,”a+”)  </li>
<li>fs.write(‘Lock acquired directly\n’)  </li>
<li>fs.close()  </li>
<li>finally:  </li>
<li>lock.release()  </li>
<li></li>
<li>if <strong>name</strong> == “<strong>main</strong>“:  </li>
<li></li>
<li>f = “file.txt”  </li>
<li></li>
<li>lock = multiprocessing.Lock()  </li>
<li>w = multiprocessing.Process(target=worker_with, args=(lock, f))  </li>
<li>nw = multiprocessing.Process(target=worker_no_with, args=(lock, f))  </li>
<li></li>
<li>w.start()  </li>
<li>nw.start()  </li>
<li></li>
<li>w.join()  </li>
<li>nw.join()  </li>
</ol>
<p>在上面的例子中，如果两个进程没有使用lock来同步,则他们对同一个文件的写操作可能会出现混乱。</p>
<p>2）Semaphore</p>
<p>Semaphore用来控制对共享资源的访问数量，例如池的最大连接数。</p>
<p><strong>[python]</strong> <a href="http://blog.csdn.net/moxiaomomo/article/details/11640439#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/moxiaomomo/article/details/11640439#" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li>import multiprocessing  </li>
<li>import time   </li>
<li></li>
<li>def worker(s,i):  </li>
<li>s.acquire()  </li>
<li>print(multiprocessing.current_process().name + “ acquire”)  </li>
<li>time.sleep(i)  </li>
<li>print(multiprocessing.current_process().name + “ release”)  </li>
<li>s.release()  </li>
<li></li>
<li>if <strong>name</strong> == “<strong>main</strong>“:  </li>
<li></li>
<li>s = multiprocessing.Semaphore(2)  </li>
<li>for i in range(5):  </li>
<li>p = multiprocessing.Process(target=worker, args=(s,i*2))  </li>
<li>p.start()  </li>
</ol>
<p>上面的实例中使用semaphore限制了最多有2个进程同时执行。</p>
<p>3）Event</p>
<p>Event用来实现进程间同步通信。</p>
<p><strong>[python]</strong> <a href="http://blog.csdn.net/moxiaomomo/article/details/11640439#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/moxiaomomo/article/details/11640439#" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li>import multiprocessing  </li>
<li>import time  </li>
<li></li>
<li>def wait_for_event(e):  </li>
<li>“””Wait for the event to be set before doing anything”””  </li>
<li>print (‘wait_for_event: starting’)  </li>
<li>e.wait()  </li>
<li>print (‘wait_for_event: e.is_set()-&gt;’ + str(e.is_set()))  </li>
<li></li>
<li>def wait_for_event_timeout(e, t):  </li>
<li>“””Wait t seconds and then timeout”””  </li>
<li>print (‘wait_for_event_timeout: starting’)  </li>
<li>e.wait(t)  </li>
<li>print (‘wait_for_event_timeout: e.is_set()-&gt;’ + str(e.is_set()))  </li>
<li></li>
<li></li>
<li>if <strong>name</strong> == ‘<strong>main</strong>‘:  </li>
<li>e = multiprocessing.Event()  </li>
<li>w1 = multiprocessing.Process(name=’block’,   </li>
<li>target=wait_for_event,  </li>
<li>args=(e,))  </li>
<li>w1.start()  </li>
<li></li>
<li>w2 = multiprocessing.Process(name=’non-block’,   </li>
<li>target=wait_for_event_timeout,   </li>
<li>args=(e, 2))  </li>
<li>w2.start()  </li>
<li></li>
<li>time.sleep(3)  </li>
<li>e.set()  </li>
<li>print (‘main: event is set’)  </li>
</ol>
<p>#the output is:  </p>
<p>#wait_for_event_timeout: starting  </p>
<p>#wait_for_event: starting  </p>
<p>#wait_for_event_timeout: e.is_set()-&gt;False  </p>
<p>#main: event is set  </p>
<p>#wait_for_event: e.is_set()-&gt;True</p>
<p> 转自：<a href="http://blog.csdn.net/moxiaomomo/article/details/11640439" target="_blank" rel="external">http://blog.csdn.net/moxiaomomo/article/details/11640439</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/moxiaomomo/article/details/11640439&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;【python】多进程锁multiprocess.Lock&lt;/a&gt;&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线程安全及Python中的GIL</title>
    <link href="https://shijingjing07.github.io/2016/12/20/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8F%8APython%E4%B8%AD%E7%9A%84GIL/"/>
    <id>https://shijingjing07.github.io/2016/12/20/线程安全及Python中的GIL/</id>
    <published>2016-12-20T05:04:00.000Z</published>
    <updated>2017-01-12T01:35:15.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程安全及Python中的GIL"><a href="#线程安全及Python中的GIL" class="headerlink" title="线程安全及Python中的GIL"></a>线程安全及Python中的GIL</h1><p>本博客所有内容采用 <a href="http://creativecommons.org/about/licenses/meet-the-licenses" target="_blank" rel="external">Creative Commons<br>Licenses</a> 许可使用.<br>引用本内容时，请保留 <a href="http://sites.google.com/site/towerjoo" target="_blank" rel="external">朱涛</a>,<br><a href="http://www.cnblogs.com/mindsbook" target="_blank" rel="external">出处</a> ，并且 <strong>非商业</strong> .</p>
<p>点击 <a href="http://feed.feedsky.com/MindsbookTowerJoo" target="_blank" rel="external">订阅</a> 来订阅本博客.(推荐使用 <a href="http://reader.google.com/" target="_blank" rel="external">google<br>reader</a>, 如果你的浏览器不支持直接订阅,请直接在 <a href="http://reader.google.com/" target="_blank" rel="external">google<br>reader</a> 中手动添加).</p>
<p>抱歉,在正文中加入很多本博客的链接,主要是发现很多转载的朋友并未按照本声明来加入出处信息. 影响阅读,实在抱歉.</p>
<h1 id="摘要-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety-and"><a href="#摘要-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety-and" class="headerlink" title="[摘要](http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-"></a>[摘要](<a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-" target="_blank" rel="external">http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-</a></h1><p>GIL.html#id17)</p>
<p><a href="http://www.cnblogs.com/mindsbook" target="_blank" rel="external">作者博客链接</a>.</p>
<p>什么是线程安全? 为什么python会使用GIL的机制?</p>
<p>在多核时代的到来的背景下,基于多线程来充分利用硬件的编程方法也不断发展起来, 但是一旦 牵扯到多线程,就必然会涉及到一个概念,即 <strong>线程安全</strong>,<br>本文就主要谈下笔者对线程安全的一些理解.</p>
<p>而Python为很多人所抱怨的一点就是GIL,那么python为什么选择使用GIL, 本文也就这个问题进行一些讨论.</p>
<p>Contents</p>
<ul>
<li><a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-GIL.html#id1" target="_blank" rel="external">摘要</a></li>
<li><a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-GIL.html#id2" target="_blank" rel="external">引入</a></li>
<li><a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-GIL.html#id3" target="_blank" rel="external">线程安全</a></li>
<li><a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-GIL.html#gil" target="_blank" rel="external">GIL</a></li>
<li><a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-GIL.html#id4" target="_blank" rel="external">个人的观点</a></li>
<li><a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-GIL.html#id5" target="_blank" rel="external">参考资料</a></li>
<li><a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-GIL.html#rst" target="_blank" rel="external">本文的rst源码</a></li>
</ul>
<h1 id="引入-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety-and"><a href="#引入-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety-and" class="headerlink" title="[引入](http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-"></a>[引入](<a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-" target="_blank" rel="external">http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-</a></h1><p>GIL.html#id18)</p>
<p><a href="http://www.cnblogs.com/mindsbook" target="_blank" rel="external">作者博客链接</a>.</p>
<p>你的PC或者笔记本还是单核吗? 如果是,那你已经out了.</p>
<p>随着纳米技术的不断进步, 计算机芯片的工艺也在进步,但是已经很难在工艺上的改进来提高 运算速度而满足<br><a href="http://en.wikipedia.org/wiki/Moore_Law" target="_blank" rel="external">摩尔定理</a>, 所以intel,<br>amd相继在采用横向的扩展即增加更多的CPU, 从而双核, 4核, N核不断推出,于是我们进入了多核时代.</p>
<p>于是一个问题出现了, 多核时代的出现对于我们程序员而言意味着什么, 我们如何利用多核的优势?</p>
<p>在回答这个问题之前,建议对 <a href="http://en.wikipedia.org/wiki/Process_\(computing\" target="_blank" rel="external">进程</a>) 和<br><a href="http://en.wikipedia.org/wiki/Thread_\(computing\" target="_blank" rel="external">线程</a>) 不熟悉的读者可以先补下相关的知识.</p>
<p>当然方案是,可以采用 <strong>多进程</strong>, 也可以采用 <strong>多线程</strong>. 二者的最大区别就是, 是否共享资源, 后者是共享资源的,而前者是独立的.<br>所以你也可能想起了google chrome为什么又开始使用独立的进程 来作为每个tab服务了(不共享数据,意味着有更好的安全性).</p>
<p>相对于进程的轻型特征,多线程环境有个最大的问题就是 <strong>如何保证资源竞争,死锁, 数据修改等</strong>.</p>
<p>于是,便有了 <a href="http://en.wikipedia.org/wiki/Thread_safety" target="_blank" rel="external">线程安全</a> (thread safety)的提出.</p>
<h1 id="线程安全-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety"><a href="#线程安全-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety" class="headerlink" title="[线程安全](http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-"></a>[线程安全](<a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-" target="_blank" rel="external">http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-</a></h1><p>and-GIL.html#id19)</p>
<p><a href="http://www.cnblogs.com/mindsbook" target="_blank" rel="external">作者博客链接</a>.</p>
<pre><code>Thread safety is a computer programming concept applicable in the context of multi-threaded programs.
A piece of code is thread-safe if it functions correctly during simultaneous execution by multiple threads.
In particular, it must satisfy the need for multiple threads to access the same shared data,
and the need for a shared piece of data to be accessed by only one thread at any given time.
</code></pre><p>上面是wikipedia中的解释, 换句话说, <a href="http://en.wikipedia.org/wiki/Thread_safety" target="_blank" rel="external">线程安全</a><br>是在多线程的环境下, 线程安全能够保证多个线程同时执行时程序依旧运行正确,<br>而且要保证对于共享的数据,可以由多个线程存取,但是同一时刻只能有一个线程进行存取.</p>
<p>既然,多线程环境下必须存在资源的竞争,那么如何才能保证同一时刻只有一个线程对共享资源进行存取?</p>
<p><strong>加锁</strong>, 对, 加锁可以保证存取操作的唯一性, 从而保证同一时刻只有一个线程对共享数据存取.</p>
<p>通常加锁也有2种不同的粒度的锁:</p>
<ol>
<li>fine-grained(所谓的细粒度), 那么程序员需要自行地加,解锁来保证线程安全</li>
<li>coarse-grained(所谓的粗粒度), 那么语言层面本身维护着一个全局的锁机制,用来保证线程安全</li>
</ol>
<p>前一种方式比较典型的是<br><a href="http://en.wikipedia.org/wiki/Java_\(programming_language\" target="_blank" rel="external">java</a>),<br><a href="http://en.wikipedia.org/wiki/Jython" target="_blank" rel="external">Jython</a> 等, 后一种方式比较典型的是<br><a href="http://en.wikipedia.org/wiki/Cpython" target="_blank" rel="external">CPython</a> (即Python).</p>
<p>前一种本文不进行讨论, 具体可参考<br><a href="http://en.wikipedia.org/wiki/Java_\(programming_language\" target="_blank" rel="external">java</a>) 中的多线程编程部分.</p>
<p>至于Python中的全局锁机制,也即 <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a><br>(Global Interpreter Lock), 下面主要进行一些讨论.</p>
<h1 id="GIL-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety-and"><a href="#GIL-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety-and" class="headerlink" title="[GIL](http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-"></a>[GIL](<a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-" target="_blank" rel="external">http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-</a></h1><p>GIL.html#id20)</p>
<p><a href="http://www.cnblogs.com/mindsbook" target="_blank" rel="external">作者博客链接</a>.</p>
<p>什么是 <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a> ?<br>答案可参考wikipedia中的说明, 简单地说就是:</p>
<p><strong>每一个interpreter进程,只能同时仅有一个线程来执行, 获得相关的锁, 存取相关的资源</strong>.</p>
<p>那么很容易就会发现,如果一个interpreter进程只能有一个线程来执行, 多线程的并发则成为不可能, 即使这几个线程之间不存在资源的竞争.</p>
<p>从理论上讲,我们要尽可能地使程序更加并行, 能够充分利用多核的功能, 那么Python为什么要使用 全局的<br><a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a> 来限制这种并行呢?</p>
<p>这个问题,其实已经得到了很多的讨论, 不止十年, 可以参考下面的文档:</p>
<p>反对 <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a> 的声音:</p>
<ol>
<li><a href="http://blog.snaplogic.org/?p=94" target="_blank" rel="external">An open letter to Guido van Rossum</a> (这个文章值得一看,下面有很多的留言也值得一看)</li>
</ol>
<p>认为 <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a> 不能去除的:</p>
<ol>
<li><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=214235" target="_blank" rel="external">It isn’t Easy to Remove the GIL</a> (这个文章来自python作者 <a href="http://en.wikipedia.org/wiki/Guido_van_Rossum" target="_blank" rel="external">Guido</a>, 他说明了什么要使用 <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a>)</li>
</ol>
<p>其它的一些讨论很容易从Google来搜索得到, 譬如: <a href="http://www.google.com/search?hl=en&amp;newwindow=1&amp;q=global+interpreter+lock&amp;aq=0&amp;oq=Global+interpreter&amp;aqi=g3g-m6" target="_blank" rel="external">GIL at<br>google</a>.</p>
<p>那么,简单总结下双方的观点.</p>
<p>认为应该去除 <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a> 的:</p>
<ol>
<li>不顺应计算机的发展潮流(多核时代已经到来, 而 <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a> 会很影响多核的使用)</li>
<li>大幅度提升多线程程序的速度</li>
</ol>
<p>认为不应该去除 <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a> 的(如果去掉,会):</p>
<ol>
<li>写python的扩展(module)时会遇到锁的问题,程序员需要繁琐地加解锁来保证线程安全</li>
<li>会较大幅度地减低单线程程序的速度</li>
</ol>
<p>后者是 <a href="http://en.wikipedia.org/wiki/Guido_van_Rossum" target="_blank" rel="external">Guido</a> 最为关切的, 也是不去除<br><a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a> 最重要的原因,<br>一个简单的尝试是在1999年(十年前), 最终的结果是导致单线程的程序速度下降了几乎2倍.</p>
<p>归根结底,其实就是多进程与多线程的选择问题, 有一段话比较有意思, 可以参考<br><a href="http://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235" target="_blank" rel="external">http://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235</a>.</p>
<p>我引用如下:</p>
<pre><code>I actually don&apos;t think removing the GIL is a good solution.
But I don&apos;t think threads are a good solution, either.
They&apos;re too hard to get right, and I say that after spending literally years studying threading in both C++ and Java.
Brian Goetz has taken to saying that no one can get threading right.
</code></pre><p>引自 <a href="http://en.wikipedia.org/wiki/Bruce_Eckel" target="_blank" rel="external">Bruce Eckel</a> 对<br><a href="http://en.wikipedia.org/wiki/Guido_van_Rossum" target="_blank" rel="external">Guido</a> 的回复. 而 <a href="http://en.wikipedia.org/wiki/Bruce_Eckel" target="_blank" rel="external">Bruce<br>Eckel</a> 是何许人, 如果你了解<br><a href="http://en.wikipedia.org/wiki/Java_\(programming_language\" target="_blank" rel="external">java</a>) 或者 C++,<br>那么应该不会不知道他.</p>
<h1 id="个人的观点-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety"><a href="#个人的观点-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety" class="headerlink" title="[个人的观点](http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-"></a>[个人的观点](<a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-" target="_blank" rel="external">http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-</a></h1><p>and-GIL.html#id21)</p>
<p><a href="http://www.cnblogs.com/mindsbook" target="_blank" rel="external">作者博客链接</a>.</p>
<p>那么,从我自己的角度来看(我没有太多的多线程编程经验), 先不论多线程的速度优势等,我更加喜欢多进程的是:</p>
<ol>
<li>简单,无需要人为(或者语言级别)的加解锁. 想想 <a href="http://en.wikipedia.org/wiki/Java_\(programming_language\" target="_blank" rel="external">java</a>) 中的多线程编程,程序员通常会在此处出错(java程序员可以思考下)</li>
<li>安全, 这也是浏览器为什么开始使用多进程的一个原因</li>
</ol>
<p>依照Python自身的哲学, <strong>简单</strong> 是一个很重要的原则,所以, 使用<br><a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a> 也是很好理解的.</p>
<p>当然你真的需要充分利用多核的速度优势,此时python可能并非你最佳的选择,请考虑别的语言吧,如<br><a href="http://en.wikipedia.org/wiki/Java_\(programming_language\" target="_blank" rel="external">java</a>),<br><a href="http://en.wikipedia.org/wiki/Erlang_\(programming_language\" target="_blank" rel="external">erlang</a>) 等.</p>
<p>转自：<a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-
GIL.html" target="_blank" rel="external">http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-
GIL.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程安全及Python中的GIL&quot;&gt;&lt;a href=&quot;#线程安全及Python中的GIL&quot; class=&quot;headerlink&quot; title=&quot;线程安全及Python中的GIL&quot;&gt;&lt;/a&gt;线程安全及Python中的GIL&lt;/h1&gt;&lt;p&gt;本博客所有内容采用 &lt;a h
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python logging模块</title>
    <link href="https://shijingjing07.github.io/2016/12/19/python%20logging%E6%A8%A1%E5%9D%97/"/>
    <id>https://shijingjing07.github.io/2016/12/19/python logging模块/</id>
    <published>2016-12-18T21:37:00.000Z</published>
    <updated>2017-01-12T01:35:15.525Z</updated>
    
    <content type="html"><![CDATA[<p>1.logging模块提供了四个组件<br>logger：日志类，有两个功能<br>1)配置日志的等级，处理器handler，过滤器filter<br>logger.setLevel(logging.INFO)<br>logger.addHandler(handler)<br>logger.addFilter(filter)<br>2)写日志<br>logger.info()</p>
<p>handler:处理器类，实际写日志的类<br>常用的处理器有StreamHandler和FileHandler<br>StreamHandler将日志输出到stream，如sys.stdout,sys.stderr<br>FileHandler将日志输出到文件<br>处理器类可以配置自己的等级，过滤器<br>一个logger可以配置多个处理器类</p>
<p>filter:过滤器类，过滤日志等级，内容<br>使用示例如下：<br>class InfoFilter(logging.Filter):<br>def filter(self,rec):<br>reurn rec.levelno==logging.INFO<br>logger.addFilter(InfoFilter())</p>
<p>formatter:内容格式化类，格式化输出的内容<br>格式化配置，使用%(&lt;dict key&gt;)s的形式，具体有哪些关键字，可以参照官网的介绍。<br>使用示例如下：<br>fmt=’%(asctime)s - %(filename)s:%(lineno)s - %(name)s - %(message)s’<br>formatter=logging.Formatter(fmt)<br>handler.setFormatter(formatter)</p>
<p>2.logger对象<br>使用logging.getLogger(name=None)函数找到一个logger对象，当name指定的logger不存在时，会自动创建一个该名称的对象，保存在logging.manage的loggerDict中。</p>
<p>3.logging日志输出流程</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161219133511603-20961325.png" alt=""></p>
<p>logger输出日志的流程：<br>1)用户代码调用打印日志函数（logging.info(),logging.debug()等）<br>2)若希望打印的日志级别不够，则流程停止。否则进入步骤3<br>3)建立一个LogRecord对象，该对象代表打印的日志<br>4)判断这条日志是否被filter过滤掉，如果被过滤，流程停止。否则进入步骤5<br>5)logger将LogRecord传递到它定义的handlers，进行处理<br>6)判断当前logger的propagate属性，为0，则流程停止，否则进入步骤7<br>7)判断当前logger有无父logger，如果没有，流程停止，否则设置当前logger为它的父logger，继续执行步骤5<br>注：logger对象是有继承关系的，如名为a.b,a.c的logger都是名为a的子logger，并且所有的logger对象都继承自root,如果子对象没有添加handler等配置，会从父对象继承，这样可以通过继承关系来复用配置。</p>
<p>handler处理日志的过程：<br>1)如果当前LogRecord的级别小于handler所设置的LogLevel,则停止流程，否则进入步骤2<br>2)判断当前LogRecord是否被handler设置的filter过滤，如果被过滤，流程停止，否则日志输出到最终目的地。</p>
<p>4.logging使用示例<br>logging有三种配置方式<br>1)代码定义logger,handler等</p>
<pre><code>#!/usr/bin/env python 
# -*- coding: utf-8 -*- 
import logging  
import logging.config

handler = logging.StreamHandler()
fmt = &apos;%(asctime)s - %(filename)s:%(lineno)s - %(name)s - %(message)s&apos;  

formatter = logging.Formatter(fmt)   # 实例化formatter  
handler.setFormatter(formatter)      # 为handler添加formatter  

logger = logging.getLogger(&apos;tst&apos;)    # 获取名为tst的logger  
logger.addHandler(handler)           # 为logger添加handler  
logger.setLevel(logging.DEBUG)  

logger.info(&apos;first info message&apos;)  
logger.debug(&apos;first debug message&apos;)  
</code></pre><p>2)logging配置文件<br>loggin.conf采用了模式匹配的方式进行配置，正则表达式是r’^[(.*)]$’，从而匹配出所有的组件。对于同一个组件具有多个实例的情况使用逗号’，’进行分隔。对于一个实例的配置采用componentName_instanceName配置块。使用这种方式还是蛮简单的。<br>logging.conf</p>
<pre><code>[loggers]
keys=root,simpleExample

[handlers]
keys=consoleHandler

[formatters]
keys=simpleFormatter

[logger_root]
level=DEBUG
handlers=consoleHandler

[logger_simpleExample]
level=DEBUG
handlers=consoleHandler
qualname=simpleExample
propagate=0

[handler_consoleHandler]
class=StreamHandler
level=DEBUG
formatter=simpleFormatter
args=(sys.stdout,)

[formatter_simpleFormatter]
format=%(asctime)s - %(name)s - %(levelname)s - %(message)s


#!/usr/bin/env python 
# -*- coding: utf-8 -*- 
import logging  
import logging.config  

logging.config.fileConfig(&apos;logging.conf&apos;)

# create logger
logger = logging.getLogger(&apos;simpleExample&apos;)

# &apos;application&apos; code
logger.debug(&apos;debug message&apos;)
logger.info(&apos;info message&apos;)
logger.warn(&apos;warn message&apos;)
logger.error(&apos;error message&apos;)
logger.critical(&apos;critical message&apos;)
</code></pre><p>3)logging配置字典</p>
<pre><code>#!/usr/bin/env python 
# -*- coding: utf-8 -*- 
import logging  
import logging.config  

LOGGING = {
    &apos;version&apos;: 1,
    &apos;disable_existing_loggers&apos;: False,
    &apos;handlers&apos;: {
        &apos;console&apos;: {
            &apos;class&apos;: &apos;logging.StreamHandler&apos;,
        },
    },
    &apos;loggers&apos;: {
        &apos;test&apos;: {
            &apos;handlers&apos;: [&apos;console&apos;],
            &apos;level&apos;: &apos;ERROR&apos;,
        },
    },
}     
logging.config.dictConfig(LOGGING)
logger = logging.getLogger(&apos;test&apos;)
logger.info(&apos;info message dict&apos;)
logger.warn(&apos;warn message dict&apos;)
logger.error(&apos;error message dict&apos;)
logger.critical(&apos;critical message dict&apos;)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.logging模块提供了四个组件&lt;br&gt;logger：日志类，有两个功能&lt;br&gt;1)配置日志的等级，处理器handler，过滤器filter&lt;br&gt;logger.setLevel(logging.INFO)&lt;br&gt;logger.addHandler(handler)&lt;b
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>postgresql修改最大连接数</title>
    <link href="https://shijingjing07.github.io/2016/12/14/postgresql%E4%BF%AE%E6%94%B9%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0/"/>
    <id>https://shijingjing07.github.io/2016/12/14/postgresql修改最大连接数/</id>
    <published>2016-12-13T21:03:00.000Z</published>
    <updated>2017-01-12T01:35:15.545Z</updated>
    
    <content type="html"><![CDATA[<p>1.合适的最大连接数<br>used_connections/max_connections在85%左右<br>2.修改最大连接数<br>postgresql最大连接数默认为100<br>1)打开postgresql配置文件<br>vim /var/lib/pgsql/9.4/data/postgresql.conf<br>2)修改最大连接数<br>max_connections = 100<br>3)重启postgresql服务<br>在CentOS 6.x系统中<br>service postgresql-9.4 restart<br>在CentOS 7系统中<br>systemctl restart postgresql-9.4</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.合适的最大连接数&lt;br&gt;used_connections/max_connections在85%左右&lt;br&gt;2.修改最大连接数&lt;br&gt;postgresql最大连接数默认为100&lt;br&gt;1)打开postgresql配置文件&lt;br&gt;vim /var/lib/pgsql/9.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>socket详解</title>
    <link href="https://shijingjing07.github.io/2016/12/02/socket%E8%AF%A6%E8%A7%A3/"/>
    <id>https://shijingjing07.github.io/2016/12/02/socket详解/</id>
    <published>2016-12-02T05:39:00.000Z</published>
    <updated>2017-01-12T01:35:15.836Z</updated>
    
    <content type="html"><![CDATA[<p>socket网络编程<br>1.进程间如何通信<br>本地进程间通信我们知道有以下几种方式：<br>1)消息传递(管道，FIFO，消息队列)<br>管道是一个进程的数据流到另一个进程的通道，即一个进程的数据输出作为另一个进程的数据输入，管道起到了桥梁的作用。<br>2)共享内存<br>不同进程访问同一个逻辑内存<br>3)同步<br>互斥量，条件变量，读写锁，信号量<br>4)远程过程调用<br>但是网络间的进程是如何通信的呢？如浏览器进程如何与web服务器通信，QQ聊天时，QQ进程如何与服务器或你好友所在的QQ进程通信？<br>答案是socket，网络间的进程通信几乎都是用的socket.  </p>
<p>2.如何识别网络中唯一进程<br>本地进程间可以通过PID来唯一标识一个进程<br>网络中我们根据TCP/IP协议族来标识唯一进程，网络层的”IP地址”可唯一标识网络中的主机，而传输层的”协议+端口”可唯一标识主机中的进程。”IP地址+协议+端口”就可以确定唯一进程了。<br>3.进程间如何通过socket进行通讯<br>Linux的哲学是一切皆文件，socket也是一种文件。可以使用”打开-读写-关闭”来操作。socket是应用层和运输层之间的一个抽象层。<br>socket通信流程：<br>1)服务端创建socket<br>socket()<br>2)服务端绑定端口号<br>bind()<br>3)服务端监听端口号<br>listen()<br>4)客户端创建socket<br>socket()<br>5)客户端主动打开socket,连接服务器端socket<br>connect()<br>6)服务端接收客户端请求，socket被动打开<br>同步：accept() 异步：beginaccept()<br>7)客户端socket向服务端socket写信息<br>send()<br>8)服务端socket读取信息<br>9)客户端socket关闭<br>10)服务端socket关闭  </p>
<p>4.socket建立连接的三次握手</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161202213659849-1737384138.png" alt=""></p>
<p>第一步，客户端调用connect，向服务器发送SYN J包，connect阻塞<br>第二步，服务端收到SYN J包，调用accept函数接收请求，向客户端发送 SYN K,ACK J+1<br>        accept函数阻塞<br>第三步，客户端收到服务器的SYN K,ACK J+1后，connect返回，进行SYN K确认，服务端收到ACK<br>K+1时，accept返回，三次握手完成，连接建立。</p>
<p>5.socket释放连接的四次握手</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161202213749927-565791155.png" alt=""><br>第一步，客户端关闭连接，发送一个FIN M到服务端<br>第二步，服务端接收到FIN M后，执行被动关闭，对这个FIN M进行确认ACK M+1。<br>第三步，当服务端发送完毕后，再发送FIN N到客户端<br>第四步，客户端接收到FIN N调用close关闭它的socket,发送一个ACK N+1到服务端<br>服务端接收到这个ACK N+1关闭它的socket</p>
<p>6.为什么建立连接是三次握手，释放连接需要四次<br>这是因为进行释放连接的第二步时，有可能服务端仍有数据发送给客户端，因此，需要分开，先对客户端FIN报文应答，当服务端数据发送完毕后，再发送FIN报文到客户端。  </p>
<p>7.socket连接示例<br>服务器端</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;errno.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;

#define MAXLINE 4096

int main(int argc, char** argv)
{
    int    listenfd, connfd;
    struct sockaddr_in     servaddr;
    char    buff[4096];
    int     n;

    if( (listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1 ){
    printf(&quot;create socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);
    exit(0);
    }

    memset(&amp;servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    servaddr.sin_port = htons(6666);

    if( bind(listenfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) == -1){
    printf(&quot;bind socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);
    exit(0);
    }

    if( listen(listenfd, 10) == -1){
    printf(&quot;listen socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);
    exit(0);
    }

    printf(&quot;======waiting for client&apos;s request======\n&quot;);
    while(1){
    if( (connfd = accept(listenfd, (struct sockaddr*)NULL, NULL)) == -1){
        printf(&quot;accept socket error: %s(errno: %d)&quot;,strerror(errno),errno);
        continue;
    }
    n = recv(connfd, buff, MAXLINE, 0);
    buff[n] = &apos;\0&apos;;
    printf(&quot;recv msg from client: %s\n&quot;, buff);
    close(connfd);
    }

    close(listenfd);
}
</code></pre><p>客户端</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;errno.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;

#define MAXLINE 4096

int main(int argc, char** argv)
{
    int    sockfd, n;
    char    recvline[4096], sendline[4096];
    struct sockaddr_in    servaddr;

    if( argc != 2){
    printf(&quot;usage: ./client &lt;ipaddress&gt;\n&quot;);
    exit(0);
    }

    if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0){
    printf(&quot;create socket error: %s(errno: %d)\n&quot;, strerror(errno),errno);
    exit(0);
    }

    memset(&amp;servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(6666);
    if( inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;= 0){
    printf(&quot;inet_pton error for %s\n&quot;,argv[1]);
    exit(0);
    }

    if( connect(sockfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) &lt; 0){
    printf(&quot;connect error: %s(errno: %d)\n&quot;,strerror(errno),errno);
    exit(0);
    }

    printf(&quot;send msg to server: \n&quot;);
    fgets(sendline, 4096, stdin);
    if( send(sockfd, sendline, strlen(sendline), 0) &lt; 0)
    {
    printf(&quot;send msg error: %s(errno: %d)\n&quot;, strerror(errno), errno);
    exit(0);
    }

    close(sockfd);
    exit(0);
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;socket网络编程&lt;br&gt;1.进程间如何通信&lt;br&gt;本地进程间通信我们知道有以下几种方式：&lt;br&gt;1)消息传递(管道，FIFO，消息队列)&lt;br&gt;管道是一个进程的数据流到另一个进程的通道，即一个进程的数据输出作为另一个进程的数据输入，管道起到了桥梁的作用。&lt;br&gt;2)共享
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>重放攻击（Replay Attacks）</title>
    <link href="https://shijingjing07.github.io/2016/12/01/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB%EF%BC%88Replay%20Attacks%EF%BC%89/"/>
    <id>https://shijingjing07.github.io/2016/12/01/重放攻击（Replay Attacks）/</id>
    <published>2016-12-01T05:30:00.000Z</published>
    <updated>2017-01-12T01:35:15.866Z</updated>
    
    <content type="html"><![CDATA[<p>重放攻击（Replay Attacks）<br>1.什么是重放攻击<br>顾名思义，重复的会话请求就是重放攻击。<br>可能是因为用户重复发起请求，也可能是因为请求被攻击者获取，然后重新发给服务器。  </p>
<p>2.重放攻击的危害<br>请求被攻击者获取，并重新发送给认证服务器，从而达到认证通过的目的。<br>我们可以通过加密，签名的方式防止信息泄露，会话被劫持修改。但这种方式防止不了重放攻击。  </p>
<p>3.重放攻击的防御<br>1)时间戳验证<br>请求时加上客户端当前时间戳，同时签名（签名是为了防止会话被劫持，时间戳被修改），服务端对请求时间戳进行判断，如超过5分钟，认定为重放攻击，请求无效。<br>时间戳无法完全防止重放攻击。  </p>
<p>2)序号<br>顾名思义，在客户端和服务端通讯时，先定义一个初始序号，每次递增。这样，服务端就可以知道是否是重复发送的请求。  </p>
<p>3)挑战与应答的方式<br>我们一般采用这种方式来防御重放攻击。<br>客户端请求服务器时，服务器会首先生成一个随机数，然后返回给客户端，客户端带上这个随机数，访问服务器，服务器比对客户端的这个参数，若相同，说明正确，不是重放攻击。<br>这种方式下，客户端每次请求时，服务端都会先生成一个挑战码，客户端带上应答码访问，服务端进行比对，若挑战码和应答码不对应，视为重放攻击。  </p>
<p>4)Https防重放攻击<br>对于https，每个socket连接都会验证证书，交换密钥。攻击者截获请求，重新发送，因为socket不同，密钥也不同，后台解密后是一堆乱码，所以https本身就是防止重放攻击的，除非能复制socket，或者进行中间人攻击。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重放攻击（Replay Attacks）&lt;br&gt;1.什么是重放攻击&lt;br&gt;顾名思义，重复的会话请求就是重放攻击。&lt;br&gt;可能是因为用户重复发起请求，也可能是因为请求被攻击者获取，然后重新发给服务器。  &lt;/p&gt;
&lt;p&gt;2.重放攻击的危害&lt;br&gt;请求被攻击者获取，并重新发送给
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IO-同步，异步，阻塞，非阻塞</title>
    <link href="https://shijingjing07.github.io/2016/11/28/IO-%E5%90%8C%E6%AD%A5%EF%BC%8C%E5%BC%82%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%EF%BC%8C%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <id>https://shijingjing07.github.io/2016/11/28/IO-同步，异步，阻塞，非阻塞/</id>
    <published>2016-11-28T06:21:00.000Z</published>
    <updated>2017-01-12T01:35:15.947Z</updated>
    
    <content type="html"><![CDATA[<p>IO-同步，异步，阻塞，非阻塞<br>1.什么是IO<br>数据在系统内核(kernel)和用户进程之间的传递，称为IO。</p>
<p>2.IO操作步骤<br>以read为例，涉及两个系统对象，调用IO的process(or thread)，即用户进程；另一个为系统内核(kernel)。<br>当用户进程调用recvfrom操作时，会经历两个阶段<br>1)等待数据准备<br>2)将数据从内核拷贝至进程中</p>
<p>3.IO模型<br>根据用户进程在IO操作时的状态，可以分为5中IO类型：<br>blocking IO:阻塞IO<br>non-blocking IO：非阻塞IO<br>IO multiplexing：多Socket连接IO<br>signal driven IO：信号驱动IO<br>asynchronous IO：异步IO</p>
<p>signal driven IO实际中很少使用，在此不做介绍。</p>
<p>2.blocking IO:阻塞IO<br>当用户进程调用recvfrom时，首先开始IO第一阶段：kernel准备数据。<br>用户进程会被阻塞。当kernel数据准备好以后，会将数据从kernel拷贝到用户内存，然后kernel返回结果，用户进程才会解除block的状态，重新运行起来。<br>blocking IO在IO执行的两个阶段都被block了。</p>
<p>3.non-blocking IO:非阻塞IO<br>可以设置socket使其变为non-blocking。<br>当对一个non-blocking socket执行recvfrom操作时，流程如下：<br>用户进程调用recvfrom,如果kernel数据还没有准备好，此时用户进程不会被block。而是立刻返回一个error，从用户进程角度看，它并没有等待，而是立刻得到了一个结果。<br>用户进程判断是一个error时，它就知道数据还没有准备好，于是再次发送read操作。<br>一旦kernel中的数据准备好，并且再次收到了用户进程的system call,那么它马上将数据拷贝到用户内存，然后kernel返回结果。<br>non-blocking<br>IO在数据准备阶段，没有被block，而是不断的轮询kernel数据是否准备好；在数据拷贝阶段，用户进程被block，直到kernel拷贝结束，返回结果，用户进程才会解除block的状态。</p>
<p>4.IO multiplexing：多Socket连接IO<br>IO<br>multiplexing的特点是单个用户进程可以同时处理多个网络连接IO，它的原理是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。<br>当用户进程调用select时，整个进程会被block，当任何一个socket中的数据准备好了，select就会返回。这时用户进程再调用read操作，将数据从kernel拷贝到用户进程。我们可以看出，IO<br>multiplexing和blocking IO的流程类似，不同的是，IO multiplexing需要两个system<br>call(select和recvfrom)，而blocking IO只调用了一个system<br>call(recvfrom)。select的优势在于它可以同时处理多个socket连接。所以如果连接数不高的话，使用select/epoll的web<br>server不一定比multi-threading+blocking IO的web<br>server性能更好，select/epoll的优势在于能够处理更多的连接。<br>IO multiplexing中，每一个socket一般设置为non-blocking的，但是用户进程一直是被select函数block的。</p>
<p>5.asynchronous IO<br>用户进程发起read操作后，立刻返回可以去做其他的事情了。<br>此时，从kernel角度看，当它收到一个asynchronous<br>read后，首先他立刻返回，所以不会对用户进程产生任何block，然后,kernel等待数据准备完成，然后将数据拷贝到用户内存，当这一切完成之后，kernel会给用户进程发送一个signal告诉用户进程read操作完成了。</p>
<p>6.四种IO模型的区别<br>blocking和non-blocking,synchronous IO和asynchronous IO的区别。<br>blocking和non-blocking的区别很明显，blocking会一致阻塞，non-blocking在数据没准备完全时会立刻返回。<br>synchronous同步IO指的是在IO操作时会阻塞用户进程；asynchronous含义相反。<br>可以看出blocking，non-blocking，IO multiplexing都是synchronous<br>IO；而asynchronous不会对用户进程产生任何阻塞。</p>
<p>7.网上有一个比较形象的例子来说明这四种IO Model<br>有A，B，C，D四个人在钓鱼：<br>A用的是最老式的鱼竿，所以呢，得一直守着，等到鱼上钩了再拉杆；<br>B的鱼竿有个功能，能够显示是否有鱼上钩，所以呢，B就和旁边的MM聊天，隔会再看看有没有鱼上钩，有的话就迅速拉杆；<br>C用的鱼竿和B差不多，但他想了一个好办法，就是同时放好几根鱼竿，然后守在旁边，一旦有显示说鱼上钩了，它就将对应的鱼竿拉起来；<br>D是个有钱人，干脆雇了一个人帮他钓鱼，一旦那个人把鱼钓上来了，就给D发个短信。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IO-同步，异步，阻塞，非阻塞&lt;br&gt;1.什么是IO&lt;br&gt;数据在系统内核(kernel)和用户进程之间的传递，称为IO。&lt;/p&gt;
&lt;p&gt;2.IO操作步骤&lt;br&gt;以read为例，涉及两个系统对象，调用IO的process(or thread)，即用户进程；另一个为系统内核(
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue.js使用详解</title>
    <link href="https://shijingjing07.github.io/2016/11/19/vue.js%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://shijingjing07.github.io/2016/11/19/vue.js使用详解/</id>
    <published>2016-11-19T01:45:00.000Z</published>
    <updated>2017-01-12T01:35:16.176Z</updated>
    
    <content type="html"><![CDATA[<p>1.什么是vue.js<br>vue.js是一款数据驱动型的js框架。何为数据驱动型？html视图层定义模板，vue定义数据。html和vue数据，通过标签id关联。</p>
<p>2.vue.js引入<br>&lt;script src=”<a href="https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&amp;gt" target="_blank" rel="external">https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&amp;gt</a>;</p>
<p>3.使用示例<br>1)声明式渲染</p>
<pre><code>&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;app&quot;&gt;
{{message}}
&lt;/div&gt;

var app=new Vue({
    el:&apos;#app&apos;,
    data:{
        message:&apos;Hello Vue!&apos;
    }
})
</code></pre><p>运行结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201611/300946-20161119174130482-998803872.png" alt=""></p>
<p>2)条件判断</p>
<pre><code>&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;app-3&quot;&gt;
  &lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;
&lt;/div&gt;

var app3 = new Vue({
  el: &apos;#app-3&apos;,
  data: {
    seen: true
  }
})
</code></pre><p>运行结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201611/300946-20161119174215842-1944546714.png" alt=""></p>
<p>3)循环</p>
<pre><code>&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;app-4&quot;&gt;
    &lt;ol&gt;
        &lt;li v-for=&quot;todo in todos&quot;&gt;
            {{ todo.text }}
        &lt;/li&gt;
    &lt;/ol&gt;
&lt;/div&gt;

var app4 = new Vue({
    el: &apos;#app-4&apos;,
    data: {
        todos: [
          { text: &apos;Learn JavaScript&apos; },
          { text: &apos;Learn Vue&apos; },
          { text: &apos;Build something awesome&apos; }
        ]
    }
})
</code></pre><p>运行结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201611/300946-20161119174251670-2022701270.png" alt=""></p>
<p>4)客户端交互</p>
<p>vue.js和浏览器可实现双向通信，即浏览器中绑定值改变后，js中会同时改变，反之亦然。</p>
<pre><code>&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;app-5&quot;&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  &lt;button v-on:click=&quot;reverseMessage&quot;&gt;Reverse Message&lt;/button&gt;
&lt;/div&gt;

var app5 = new Vue({
  el: &apos;#app-5&apos;,
  data: {
    message: &apos;Hello Vue.js!&apos;
  },
  methods: {
    reverseMessage: function () {
      this.message = this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)
    }
  }
})
</code></pre><p>运行结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201611/300946-20161119174331310-1906400836.png" alt=""></p>
<p>4.组件<br>组件可以理解为在js中定义了一个html模板和一个vue.js，前台html可以直接使用这个模板，同时会被vue.js渲染。<br>需要注意的是，组件必须要有vue.js数据渲染才能显示。<br>如下例所示：</p>
<pre><code>&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;app-7&quot;&gt;
  &lt;ol&gt;
    &lt;todo-item v-for=&quot;item in groceryList&quot; v-bind:todo=&quot;item&quot;&gt;&lt;/todo-item&gt;
  &lt;/ol&gt;
&lt;/div&gt;

Vue.component(&apos;todo-item&apos;, {
  props: [&apos;todo&apos;],
  template: &apos;&lt;li&gt;{{ todo.text }}&lt;/li&gt;&apos;
})
var app7 = new Vue({
  el: &apos;#app-7&apos;,
  data: {
    groceryList: [
      { text: &apos;Vegetables&apos; },
      { text: &apos;Cheese&apos; },
      { text: &apos;Whatever else humans are supposed to eat&apos; }
    ]
  }
})
</code></pre><p>运行结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201611/300946-20161119174405810-1399612477.png" alt=""></p>
<p>我们在模板中增加了一个”props”字段，来接收数据，在html页面中将这个字段绑定到vue.js中的数据。<br>完成数据绑定。</p>
<p>5.使用场景</p>
<p>个人觉得适合数据量大，前端html页面模块重复复杂的情况。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.什么是vue.js&lt;br&gt;vue.js是一款数据驱动型的js框架。何为数据驱动型？html视图层定义模板，vue定义数据。html和vue数据，通过标签id关联。&lt;/p&gt;
&lt;p&gt;2.vue.js引入&lt;br&gt;&amp;lt;script src=”&lt;a href=&quot;https:/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python 类中staticmethod,classmethod,普通方法</title>
    <link href="https://shijingjing07.github.io/2016/11/19/python%20%E7%B1%BB%E4%B8%ADstaticmethod,classmethod,%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95/"/>
    <id>https://shijingjing07.github.io/2016/11/19/python 类中staticmethod,classmethod,普通方法/</id>
    <published>2016-11-18T18:24:00.000Z</published>
    <updated>2017-01-12T01:35:16.252Z</updated>
    
    <content type="html"><![CDATA[<p>1.staticmethod:静态方法<br>和全局函数类似，但是通过类和对象调用。</p>
<p>2.classmethod:类方法<br>和类相关的方法，第一个参数是class对象（不是实例对象）。<br>在python中class也是一个真实存在于内存中的对象，不同于其他语言只存在于编译期间。</p>
<p>3.普通方法<br>和实例相关的方法，通过类实例调用。</p>
<p>4.代码示例</p>
<pre><code>#coding:utf-8
&apos;&apos;&apos;
Created on 2015年5月29日
@author: canx
&apos;&apos;&apos;

class Person:
    def __init__(self):
        print &quot;init&quot;

    @staticmethod
    def sayHello(hello):
        print &quot;sayHell %s&quot;%(hello)

    @classmethod
    def introduce(cls,hello):
        print &quot;introduce %s&quot;%(hello)

    def hello(self,hello):
        print &quot;hello %s&quot;%(hello)

def main():
    Person.sayHello(&quot;test&quot;)
    Person.introduce(&quot;test&quot;)
    p=Person()
    p.hello(&quot;test&quot;)

if __name__==&apos;__main__&apos;:
    main()
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201611/300946-20161119102339467-2036845135.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.staticmethod:静态方法&lt;br&gt;和全局函数类似，但是通过类和对象调用。&lt;/p&gt;
&lt;p&gt;2.classmethod:类方法&lt;br&gt;和类相关的方法，第一个参数是class对象（不是实例对象）。&lt;br&gt;在python中class也是一个真实存在于内存中的对象，不同于
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cookie,session,sessionid</title>
    <link href="https://shijingjing07.github.io/2016/11/07/cookie,session,sessionid/"/>
    <id>https://shijingjing07.github.io/2016/11/07/cookie,session,sessionid/</id>
    <published>2016-11-07T03:10:00.000Z</published>
    <updated>2017-01-12T01:35:16.267Z</updated>
    
    <content type="html"><![CDATA[<p>cookie,session,sessionid</p>
<p>http协议是无状态的，意思是每次请求的状态不会保存。因此，产生了cookie,session之类保存会话状态的机制。<br>1.什么是cookie<br>cookie将信息存储在客户端浏览器中。<br>cookie的内容主要包括：key,value,expire_time,path(路径),domain(域)<br>浏览器发送请求是会查找对应的path,domain，把符合的cookie自动发送给服务器。</p>
<p>2.什么是session<br>session在服务器端生成，然后会将对应的sessionid在浏览器端使用cookie保存起来。<br>因此会话状态可以在session中保存。<br>cookie可以被人为禁止，可以使用url重写，将session id附在URL路径的后面。还可以使用表单隐藏字段。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cookie,session,sessionid&lt;/p&gt;
&lt;p&gt;http协议是无状态的，意思是每次请求的状态不会保存。因此，产生了cookie,session之类保存会话状态的机制。&lt;br&gt;1.什么是cookie&lt;br&gt;cookie将信息存储在客户端浏览器中。&lt;br&gt;coo
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>supervisor使用详解</title>
    <link href="https://shijingjing07.github.io/2016/11/02/supervisor%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://shijingjing07.github.io/2016/11/02/supervisor使用详解/</id>
    <published>2016-11-02T02:57:00.000Z</published>
    <updated>2017-01-12T01:35:16.382Z</updated>
    
    <content type="html"><![CDATA[<p>1.什么是supervisor<br>supervisor是用python写的一个进程管理工具，用来启动，重启，关闭进程。</p>
<p>2.supervisor的安装</p>
<pre><code>pip install supervisor
</code></pre><p>3.supervisor的配置文件<br>supervisor安装完毕后，会有一个配置文件supervisord.conf<br>运行</p>
<pre><code>echo_supervisord_conf
</code></pre><p>命令，可输出文件详细<br>我们使用重定向运算符将配置文件定向到/etc路径下（方便管理）</p>
<pre><code>echo_supervisord_conf&gt;/etc/supervisord.conf
</code></pre><p>4.配置文件详解</p>
<pre><code>[unix_http_server]
file=/tmp/supervisor.sock ; UNIX socket 文件，supervisorctl 会使用
;chmod=0700 ; socket 文件的 mode，默认是 0700
;chown=nobody:nogroup ; socket 文件的 owner，格式： uid:gid

;[inet_http_server] ; HTTP 服务器，提供 web 管理界面
;port=127.0.0.1:9001 ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性
;username=user ; 登录管理后台的用户名
;password=123 ; 登录管理后台的密码

[supervisord]
logfile=/tmp/supervisord.log ; 日志文件，默认是 $CWD/supervisord.log
logfile_maxbytes=50MB ; 日志文件大小，超出会 rotate，默认 50MB
logfile_backups=10 ; 日志文件保留备份数量默认 10
loglevel=info ; 日志级别，默认 info，其它: debug,warn,trace
pidfile=/tmp/supervisord.pid ; pid 文件
nodaemon=false ; 是否在前台启动，默认是 false，即以 daemon 的方式启动
minfds=1024 ; 可以打开的文件描述符的最小值，默认 1024
minprocs=200 ; 可以打开的进程数的最小值，默认 200

; the below section must remain in the config file for RPC
; (supervisorctl/web interface) to work, additional interfaces may be
; added by defining them in separate rpcinterface: sections
[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

[supervisorctl]
serverurl=unix:///tmp/supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致
;serverurl=http://127.0.0.1:9001 ; 通过 HTTP 的方式连接 supervisord

; 包含其他的配置文件
[include]
files = relative/directory/*.ini ; 可以是 *.conf 或 *.ini
</code></pre><p>5.进程Program配置</p>
<pre><code>[program:usercenter]
directory = /home/leon/projects/usercenter ; 程序的启动目录
command = gunicorn -c gunicorn.py wsgi:app ; 启动命令，可以看出与手动在命令行启动的命令是一样的
autostart = true ; 在 supervisord 启动的时候也自动启动
startsecs = 5 ; 启动 5 秒后没有异常退出，就当作已经正常启动了
autorestart = true ; 程序异常退出后自动重启
startretries = 3 ; 启动失败自动重试次数，默认是 3
user = leon ; 用哪个用户启动
redirect_stderr = true ; 把 stderr 重定向到 stdout，默认 false
stdout_logfile_maxbytes = 20MB ; stdout 日志文件大小，默认 50MB
stdout_logfile_backups = 20 ; stdout 日志文件备份数
; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）
stdout_logfile = /data/logs/usercenter_stdout.log

; 可以通过 environment 来添加需要的环境变量，一种常见的用法是修改 PYTHONPATH
; environment=PYTHONPATH=$PYTHONPATH:/path/to/somewhere
</code></pre><p>将进程配置添加到supervisord.conf文件中<br>推荐将各个进程配置放到单独的文件中，然后通过[include]配置项引用</p>
<pre><code>[include]
files = /etc/supervisor/*.conf
</code></pre><p>6.supervisor服务启动<br>运行命令</p>
<pre><code>supervisord -c /etc/supervisord.conf
</code></pre><p>启动服务<br>若服务已启动会报以下错误：<br><img src="http://images2015.cnblogs.com/blog/300946/201611/300946-20161102190531861-1862207493.png" alt=""><br>查找服务进程，kill，重新运行<br><img src="http://images2015.cnblogs.com/blog/300946/201611/300946-20161102190540190-1592905441.png" alt=""></p>
<p>7.supervisor服务客户端管理<br>可以使用supervisord的命令行客户端管理工具supervisorctl，来管理进程。</p>
<pre><code>$ supervisorctl status
$ supervisorctl stop usercenter
$ supervisorctl start usercenter
$ supervisorctl restart usercenter
$ supervisorctl reread
$ supervisorctl update
</code></pre><p>8.supervisor web管理界面</p>
<pre><code>;[inet_http_server] ; HTTP 服务器，提供 web 管理界面
;port=127.0.0.1:9001 ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性
;username=user ; 登录管理后台的用户名
;password=123 ; 登录管理后台的密码
</code></pre><p>在浏览器中输入<a href="http://127.0.0.1:9001，可进入web管理界面" target="_blank" rel="external">http://127.0.0.1:9001，可进入web管理界面</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.什么是supervisor&lt;br&gt;supervisor是用python写的一个进程管理工具，用来启动，重启，关闭进程。&lt;/p&gt;
&lt;p&gt;2.supervisor的安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip install supervisor
&lt;/code&gt;&lt;/pre&gt;&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python unicode字节串转成中文问题</title>
    <link href="https://shijingjing07.github.io/2016/11/01/python%20unicode%E5%AD%97%E8%8A%82%E4%B8%B2%E8%BD%AC%E6%88%90%E4%B8%AD%E6%96%87%E9%97%AE%E9%A2%98/"/>
    <id>https://shijingjing07.github.io/2016/11/01/python unicode字节串转成中文问题/</id>
    <published>2016-11-01T03:10:00.000Z</published>
    <updated>2017-01-12T01:35:16.465Z</updated>
    
    <content type="html"><![CDATA[<p>如题，其实我的问题很简单，就是在写爬虫的时候拿到网页的信息包含类似”\u65b0\u6d6a\u5fae\u535a\u6ce8\u518c”的字符串，实际上这是unicode的中文编码，对应的中文为”新浪微博注册”。其实我就是想找一个函数让这一串东西显示中文而已，没想到百度了白天找到合适的。遇到这种问题千万不要用什么<br>“python编码” “unicode中文编码” “unicode解码”这样的关键字去搜，一大堆网页出来毫不相关。<br>其实这个问题一个函数搞定，如下：<br>Example 1:<br>&gt;&gt;&gt; s = r”\u65b0\u6d6a\u5fae\u535a\u6ce8\u518c”<br>&gt;&gt;&gt; s<br>‘\\u65b0\\u6d6a\\u5fae\\u535a\\u6ce8\\u518c’<br>&gt;&gt;&gt; print s<br>\u65b0\u6d6a\u5fae\u535a\u6ce8\u518c<br>&gt;&gt;&gt; s = s.decode(“unicode_escape”); #就是这个函数<br>&gt;&gt;&gt; print s<br>新浪微博注册</p>
<p>Example 2:<br>&gt;&gt;&gt; str<em> = “Russopho\xe9bic, clichd and just pl\xe9ain stupid.”<br>&gt;&gt;&gt; print str</em><br>Russopho?bic, clichd and just pl?ain stupid.<br>&gt;&gt;&gt; str<em> = str</em>.decode(“unicode<em>escape”)<br>&gt;&gt;&gt; print str</em><br>Russophoebic, clichd and just pleain stupid.<br>(这个方法解决了我在插入数据到mongodb时遇到的”bson.errors.InvalidStringData: strings in documents<br>must be valid UTF-8”问题)</p>
<p>附上关于这个问题的相关博客链接：<a href="http://www.cnblogs.com/yangze/archive/2010/11/16/1878469.html" target="_blank" rel="external">http://www.cnblogs.com/yangze/archive/2010/11/16/1878469.html</a></p>
<p>另外还有一个与unicode字节串有关的问题，遇到这样的错误提示：Unicode equal comparison failed to convert<br>both arguments to Unicode - interpreting them as being<br>unequal。说明我们在对两个字符（串）进行对比的时候等号两边的类型<br>不一样，可能是一边是unicode字节串，一边是字符串。详见<a href="http://stackoverflow.com/questions/3400171" target="_blank" rel="external">http://stackoverflow.com/questions/3400171</a><br>/python-utf-8-comparison。  </p>
<p>小结：<br>以后遇到奇葩问题要想好关键字再搜，不然很有可能一无所获。</p>
<p>转自：<a href="http://windkeepblow.blog.163.com/blog/static/1914883312013988185783/" target="_blank" rel="external">http://windkeepblow.blog.163.com/blog/static/1914883312013988185783/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如题，其实我的问题很简单，就是在写爬虫的时候拿到网页的信息包含类似”\u65b0\u6d6a\u5fae\u535a\u6ce8\u518c”的字符串，实际上这是unicode的中文编码，对应的中文为”新浪微博注册”。其实我就是想找一个函数让这一串东西显示中文而已，没想到百
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>对称加密和非对称加密</title>
    <link href="https://shijingjing07.github.io/2016/10/27/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    <id>https://shijingjing07.github.io/2016/10/27/对称加密和非对称加密/</id>
    <published>2016-10-26T23:50:00.000Z</published>
    <updated>2017-01-12T01:35:16.491Z</updated>
    
    <content type="html"><![CDATA[<p>1.什么是对称加密,非对称加密<br>对称加密是指加解密使用的是同样的密钥<br>非对称加密是指加解密使用的密钥不同。</p>
<p>2.对称加密的优缺点<br>对称加密的特点是简单快速。<br>密钥越大，加密越强，但加解密过程越慢。<br>密钥容易被黑客拦截</p>
<p>3.非对称加密的优缺点<br>非对称加密使用了一对密钥，公钥和私钥。私钥由解密方安全保管，公钥可以发给任何请求它的人。数据使用公钥加密，私钥解密。因为私钥不通过网络发送出去，所以非对称加密的安全性很高。<br>非对称加密很安全，但和对称加密比起来，非常慢。</p>
<p>4.对称密钥使用非对称方式发送<br>对称密钥使用非对称方式发送，解决了对称密钥易被获取，和非对称密钥加解密慢的问题。<br>使用步骤如下：<br>1)A生成一个随机数作为对称密钥<br>2)A向B申请公钥<br>3)B将公钥发给A<br>4)A使用公钥加密对称密钥，将加密后的结果发给B<br>5)B使用私钥解密出对称密钥<br>6)A和B可以通过对称密钥对信息加解密了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.什么是对称加密,非对称加密&lt;br&gt;对称加密是指加解密使用的是同样的密钥&lt;br&gt;非对称加密是指加解密使用的密钥不同。&lt;/p&gt;
&lt;p&gt;2.对称加密的优缺点&lt;br&gt;对称加密的特点是简单快速。&lt;br&gt;密钥越大，加密越强，但加解密过程越慢。&lt;br&gt;密钥容易被黑客拦截&lt;/p&gt;
&lt;p
    
    </summary>
    
    
  </entry>
  
</feed>
