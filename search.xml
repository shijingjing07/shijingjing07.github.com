<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[cnblogs博客迁移到hexo]]></title>
      <url>https://shijingjing07.github.io/2017/01/20/cnblogs%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0hexo/</url>
      <content type="html"><![CDATA[<h2 id="cnblogs博客备份"><a href="#cnblogs博客备份" class="headerlink" title="cnblogs博客备份"></a>cnblogs博客备份</h2><p>备份地址：<a href="https://i.cnblogs.com/BlogBackup.aspx?type=1" target="_blank" rel="external">https://i.cnblogs.com/BlogBackup.aspx?type=1</a><br><img src="https://raw.githubusercontent.com/shijingjing07/shijingjing07.github.com/master/img/1.png" alt=""><br>备份文件为xml格式，打开备份文件，如下所示：  </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;&lt;rss version=&quot;2.0&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:trackback=&quot;http://madskills.com/public/xml/rss/module/trackback/&quot; xmlns:wfw=&quot;http://wellformedweb.org/CommentAPI/&quot; xmlns:slash=&quot;http://purl.org/rss/1.0/modules/slash/&quot;&gt;&lt;channel&gt;&lt;title&gt;博客园-&lt;/title&gt;&lt;link&gt;http://www.cnblogs.com/shijingjing07/&lt;/link&gt;&lt;description /&gt;&lt;language&gt;zh-cn&lt;/language&gt;&lt;lastBuildDate&gt;Fri, 20 Jan 2017 13:20:14 GMT&lt;/lastBuildDate&gt;&lt;pubDate&gt;Fri, 20 Jan 2017 13:20:14 GMT&lt;/pubDate&gt;&lt;ttl&gt;60&lt;/ttl&gt;&lt;item&gt;&lt;title&gt;博客迁移&lt;/title&gt;&lt;link&gt;http://www.cnblogs.com/shijingjing07/archive/2017/01/16/6290517.html&lt;/link&gt;&lt;dc:creator&gt;迪米特&lt;/dc:creator&gt;&lt;author&gt;迪米特&lt;/author&gt;&lt;pubDate&gt;Mon, 16 Jan 2017 09:44:00 GMT&lt;/pubDate&gt;&lt;guid&gt;http://www.cnblogs.com/shijingjing07/archive/2017/01/16/6290517.html&lt;/guid&gt;&lt;description&gt;&lt;![CDATA[&lt;p&gt;博客迁移至&amp;nbsp;&lt;a href=&quot;https://shijingjing07.github.io/&quot; target=&quot;_blank&quot;&gt;https://shijingjing07.github.io/&lt;/a&gt;&lt;/p&gt;]]&gt;&lt;/description&gt;&lt;/item&gt;&lt;item&gt;&lt;title&gt;cookie欺骗&lt;/title&gt;&lt;link&gt;http://www.cnblogs.com/shijingjing07/archive/2017/01/06/6256622.html&lt;/link&gt;&lt;dc:creator&gt;迪米特&lt;/dc:creator&gt;&lt;author&gt;迪米特&lt;/author&gt;&lt;pubDate&gt;Fri, 06 Jan 2017 07:55:00 GMT&lt;/pubDate&gt;&lt;guid&gt;http://www.cnblogs.com/shijingjing07/archive/2017/01/06/6256622.html&lt;/guid&gt;&lt;description&gt;&lt;![CDATA[&lt;p&gt;1.什么是cookie欺骗&lt;br /&gt;改变cookie的值，发给服务器，就是cookie欺骗。&lt;br /&gt;正常情况下，受浏览器的内部cookie机制所限，每个cookie只能被它的原服务器所访问，我们操作不了原服务器。&lt;/p&gt;
&lt;p&gt;2.cookie使用示例&lt;/p&gt;
&lt;p&gt;index.html 写入cookie {&apos;username&apos;:&apos;zhangsan&apos;,&apos;psw&apos;:&apos;123&apos;}&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;lt;!&lt;/span&gt;&lt;span style=&quot;color: #ff00ff;&quot;&gt;DOCTYPE html&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;html&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;head&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;meta &lt;/span&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;http-equiv&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt; content&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;title&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;title&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;meta &lt;/span&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;charset&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;=&quot;utf-8&quot;&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;script &lt;/span&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;type&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt; src&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;=&quot;jquery.min.js&quot;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;script&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;script &lt;/span&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;type&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt; src&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;=&quot;jquery.cookie.js&quot;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;script&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;script &lt;/span&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;type&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;
    $.cookie(&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;&apos;&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;username&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;&apos;&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;zhangsan&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;);
    $.cookie(&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;&apos;&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;psw&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;&apos;&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;123&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;background-color: #f5f5f5; color: #000000;&quot;&gt;);
&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;script&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;head&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;body&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;body&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&quot;color: #800000;&quot;&gt;html&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;运行index.html,通过Chrome F12开发者工具，可以看到cookie信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/300946/201701/300946-20170106155059847-848303078.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到cookie要和domain域名对应。每个cookie只能被对应的域名所访问，其他域名无法访问。&lt;/p&gt;
&lt;p&gt;3.如何进行cookie欺骗&lt;/p&gt;
&lt;p&gt;修改hosts，将域名(dev.test.com)对应的ip转为自己的ip(121.43.113.200)，写在自己的ip下修改cookie，会发现域名对应的cookie更改了。&lt;br /&gt;步骤：&lt;br /&gt;1)修改host&lt;br /&gt;121.43.113.200      dev.test.com&lt;br /&gt;2)将index.html放入服务器121.43.113.200&lt;br /&gt;3)访问url:dev.test.com/index.html&lt;br /&gt;4)查看cookie信息&lt;br /&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/300946/201701/300946-20170106155240675-1380622233.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;5)还原host&lt;br /&gt;#121.43.113.200      dev.test.com&lt;br /&gt;6)访问url:dev.test.com，会发现dev.test.com中的cookie已被修改。&lt;/p&gt;
&lt;p&gt;4.cookie欺骗防止&lt;br /&gt;随机码防止cookie欺骗&lt;br /&gt;原理：在服务端生成唯一随机码，每次提交cookie时带上随机码，和服务端的随机码校验。&lt;/p&gt;]]&gt;&lt;/description&gt;&lt;/item&gt;&lt;/channel&gt;&lt;/rss&gt;
</code></pre><h2 id="2-将备份文件解析为-mk文件"><a href="#2-将备份文件解析为-mk文件" class="headerlink" title="2.将备份文件解析为.mk文件"></a>2.将备份文件解析为.mk文件</h2><p>备份文件中每个item节点，对应一篇文章。<br>将每个item中的title,pubDate,description解析出来，写入.mk文件。<br>代码如下所示：  </p>
<pre><code>#!/usr/bin/python
# -*- coding: UTF-8 -*-
import html2text
import xml.sax
import datetime
import sys  
reload(sys)  
sys.setdefaultencoding(&apos;utf8&apos;)   
class MovieHandler( xml.sax.ContentHandler ):
   def __init__(self):
      self.CurrentData = &quot;&quot;
      self.title = &quot;&quot;
      self.pubDate = &quot;&quot;
      self.description = &quot;&quot;

   # 元素开始事件处理
   def startElement(self, tag ,attributes):
      self.CurrentData = tag
      if tag==&quot;item&quot;:
          self.title = &quot;&quot;
          self.pubDate = &quot;&quot;
          self.description = &quot;&quot;

   # 元素结束事件处理
   def endElement(self, tag):
      if tag == &quot;item&quot;:
          try:
            filename=self.title+&quot;.md&quot;
            fo = open(&quot;D:\\certs\\&quot;+filename,&apos;a&apos;)
            fo.write( &quot;---\n&quot;)
            fo.write(&quot;title: &quot;+self.title+&quot;\n&quot;)
            GMT_FORMAT = &apos;%a, %d %b %Y %H:%M:%S GMT&apos;
            writedate=datetime.datetime.strptime(self.pubDate, GMT_FORMAT)
            fo.write( &quot;date: &quot;+writedate.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;)+&quot;\n&quot;)
            fo.write( &quot;tags: \n&quot;)
            fo.write( &quot;categories: \n&quot;)
            fo.write( &quot;---\n&quot;)
            writedesc=html2text.html2text(self.description)
            fo.write(writedesc)
            fo.close()
          except Exception as error:
            print error.message

   # 内容事件处理
   def characters(self, content):
      if self.CurrentData == &quot;title&quot;:
         self.title = content
      elif self.CurrentData == &quot;pubDate&quot;:
         self.pubDate = content
      elif self.CurrentData == &quot;description&quot;:
         self.description += content

if ( __name__ == &quot;__main__&quot;):

   # 创建一个 XMLReader
   parser = xml.sax.make_parser()
   # turn off namepsaces
   parser.setFeature(xml.sax.handler.feature_namespaces, 0)

   # 重写 ContextHandler
   Handler = MovieHandler()
   parser.setContentHandler( Handler )

   parser.parse(&quot;CNBlogs_BlogBackup_1_201701_201701.xml&quot;)
</code></pre><p>程序执行后，在D:\certs目录下就生成了hexo网站需要的.mk文件。<br>如下所示：<br><img src="https://raw.githubusercontent.com/shijingjing07/shijingjing07.github.com/master/img/2.png" alt=""></p>
<h2 id="将生成的-mk文件copy到hexo-posts目录下"><a href="#将生成的-mk文件copy到hexo-posts目录下" class="headerlink" title="将生成的.mk文件copy到hexo _posts目录下"></a>将生成的.mk文件copy到hexo _posts目录下</h2><pre><code>D:\hexo\source\_posts
</code></pre><h2 id="重新生成静态文件"><a href="#重新生成静态文件" class="headerlink" title="重新生成静态文件"></a>重新生成静态文件</h2><pre><code>hexo c
hexo g
hexo s
</code></pre><p>在浏览器中打开 <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a><br>结果如下：<br><img src="https://raw.githubusercontent.com/shijingjing07/shijingjing07.github.com/master/img/3.png" alt=""></p>
<h2 id="备份文件中没有分类，标签节点，所以无法将这两部分迁移到hexo。"><a href="#备份文件中没有分类，标签节点，所以无法将这两部分迁移到hexo。" class="headerlink" title="备份文件中没有分类，标签节点，所以无法将这两部分迁移到hexo。"></a>备份文件中没有分类，标签节点，所以无法将这两部分迁移到hexo。</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[webapi应用架构详解]]></title>
      <url>https://shijingjing07.github.io/2017/01/16/webapi%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="webapi适用场景"><a href="#webapi适用场景" class="headerlink" title="webapi适用场景"></a>webapi适用场景</h2><p>常见的应用包括以下四类，PC客户端程序，APP程序，网站程序，H5程序。<br>这些应用需要的数据，服务可由同一个接口服务程序提供，这样，大大提高了产品多平台设计开发的效率，避免了重复的编码。</p>
<h2 id="什么是webapi"><a href="#什么是webapi" class="headerlink" title="什么是webapi"></a>什么是webapi</h2><p>webapi一般采用restful风格。以tornado为例,url路由配置如下：  </p>
<pre><code>url = [
    (r&apos;/test&apos;, testfc.testHandler)
]
</code></pre><p>业务逻辑层,返回数据一般为json格式：  </p>
<pre><code>class testHandler(RequestHandler):
    def get(self):
        self.post()
    def post(self):
        result={}
        if True:
            result[&quot;code&quot;]=&quot;200&quot;
            result[&quot;status&quot;]=&quot;true&quot;
            result[&quot;result&quot;]=&quot;success&quot;
        else:
            result[&quot;code&quot;]=&quot;300&quot;
            result[&quot;status&quot;]=&quot;false&quot;
            result[&quot;result&quot;]=&quot;fail&quot;
        self.write(json_encode(result))
        return
</code></pre><p>webapi访问方式如下：</p>
<pre><code>http://127.0.0.1:9999/test
</code></pre><p>返回结果：</p>
<pre><code>{&quot;status&quot;: &quot;true&quot;, &quot;code&quot;: &quot;200&quot;, &quot;result&quot;: &quot;success&quot;}
</code></pre><h2 id="webapi架构设计"><a href="#webapi架构设计" class="headerlink" title="webapi架构设计"></a>webapi架构设计</h2><p>如何确认一个app能够访问webapi?<br>使用AppID验证app访问webapi的合法性，AppID为服务端给出的一个ID标志。<br>我们可以为web/app/winform分别分配一个ID，从而可以确定访问的合法性，和访问的渠道。  </p>
<p>如何保证app参数的正确性，没有被篡改？<br>客户端使用AppID对应的AppSecert，对参数进行签名(MD5/SHA等)<br>服务端使用同样的方式签名，和客户端签名校验。  </p>
<p>如何防止webapi url被截获，重新访问？<br>客户端访问webapi时带上时间戳参数，服务端对时间戳进行校验，如10分钟内的访问才是有效的。  </p>
<p>涉及具体用户的操作时，如何验证用户？<br>可以使用username,psw参数的方式访问webapi。但是这种方式很不安全。<br>使用授权token是很好的解决办法。在用户登录成功时，服务端生成一个授权码，对应用户信息。<br>访问时带上token参数，服务端查询token有效性，和token对应的用户信息。  </p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>签名代码如下:</p>
<pre><code>#coding:utf-8

__author__ = &apos;jy&apos;

import sys
reload(sys)
sys.setdefaultencoding(&apos;utf-8&apos;)
sys.path.append(&apos;..&apos;)
import datetime
import time
import math
import hashlib
import urllib
def md5encode(source):
    m2 = hashlib.md5()
    m2.update(source)
    return m2.hexdigest()
def dataSort(data):
    dataKeys=data.keys()
    dataKeys.sort()
    result=&quot;&quot;
    for key in dataKeys:
        result+=key.strip()
        result+=data[key].strip()
    return result 
def dataSecret(data):
    secret=&quot;af4d2c92-4bb7-11e5-8111-00163e001071&quot;
    data=secret+data+secret
    return data 
def getSign(postdata):
    try:
        #升序排列,合并为字符串
        dataSign=dataSort(postdata)
        #加密钥
        dataSign=dataSecret(dataSign)
        #md5编码
        dataSign=md5encode(dataSign)
        return dataSign
    except Exception as error:
        pass
</code></pre><p>验证url参数代码如下：</p>
<pre><code>#coding:utf-8
__author__ = &apos;haoy&apos;

import sys
reload(sys)
sys.setdefaultencoding(&apos;utf-8&apos;)
sys.path.append(&apos;..&apos;)
from tornado.escape import json_decode, json_encode
import datetime
import time
import math
from utils.sign import *
def valiUrldata(data):
    result={}
    try:
        #判断appKey是否合法
        appKey=data.get(&quot;appKey&quot;,&quot;&quot;) 
        if appKey!=&quot;21ec85ec-30ca-491b-8bfb-c05e479eadc0&quot;:
            result[&quot;code&quot;]=&quot;300&quot;
            result[&quot;status&quot;]=&quot;false&quot;
            result[&quot;result&quot;]=&quot;账号不合法&quot;
            return result
        #appKey对应的secret
        appSecret=&quot;af4d2c92-4bb7-11e5-8111-00163e001071&quot;
        #检验时间
        timeStamp=data.get(&quot;timeStamp&quot;,&quot;0&quot;)
        timeStamp=int(timeStamp)
        nowtime=int(round(time.time()))

        if abs(timeStamp-nowtime)&gt;600:
            result[&quot;code&quot;]=&quot;300&quot;
            result[&quot;status&quot;]=&quot;false&quot;
            result[&quot;result&quot;]=&quot;请求时间戳不合法&quot;
            return result

        #校验签名
        clientSign=data.get(&quot;sign&quot;,&quot;&quot;)
        if clientSign==&quot;&quot;:
            result[&quot;code&quot;]=&quot;300&quot;
            result[&quot;status&quot;]=&quot;false&quot;
            result[&quot;result&quot;]=&quot;请求参数签名不能为空&quot;
            return result
        data.pop(&quot;sign&quot;)
        serverSign=getSign(data)
        print serverSign
        if clientSign!=serverSign:
            result[&quot;code&quot;]=&quot;300&quot;
            result[&quot;status&quot;]=&quot;false&quot;
            result[&quot;result&quot;]=&quot;请求参数签名不合法&quot;
            return result
        result[&quot;code&quot;]=&quot;200&quot;
        result[&quot;status&quot;]=&quot;true&quot;
        result[&quot;result&quot;]=&quot;通过验证&quot;
        return result
    except Exception as error:
        result[&quot;code&quot;]=&quot;300&quot;
        result[&quot;status&quot;]=&quot;false&quot;
        result[&quot;result&quot;]=&quot;异常:&quot;+error.message
        return result
</code></pre><p>登录代码如下：  </p>
<pre><code>import uuid
import redis
class testLoginHandler(BaseHandler):
    def get(self):
        self.post()
    def post(self):
        #获取url参数
        args=self.request.arguments
        data={}
        for key in args:
            data[key]=self.get_argument(key,&quot;&quot;)
        #验证url参数
        valiResult=valiUrldata(data)
        if valiResult[&quot;code&quot;]==&quot;300&quot;:
            self.write(json_encode(valiResult).decode(&quot;unicode_escape&quot;))
            return
        username=self.get_argument(&quot;username&quot;,&quot;&quot;)
        psw=self.get_argument(&quot;psw&quot;,&quot;&quot;)
        if username==&quot;shijingjing07&quot; and psw==&quot;123456&quot;:
            token = uuid.uuid1()
            redisPool = redis.ConnectionPool(host=&apos;127.0.0.1&apos;,password=&apos;123456&apos;, port=6379, db=0)
            cache = redis.Redis(connection_pool=redisPool)
            cache.setex(token,username,300)
            result[&quot;code&quot;] = 200
            result[&quot;status&quot;] = &quot;true&quot;
            result[&quot;result&quot;] = token
        else:
            result[&quot;code&quot;] = 300
            result[&quot;status&quot;] = &quot;false&quot;
            result[&quot;result&quot;] = &quot;account illegal&quot;
        self.write(json_encode(result))
</code></pre><p>返回结果：  </p>
<pre><code>{&quot;status&quot;: &quot;true&quot;, &quot;code&quot;: 200, &quot;result&quot;: &quot;5720c334-dbcc-11e6-84f1-00163e001071&quot;}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[cookie欺骗]]></title>
      <url>https://shijingjing07.github.io/2017/01/06/cookie%E6%AC%BA%E9%AA%97/</url>
      <content type="html"><![CDATA[<p>1.什么是cookie欺骗<br>改变cookie的值，发给服务器，就是cookie欺骗。<br>正常情况下，受浏览器的内部cookie机制所限，每个cookie只能被它的原服务器所访问，我们操作不了原服务器。</p>
<p>2.cookie使用示例</p>
<p>index.html 写入cookie {‘username’:’zhangsan’,’psw’:’123’}</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;jquery.cookie.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        $.cookie(&apos;username&apos;, &quot;zhangsan&quot;);
        $.cookie(&apos;psw&apos;, &quot;123&quot;);
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>运行index.html,通过Chrome F12开发者工具，可以看到cookie信息。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201701/300946-20170106155059847-848303078.png" alt=""></p>
<p>可以看到cookie要和domain域名对应。每个cookie只能被对应的域名所访问，其他域名无法访问。</p>
<p>3.如何进行cookie欺骗</p>
<p>修改hosts，将域名(dev.test.com)对应的ip转为自己的ip(121.43.113.200)，写在自己的ip下修改cookie，会发现域名对应的cookie更改了。<br>步骤：<br>1)修改host<br>121.43.113.200 dev.test.com<br>2)将index.html放入服务器121.43.113.200<br>3)访问url:dev.test.com/index.html<br>4)查看cookie信息<br><img src="http://images2015.cnblogs.com/blog/300946/201701/300946-20170106155240675-1380622233.png" alt=""><br>5)还原host  </p>
<p>#121.43.113.200 dev.test.com<br>6)访问url:dev.test.com，会发现dev.test.com中的cookie已被修改。</p>
<p>4.cookie欺骗防止<br>随机码防止cookie欺骗<br>原理：在服务端生成唯一随机码，每次提交cookie时带上随机码，和服务端的随机码校验。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[nginx文件目录权限设置]]></title>
      <url>https://shijingjing07.github.io/2016/12/30/nginx%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>1.有时我们web服务器上的某个文件夹只允许特定人员访问，这时我们需要在nginx配置文件中配置该文件夹的访问权限。</p>
<p>2.生成用户名单<br>在nginx中我们使用htpasswd来生成用户名单<br>下载这个python文件：<a href="http://trac.edgewall.org/export/10770/trunk/contrib/htpasswd.py" target="_blank" rel="external">http://trac.edgewall.org/export/10770/trunk/contrib/htpasswd.py</a><br>（nginx wiki里推荐的）<br>运行示例：</p>
<pre><code>chmod 777 htpasswd.py
./htpasswd.py -c -b htpasswd username password
</code></pre><p>#-c为生成文件 htpasswd为文件名</p>
<p>nginx 的 http auth basic 的密码是用 crypt(3) 加密的<br>我们把生成的htpasswd文件放到/etc/nginx目录中，修改权限chmod 400 htpasswd来保护一下该文件。</p>
<p>3.修改nginx配置文件</p>
<pre><code>server {
server_name www.test.com;
root /usr/share/nginx/html;
location /devdoc {
autoindex on;#显示文件列表
index index.html index.htm;#默认首页
charset utf-8;#编码
auth_basic &quot;Restricted&quot;;#访问权限类型
auth_basic_user_file /etc/nginx/htpasswd;#用户名单
}
}
</code></pre><p>重启nginx即可。访问网站www.test.com/devdoc，需要输入我们设置的用户名密码登录才能访问文件。如下图所示：<br><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161230174155304-2076405830.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSRF攻击]]></title>
      <url>https://shijingjing07.github.io/2016/12/30/CSRF%E6%94%BB%E5%87%BB/</url>
      <content type="html"><![CDATA[<p>1.什么是CSRF攻击<br>CSRF(Cross-site request forgery)，跨站请求伪造。<br>CSRF攻击的原理如下：<br>1)用户登录正常的网站A后，在本地生成Cookie<br>2)在不登出A的情况下，访问了危险网站B<br>3)网站B中含有网站A的链接，点击网站A的链接，会调用本地cookie验证，自动登录网站A。</p>
<p>CSRF攻击源于WEB的隐式身份验证机制，WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。</p>
<p>2.原理图如下：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161230105937070-1267632684.png" alt=""></p>
<p>3.CSRF的防御<br>1)Cookie Hashing(所有表单都包含同一个伪随机值)：<br>CSRF的问题在于网站验证cookie存在的情况下，黑客可以直接登录网站。<br>我们可以在访问网站时，生成一个伪随机数，访问网站每个页面时带上这个伪随机数，服务端验证cookie和伪随机数是否一致。<br>这样可以确保网站A的链接不是由第三方网站直接跳转过来的，因为第三方网站是无法获得网站的cookie伪随机数的。</p>
<p>2)验证码<br>登录网站时设置验证码，是很常用的方式，可以完全解决CSRF的问题。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTTP长连接和短连接]]></title>
      <url>https://shijingjing07.github.io/2016/12/28/HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5/</url>
      <content type="html"><![CDATA[<p>1.HTTP协议的五大特点<br>1)支持客户/服务器模式<br>2)简单快速<br>3)灵活<br>4)无连接<br>每次连接只处理一个请求，服务器处理完客户的请求，并受到客户的应答后，断开连接。<br>5)无状态<br>协议不会记录服务器客户端状态。</p>
<p>2.保持HTTP连接状态的两种方式<br>1)Cookie<br>在访问统一网站时，可以将信息写入cookie，方便在不同的页面间提取信息。</p>
<p>2)Session<br>Session保存在服务器上，同时将标识Session的SessionId传递给客户端浏览器，保存在cookie中，浏览器关闭后，这个cookie就会被清掉。</p>
<p>浏览器每次请求都会额外加上这个参数值，服务器根据这个SessionId，就能取得客户端的数据信息。</p>
<p>3.什么是HTTP长连接，短连接<br>HTTP的长连接，短连接本质上是TCP长连接，短连接。</p>
<p>在HTTP/1.0中，默认使用的是短连接。<br>即浏览器和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。这样，如果一个网页中包含其他的web资源，如JavaScript文件，图像文件，CSS文件等，都需要建立连接。</p>
<p>从HTTP/1.1起，默认使用长连接。我们可以看到响应头有这样一行代码：Connection:keep-alive<br>当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这条已经建立的连接。</p>
<p>4.长连接短连接操作过程<br>短连接的操作步骤是：<br>建立连接—-数据传输—-关闭连接…建立连接—-数据传输—-关闭连接<br>长连接的操作步骤是：<br>建立连接—-数据传输…（保持连接）…数据传输—-关闭连接</p>
<p>5.长连接短连接的优缺点<br>长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。<br>Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭长时间没有读写事件的连接；限制每个客户端的最大长连接数。<br>短连接对服务器来说管理较为简单，存在的连接都是有用的连接。但如果客户请求频繁，将在TCP的建立和关闭上浪费时间和带宽。</p>
<p>6.长连接短连接使用场合<br>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。如数据库的连接。<br>而像web网站的http服务一般用短连接，因为长连接对于服务端来说会耗费一定的资源，而像web网站这么频繁的成千上万甚至上亿客户端的连接用短连接更省资源，如果用长连接，而且同时有成千上万的用户。如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作的情况下用短连接好。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[类与类之间的关系-依赖，关联，聚合，组合，继承泛化的区别]]></title>
      <url>https://shijingjing07.github.io/2016/12/28/%E7%B1%BB%E4%B8%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB-%E4%BE%9D%E8%B5%96%EF%BC%8C%E5%85%B3%E8%81%94%EF%BC%8C%E8%81%9A%E5%90%88%EF%BC%8C%E7%BB%84%E5%90%88%EF%BC%8C%E7%BB%A7%E6%89%BF%E6%B3%9B%E5%8C%96%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>1)依赖<br>依赖关系是类与类之间的联接。一个类依赖于另一个类的定义。如，一个人(Person)可以买车(Car)和房子(House),Person类依赖于Car和House的定义，因为Person引入了Car和House。与关联不同的是，Person类中没有Car和House的属性，Car和House的实例是以参量的方式传入到buy()方法中的。一般而言，依赖关系在Java语言中体现为局部变量，方法形参，或者对静态方法的调用。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161228101136961-696404574.png" alt=""></p>
<p>2)关联<br>关联是类与类之间的联接，使一个类知道另一个类的属性和方法。关联可以是双向，也可以是单向的。一般使用成员变量来实现。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161228101151773-384156678.png" alt=""></p>
<p>3)聚合<br>聚合是一种强的关联关系。是整体和个体之间的关系。例如，汽车类与引擎类，轮胎类之间的关系就是整体与个体之间的关系。与关联关系一样，聚合关系也是通过实例变量实现的。但是关联关系涉及的两个类在同一层次，而聚合关系中两个类处在不平等的层次上，一个代表整体，一个代表部分。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161228101335851-1483683152.png" alt=""></p>
<p>4)组合<br>组合也是关联关系的一种，一种比聚合关系强的关系。组合关系中的部分类不能独立于整体类存在。整体类和部分类有相同的生命周期。如Person类和Leg类。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161228101350570-1896750592.png" alt=""></p>
<p>5)继承/泛化<br>泛化和继承其实是一个逆过程 泛化就是有子类抽象出一个父类 而继承就是由父类具体化一个子类 例如足球比联赛跟什么西甲 意甲 英超之间就是泛化/继承的关系</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161228101408773-94063945.png" alt=""></p>
<p>6)组合和聚合的区别<br>组合和聚合都属于关联，所以它们之间难免有相似之处，区别举例来说明：<br>程老师的《大话》里举大那个大雁的例子很贴切 在此我就借用一下 大雁喜欢热闹害怕孤独 所以它们一直过着群居的生活 这样就有了雁群 每一只大雁都有自己的雁群<br>每个雁群都有好多大雁 大雁与雁群的这种关系就可以称之为聚合 另外每只大雁都有两只翅膀 大雁与雁翅的关系就叫做组合 有此可见 聚合的关系明显没有组合紧密<br>大雁不会因为它们的群主将雁群解散而无法生存 而雁翅就无法脱离大雁而单独生存—-组合关系的类具有相同的生命周期<br>聚合关系图：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161228101435898-1130053478.png" alt=""></p>
<p>聚合关系图：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161228101455429-49000952.png" alt=""></p>
<p>雁群类：</p>
<pre><code>public class GooseGroup
{
    publi Goose goose;
    public GooseGroup(Goose goose){
        this.goose=goose;
    }
}
</code></pre><p>大雁类：</p>
<pre><code>public class Goose{
    public Wings wings;
    public Goose()
    {
        wings=new Wings();
    }
}    
</code></pre><p>从构造函数来看，GooseGroup的构造函数要用到Goose作为参数把值传进来，Goose可以脱离GooseGroup独立存在。<br>组合关系中整体类含有部分类的实例化，Goose在实例化之前，一定要先实例化Wings，两个类紧密耦合在一起，它们有相同的生命周期，Wings不能独立于Goose存在。</p>
<p>从信息封装来看，聚合关系中，客户端同时了解GooseGroup和Goose，因为它们是独立的。<br>而在组合关系中，客户端只认识大雁类，根本不知道翅膀类的存在，因为翅膀类被严密封装在大雁类中。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式六大原则]]></title>
      <url>https://shijingjing07.github.io/2016/12/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<p>1.设计模式的目的<br>设计模式是为了更好的代码重用性，可读性，可靠性，可维护性。</p>
<p>2.常用的六大设计模式<br>1)单一职责原则<br>2)里氏替换原则<br>3)依赖倒转原则<br>4)接口隔离原则<br>5)迪米特法则<br>6)开闭原则</p>
<p>3.单一职责原则<br>该原则是针对类来说的，即一个类应该只负责一项职责。<br>如类T负责两个不同职责：职责P1，职责P2。当职责P1需求变更而改变T时，可能造成职责P2发生故障，所以需要将类T的粒度分解为T1，T2。<br>示例如下：<br>用一个类秒数动物呼吸这个场景</p>
<pre><code>class Animal {
    public void breathe(string animal)
    {
        Console.WriteLine(animal+&quot;呼吸空气&quot;);
    }
}
class Program
{
    static void Main(string[] args)
    {
        Animal animal = new Animal();
        animal.breathe(&quot;牛&quot;);
        animal.breathe(&quot;羊&quot;);
        animal.breathe(&quot;猪&quot;);
        animal.breathe(&quot;鱼&quot;);
        Console.ReadLine();
    }
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161227221245086-1277429426.png" alt=""></p>
<p>我们发现不是所有动物都是呼吸空气的，比如鱼就是呼吸水的，根据单一职责原则，我们将Animal类细分为陆生动物类和水生动物类，如下所示：</p>
<pre><code>class Terrestrial
{
    public void breathe(string animal)
    {
        Console.WriteLine(animal+&quot;呼吸空气&quot;);
    }
}
class Aquatic
{
    public void breathe(string animal)
    {
        Console.WriteLine(animal + &quot;呼吸水&quot;);
    }
}
class Program
{
    static void Main(string[] args)
    {
        Terrestrial terrestrial = new Terrestrial();
        terrestrial.breathe(&quot;牛&quot;);
        terrestrial.breathe(&quot;羊&quot;);
        terrestrial.breathe(&quot;猪&quot;);
        Aquatic aquatic = new Aquatic();
        aquatic.breathe(&quot;鱼&quot;);
        Console.ReadLine();
    }
}
</code></pre><p>我们发现这样修改的花销很大，既要将原来的类分解，又要修改客户端。而直接修改Animal类虽然违背了单一职责原则，但花销小的多，如下所示：</p>
<pre><code>class Animal
{
    public void breathe(string animal)
    {
        if (&quot;鱼&quot;.Equals(animal))
        {
            Console.WriteLine(animal + &quot;呼吸水&quot;);
        }
        else {
            Console.WriteLine(animal + &quot;呼吸空气&quot;);
        }
    }
}
class Program
{
    static void Main(string[] args)
    {
        Animal animal = new Animal();
        animal.breathe(&quot;牛&quot;);
        animal.breathe(&quot;羊&quot;);
        animal.breathe(&quot;猪&quot;);
        animal.breathe(&quot;鱼&quot;);
        Console.ReadLine();
    }
}
</code></pre><p>可以看到，这种修改方式简单的多。但却存在隐患，一天需要将鱼分为淡水鱼，海水鱼，又需要修改Animal类的breathe方法。可能给”猪牛羊”等相关功能带来风险，这种修改直接在代码级别违背了单一职责原则，虽然修改起来最简单，但隐患最大。还有一种修改方式：</p>
<pre><code>class Animal
{
    public void breathe(string animal)
    {
         Console.WriteLine(animal + &quot;呼吸空气&quot;);
    }
    public void breathe2(string animal)
    {
        Console.WriteLine(animal + &quot;呼吸水&quot;);
    }
}
class Program
{
    static void Main(string[] args)
    {
        Animal animal = new Animal();
        animal.breathe(&quot;牛&quot;);
        animal.breathe(&quot;羊&quot;);
        animal.breathe(&quot;猪&quot;);
        animal.breathe2(&quot;鱼&quot;);
        Console.ReadLine();
    }
} 
</code></pre><p>这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然违背了单一职责原则，但在方法级别上却是符合单一职责原则的。那么在实际编程中，采用哪一种呢？我的原则是，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，才可以在方法级别违反单一职责原则。</p>
<p>遵循单一职责的优点：<br>1)降低类的复杂度，一个类只负责一项职责。<br>2)提高类的可读性，可维护性<br>3)降低变更引起的风险。</p>
<p>4.里氏替换原则<br>该原则是在1988年，由麻省理工学院的以为姓里的女士提出的。<br>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。<br>换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</p>
<p>由定义可知，在使用继承时，遵循里氏替换原则，在子类中尽量不要重写和重载父类的方法。<br>继承包含这样一层含义：父类中凡是已经实现好的方法（相对抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。<br>继承作为面向对象三大特性之一，在给程序设计带来巨大遍历的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。<br>举例说明继承的风险，我们需要完成一个两数相减的功能，由类A来负责。</p>
<pre><code>class A{
    public int func1(int a,int b){
        return a-b;
    }
}
public class Client{
    public static void main(string[] args){
        A a=new A();
        System.out.println(&quot;100-50=&quot;+a.func1(100,50));
        System.out.println(&quot;100-80=&quot;+a.func1(100,80));
    }
}
</code></pre><p>运行结果：</p>
<p>100-50=50<br>100-80=20</p>
<p>后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。</p>
<pre><code>Class B extends A{
    public int func1(int a,int b){
        return a+b;
    }
    public int func2(int a,int b){
        return func1(a,b)+100;
    }
}
public class Client{
    public static void main(string[] args){
        B a=new B();
        System.out.println(&quot;100-50=&quot;+b.func1(100,50));
        System.out.println(&quot;100-80=&quot;+b.func1(100,80));
        System.out.println(&quot;100+20+100=&quot;+b.func2(100,20));
    }
}
</code></pre><p>运行结果：</p>
<p>100-50=150<br>100-80=180<br>100+20+100=220</p>
<p>我们发现原来运行正常的相减功能发生了错误。原因就是类B无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候，如果非要重写父类的方法，通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替。</p>
<p>5.依赖倒转原则<br>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。<br>类A直接依赖类B，如果要将类A改为依赖类C，则必须通过修改类A的代码来达成。此时，类A一般是高层模块，负责复杂的业务逻辑，类B和类C是低层模块，负责基本的原子操作；修改A会给程序带来风险。<br>将类A修改未依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或类C发生联系，则会大大降低修改类A的记几率。<br>依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类，使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。<br>依赖倒置的中心思想是面向接口编程。</p>
<p>代码示例如下：</p>
<pre><code>class Book {
    public string getContent() {
        return &quot;很久很久以前。。。。。&quot;;
    }
}
class Mother {
    public void narrate(Book book)
    {
        Console.WriteLine(book.getContent());
    }
}
class Program
{
    static void Main(string[] args)
    {
        Mother monther = new Mother();
        monther.narrate(new Book());
        Console.ReadLine();
    }
}
</code></pre><p>运行结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161227221502773-795863634.png" alt=""></p>
<p>如果读的对象是报纸，杂志，却发现客户端不适用了。<br>我们引入一个抽象的接口IReader,代表读物</p>
<pre><code>interface IReader{
    public string getContent();
}
</code></pre><p>这样Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，修改代码如下：</p>
<pre><code>interface IReader {
         string getContent();
    }
    class Newspaper: IReader
    {
    public string getContent()
    {
        return &quot;切尔西豪取12连胜&quot;;
    }
}
class Book:IReader
{

    public string getContent()
{
    return &quot;很久很久以前。。。。&quot;;
}
}
class Mother
{
    public void narrate(IReader reader)
    {
        Console.WriteLine(reader.getContent());
    }
}
class Program
{
    static void Main(string[] args)
    {
        Mother monther = new Mother();
        monther.narrate(new Book());
        monther.narrate(new Newspaper());
        Console.ReadLine();
    }
}
</code></pre><p>运行结果:</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161227221546539-427144726.png" alt=""></p>
<p>采用依赖倒置原则给多人并行开发带来极大的便利，比如上列中Mother类与Book类直接耦合，Mother必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序可以同时开工，互不影响。<br>依赖关系的传递有三种方式，接口传递，构造方法传递和setter方法传递。<br>接口传递：</p>
<pre><code>interface IDriver{
    public void drive(ICar car);
}
public class Driver:IDriver{
    public void drive(ICar car){
        car.run();
    }
}
</code></pre><p>构造方法传递：</p>
<pre><code>interface IDriver{
    public void drive();
}
public class Driver implements IDriver{
    public ICar car;
    public Driver(ICar _car){
        this.car=_car;
    }
    public void drive(){
        this.car.run();
    }
}
</code></pre><p>setter方式传递：</p>
<pre><code>interface IDriver{
    public void setCar(ICar car);
    public void drive();
}
public class Driver:IDriver{
    PRIVATE ICar car;
    public void setCar(ICar car){
        this.car=car;
    }
    public void drive(){
        this.car.run();
    }
}
</code></pre><p>在实际编程中，一般需要做到如下3点：<br>低层模块尽量都要有抽象类或接口，或者两者都有。<br>变量的声明类型尽量是抽象类或接口。<br>使用继承时遵循里氏替换原则</p>
<p>6.接口隔离原则<br>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。<br>类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类C来说不是最小接口，则类B和类D必须去实现他们不需要的方法。<br>将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。<br>举例说明接口隔离原则：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161227221656132-1065812137.png" alt=""></p>
<p>这个图的意思是：类A依赖接口I中的方法1，方法2，方法3，类B是对类A依赖的实现；类C依赖接口I中的方法1，方法4，方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然存在用不到的方法（红色标记所示），但由于实现了接口I，所以也必须要实现这些用不到的方法。代码如下：</p>
<pre><code>interface I{
    void method1();
    void method2();
    void method3();
    void method4();
    void method5();
}
class A{
    public void depend1(I i){
        i.method1();
    }
    public void depend2(I i){
        i.method2();
    }
    public void depend3(I i){
        i.method3();
    }
}
class C{
    public void depend1(I i){
        i.method1();
    }
    public void depend2(I i){
        i.method4();
    }
    public void depend3(I i){
        i.method5();
    }
}
class B:I{
    public void method1(){
        Console.WriteLine(&quot;类B实现接口I的方法1&quot;);
    }
    public void method2(){
        Console.WriteLine(&quot;类B实现接口I的方法2&quot;);
    }
    public void method3(){
        Console.WriteLine(&quot;类B实现接口I的方法3&quot;);
    }
    public void method4(){}
    public void method5(){}
}
class D:I{
    public void method1(){
        Console.WriteLine(&quot;类B实现接口I的方法1&quot;);
    }
    public void method2(){}
    public void method3(){}
    public void method4(){
        Console.WriteLine(&quot;类B实现接口I的方法4&quot;);
    }
    public void method5(){
        Console.WriteLine(&quot;类B实现接口I的方法5&quot;);
    }
}
class Program
{
    static void Main(string[] args)
    {
        A a=new A();
        a.depend1(new B());
        a.depend2(new B());
        a.depend3(new B());

        C c=new C();
        c.depend1(new D());
        c.depend2(new D());
        c.depend3(new D());
        Console.ReadLine();
    }
}
</code></pre><p>可以看到，接口中出现的方法，不管对依赖于它的类有没有作用，实现类中都必须去实现这些方法。于是我们将原接口I拆分为三个接口：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161227221732117-1230926316.png" alt=""></p>
<p>代码如下所示：</p>
<pre><code>interface I1{
    void method1();
}
interface I2{
    void method2();
    void method3();
}
interface I3{
    void method4();
    void method5();
}
class A{
    public void depend1(I1 i){
        i.method1();
    }
    public void depend2(I2 i){
        i.method2();
    }
    public void depend3(I2 i){
        i.method3();
    }
}
class C{
    public void depend1(I1 i){
        i.method1();
    }
    public void depend2(I3 i){
        i.method4();
    }
    public void depend3(I3 i){
        i.method5();
    }
}
class B:I1,I2{
    public void method1(){
        Console.WriteLine(&quot;类B实现接口I1的方法1&quot;);
    }
    public void method2(){
        Console.WriteLine(&quot;类B实现接口I2的方法2&quot;);
    }
    public void method3(){
        Console.WriteLine(&quot;类B实现接口I2的方法3&quot;);
    }
}
class D:I1,I3{
    public void method1(){
        Console.WriteLine(&quot;类B实现接口I的方法1&quot;);
    }
    public void method4(){
        Console.WriteLine(&quot;类B实现接口I的方法4&quot;);
    }
    public void method5(){
        Console.WriteLine(&quot;类B实现接口I的方法5&quot;);
    }
}
class Program
{
    static void Main(string[] args)
    {
        A a=new A();
        a.depend1(new B());
        a.depend2(new B());
        a.depend3(new B());

        C c=new C();
        c.depend1(new D());
        c.depend2(new D());
        c.depend3(new D());
        Console.ReadLine();
    }
}
</code></pre><p>说到这里，可能会觉得接口隔离原则和之前的单一职责原则很相似，其实不然。一，单一职责注重职责，而接口隔离原则注重对接口依赖的隔离；二，单一职责是约束类，其次是方法，针对的是程序中的实现和细节；而接口隔离原则约束的是接口，针对的是抽象，程序整体框架的构建。</p>
<p>7.迪米特法则<br>一个对象应该对其他对象保持最少的了解。<br>类与类关系越密切，耦合度越大。<br>迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public<br>方法，不对外泄露任何信息。<br>迪米特法则还有个更简单的定义：只与直接的朋友通信。<br>什么是直接的朋友：每个对象都会与其他对象由耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。<br>举例额说明如下，有一个集团公司，下属单位有分公司和直属部门，现要求打印出所有下属单位的员工ID。</p>
<pre><code>class Employee{
    private string id;
    public void setId(string id){
        this.id=id;
    }
    public string getId(){
        return id;
    }
}
class SubEmployee{
    private string id;
    public void setId(string id){
        this.id=id;
    }
    public string getId(){
        return id;
    }
}
class SubCompanyManager{
    public List&lt;SubEmployee&gt; getAllEmployee(){
        List&lt;SubEmployee&gt; list=new ArrayList(SubEmployee);
        for(int i=0;i&lt;100;i++){
            SubEmployee emp=new SubEmployee();
            emp.setId(&quot;分公司&quot;+i);
            list.add(emp);
        }
        return list;
    }
}
class CompanyManager{
    public List&lt;Employee&gt; getAllEmployee(){
        List&lt;Employee&gt; list=new ArrayList&lt;Employee&gt;();
        for(int i=0;i&lt;30;i++)
        {
            Employee emp=new Employee();
            emp.setId(&quot;总公司&quot;+i);
            list.add(emp);
        }
        return list;
    }
    publi void printAllEmployee(SubCompanyManager sub){
        List&lt;SubEmployee&gt; list1=sub.getAllEmployee();
        foreach(SubEmployee e in list1){
            Console.WriteLine(e.getId());
        }
        List&lt;Employee&gt; list2=this.getAllEmployee();
        foreach(Employee e in list2){
            Console.WriteLine(e.getId());
        }
    }
}
class Program
{
    static void Main(string[] args)
    {
        CompanyManager e=new CompanyManager();
        e.printAllEmployee(new SubCompanyManager());
        Console.ReadLine();
    }
}
</code></pre><p>这个设计的问题在于CompanyManager中，SubEmployee类并不是CompanyManager类的直接朋友，按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:</p>
<pre><code>class SubCompanyManager{
    public List&lt;SubEmployee&gt; getAllEmployee(){
        List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;();
        for(int i=0; i&lt;100; i++){
            SubEmployee emp = new SubEmployee();
            //为分公司人员按顺序分配一个ID
            emp.setId(&quot;分公司&quot;+i);
            list.add(emp);
        }
        return list;
    }
    public void printEmployee(){
        List&lt;SubEmployee&gt; list = this.getAllEmployee();
        for(SubEmployee e:list){
            System.out.println(e.getId());
        }
    }
}
class CompanyManager{
    public List&lt;Employee&gt; getAllEmployee(){
        List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();
        for(int i=0; i&lt;30; i++){
            Employee emp = new Employee();
            //为总公司人员按顺序分配一个ID
            emp.setId(&quot;总公司&quot;+i);
            list.add(emp);
        }
        return list;
    }

    public void printAllEmployee(SubCompanyManager sub){
        sub.printEmployee();
        List&lt;Employee&gt; list2 = this.getAllEmployee();
        for(Employee e:list2){
            System.out.println(e.getId());
        }
    }
}
</code></pre><p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。</p>
<p>8.开闭原则<br>一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节。<br>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。<br>当我们遵循前面介绍的5大原则，以及使用23中设计模式的目的就是遵循开闭原则。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【python】多进程锁multiprocess.Lock]]></title>
      <url>https://shijingjing07.github.io/2016/12/20/%E3%80%90python%E3%80%91%E5%A4%9A%E8%BF%9B%E7%A8%8B%E9%94%81multiprocess.Lock/</url>
      <content type="html"><![CDATA[<p>#<br><a href="http://blog.csdn.net/moxiaomomo/article/details/11640439" target="_blank" rel="external">【python】多进程锁multiprocess.Lock</a></p>
<p>2013-09-13 13:48 11613人阅读<br><a href="http://blog.csdn.net/moxiaomomo/article/details/11640439#comments" target="_blank" rel="external">评论</a>(2) 收藏<br><a href="http://blog.csdn.net/moxiaomomo/article/details/11640439#report" title="举报" target="_blank" rel="external">举报</a></p>
<p><img src="http://static.blog.csdn.net/images/category_icon.jpg" alt=""> 分类：</p>
<p>Python（38） <img src="http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg" alt=""></p>
<p>同步的方法基本与多线程相同。</p>
<p>1) Lock</p>
<p>当多个进程需要访问共享资源的时候，Lock可以用来避免访问的冲突。</p>
<p><strong>[python]</strong> <a href="http://blog.csdn.net/moxiaomomo/article/details/11640439#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/moxiaomomo/article/details/11640439#" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li>import multiprocessing  </li>
<li>import sys  </li>
<li></li>
<li>def worker_with(lock, f):  </li>
<li>with lock:  </li>
<li>fs = open(f,”a+”)  </li>
<li>fs.write(‘Lock acquired via with\n’)  </li>
<li>fs.close()  </li>
<li></li>
<li>def worker_no_with(lock, f):  </li>
<li>lock.acquire()  </li>
<li>try:  </li>
<li>fs = open(f,”a+”)  </li>
<li>fs.write(‘Lock acquired directly\n’)  </li>
<li>fs.close()  </li>
<li>finally:  </li>
<li>lock.release()  </li>
<li></li>
<li>if <strong>name</strong> == “<strong>main</strong>“:  </li>
<li></li>
<li>f = “file.txt”  </li>
<li></li>
<li>lock = multiprocessing.Lock()  </li>
<li>w = multiprocessing.Process(target=worker_with, args=(lock, f))  </li>
<li>nw = multiprocessing.Process(target=worker_no_with, args=(lock, f))  </li>
<li></li>
<li>w.start()  </li>
<li>nw.start()  </li>
<li></li>
<li>w.join()  </li>
<li>nw.join()  </li>
</ol>
<p>在上面的例子中，如果两个进程没有使用lock来同步,则他们对同一个文件的写操作可能会出现混乱。</p>
<p>2）Semaphore</p>
<p>Semaphore用来控制对共享资源的访问数量，例如池的最大连接数。</p>
<p><strong>[python]</strong> <a href="http://blog.csdn.net/moxiaomomo/article/details/11640439#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/moxiaomomo/article/details/11640439#" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li>import multiprocessing  </li>
<li>import time   </li>
<li></li>
<li>def worker(s,i):  </li>
<li>s.acquire()  </li>
<li>print(multiprocessing.current_process().name + “ acquire”)  </li>
<li>time.sleep(i)  </li>
<li>print(multiprocessing.current_process().name + “ release”)  </li>
<li>s.release()  </li>
<li></li>
<li>if <strong>name</strong> == “<strong>main</strong>“:  </li>
<li></li>
<li>s = multiprocessing.Semaphore(2)  </li>
<li>for i in range(5):  </li>
<li>p = multiprocessing.Process(target=worker, args=(s,i*2))  </li>
<li>p.start()  </li>
</ol>
<p>上面的实例中使用semaphore限制了最多有2个进程同时执行。</p>
<p>3）Event</p>
<p>Event用来实现进程间同步通信。</p>
<p><strong>[python]</strong> <a href="http://blog.csdn.net/moxiaomomo/article/details/11640439#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/moxiaomomo/article/details/11640439#" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li>import multiprocessing  </li>
<li>import time  </li>
<li></li>
<li>def wait_for_event(e):  </li>
<li>“””Wait for the event to be set before doing anything”””  </li>
<li>print (‘wait_for_event: starting’)  </li>
<li>e.wait()  </li>
<li>print (‘wait_for_event: e.is_set()-&gt;’ + str(e.is_set()))  </li>
<li></li>
<li>def wait_for_event_timeout(e, t):  </li>
<li>“””Wait t seconds and then timeout”””  </li>
<li>print (‘wait_for_event_timeout: starting’)  </li>
<li>e.wait(t)  </li>
<li>print (‘wait_for_event_timeout: e.is_set()-&gt;’ + str(e.is_set()))  </li>
<li></li>
<li></li>
<li>if <strong>name</strong> == ‘<strong>main</strong>‘:  </li>
<li>e = multiprocessing.Event()  </li>
<li>w1 = multiprocessing.Process(name=’block’,   </li>
<li>target=wait_for_event,  </li>
<li>args=(e,))  </li>
<li>w1.start()  </li>
<li></li>
<li>w2 = multiprocessing.Process(name=’non-block’,   </li>
<li>target=wait_for_event_timeout,   </li>
<li>args=(e, 2))  </li>
<li>w2.start()  </li>
<li></li>
<li>time.sleep(3)  </li>
<li>e.set()  </li>
<li>print (‘main: event is set’)  </li>
</ol>
<p>#the output is:  </p>
<p>#wait_for_event_timeout: starting  </p>
<p>#wait_for_event: starting  </p>
<p>#wait_for_event_timeout: e.is_set()-&gt;False  </p>
<p>#main: event is set  </p>
<p>#wait_for_event: e.is_set()-&gt;True</p>
<p> 转自：<a href="http://blog.csdn.net/moxiaomomo/article/details/11640439" target="_blank" rel="external">http://blog.csdn.net/moxiaomomo/article/details/11640439</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[线程安全及Python中的GIL]]></title>
      <url>https://shijingjing07.github.io/2016/12/20/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8F%8APython%E4%B8%AD%E7%9A%84GIL/</url>
      <content type="html"><![CDATA[<h1 id="线程安全及Python中的GIL"><a href="#线程安全及Python中的GIL" class="headerlink" title="线程安全及Python中的GIL"></a>线程安全及Python中的GIL</h1><p>本博客所有内容采用 <a href="http://creativecommons.org/about/licenses/meet-the-licenses" target="_blank" rel="external">Creative Commons<br>Licenses</a> 许可使用.<br>引用本内容时，请保留 <a href="http://sites.google.com/site/towerjoo" target="_blank" rel="external">朱涛</a>,<br><a href="http://www.cnblogs.com/mindsbook" target="_blank" rel="external">出处</a> ，并且 <strong>非商业</strong> .</p>
<p>点击 <a href="http://feed.feedsky.com/MindsbookTowerJoo" target="_blank" rel="external">订阅</a> 来订阅本博客.(推荐使用 <a href="http://reader.google.com/" target="_blank" rel="external">google<br>reader</a>, 如果你的浏览器不支持直接订阅,请直接在 <a href="http://reader.google.com/" target="_blank" rel="external">google<br>reader</a> 中手动添加).</p>
<p>抱歉,在正文中加入很多本博客的链接,主要是发现很多转载的朋友并未按照本声明来加入出处信息. 影响阅读,实在抱歉.</p>
<h1 id="摘要-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety-and"><a href="#摘要-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety-and" class="headerlink" title="[摘要](http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-"></a>[摘要](<a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-" target="_blank" rel="external">http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-</a></h1><p>GIL.html#id17)</p>
<p><a href="http://www.cnblogs.com/mindsbook" target="_blank" rel="external">作者博客链接</a>.</p>
<p>什么是线程安全? 为什么python会使用GIL的机制?</p>
<p>在多核时代的到来的背景下,基于多线程来充分利用硬件的编程方法也不断发展起来, 但是一旦 牵扯到多线程,就必然会涉及到一个概念,即 <strong>线程安全</strong>,<br>本文就主要谈下笔者对线程安全的一些理解.</p>
<p>而Python为很多人所抱怨的一点就是GIL,那么python为什么选择使用GIL, 本文也就这个问题进行一些讨论.</p>
<p>Contents</p>
<ul>
<li><a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-GIL.html#id1" target="_blank" rel="external">摘要</a></li>
<li><a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-GIL.html#id2" target="_blank" rel="external">引入</a></li>
<li><a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-GIL.html#id3" target="_blank" rel="external">线程安全</a></li>
<li><a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-GIL.html#gil" target="_blank" rel="external">GIL</a></li>
<li><a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-GIL.html#id4" target="_blank" rel="external">个人的观点</a></li>
<li><a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-GIL.html#id5" target="_blank" rel="external">参考资料</a></li>
<li><a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-GIL.html#rst" target="_blank" rel="external">本文的rst源码</a></li>
</ul>
<h1 id="引入-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety-and"><a href="#引入-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety-and" class="headerlink" title="[引入](http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-"></a>[引入](<a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-" target="_blank" rel="external">http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-</a></h1><p>GIL.html#id18)</p>
<p><a href="http://www.cnblogs.com/mindsbook" target="_blank" rel="external">作者博客链接</a>.</p>
<p>你的PC或者笔记本还是单核吗? 如果是,那你已经out了.</p>
<p>随着纳米技术的不断进步, 计算机芯片的工艺也在进步,但是已经很难在工艺上的改进来提高 运算速度而满足<br><a href="http://en.wikipedia.org/wiki/Moore_Law" target="_blank" rel="external">摩尔定理</a>, 所以intel,<br>amd相继在采用横向的扩展即增加更多的CPU, 从而双核, 4核, N核不断推出,于是我们进入了多核时代.</p>
<p>于是一个问题出现了, 多核时代的出现对于我们程序员而言意味着什么, 我们如何利用多核的优势?</p>
<p>在回答这个问题之前,建议对 <a href="http://en.wikipedia.org/wiki/Process_\(computing\" target="_blank" rel="external">进程</a>) 和<br><a href="http://en.wikipedia.org/wiki/Thread_\(computing\" target="_blank" rel="external">线程</a>) 不熟悉的读者可以先补下相关的知识.</p>
<p>当然方案是,可以采用 <strong>多进程</strong>, 也可以采用 <strong>多线程</strong>. 二者的最大区别就是, 是否共享资源, 后者是共享资源的,而前者是独立的.<br>所以你也可能想起了google chrome为什么又开始使用独立的进程 来作为每个tab服务了(不共享数据,意味着有更好的安全性).</p>
<p>相对于进程的轻型特征,多线程环境有个最大的问题就是 <strong>如何保证资源竞争,死锁, 数据修改等</strong>.</p>
<p>于是,便有了 <a href="http://en.wikipedia.org/wiki/Thread_safety" target="_blank" rel="external">线程安全</a> (thread safety)的提出.</p>
<h1 id="线程安全-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety"><a href="#线程安全-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety" class="headerlink" title="[线程安全](http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-"></a>[线程安全](<a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-" target="_blank" rel="external">http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-</a></h1><p>and-GIL.html#id19)</p>
<p><a href="http://www.cnblogs.com/mindsbook" target="_blank" rel="external">作者博客链接</a>.</p>
<pre><code>Thread safety is a computer programming concept applicable in the context of multi-threaded programs.
A piece of code is thread-safe if it functions correctly during simultaneous execution by multiple threads.
In particular, it must satisfy the need for multiple threads to access the same shared data,
and the need for a shared piece of data to be accessed by only one thread at any given time.
</code></pre><p>上面是wikipedia中的解释, 换句话说, <a href="http://en.wikipedia.org/wiki/Thread_safety" target="_blank" rel="external">线程安全</a><br>是在多线程的环境下, 线程安全能够保证多个线程同时执行时程序依旧运行正确,<br>而且要保证对于共享的数据,可以由多个线程存取,但是同一时刻只能有一个线程进行存取.</p>
<p>既然,多线程环境下必须存在资源的竞争,那么如何才能保证同一时刻只有一个线程对共享资源进行存取?</p>
<p><strong>加锁</strong>, 对, 加锁可以保证存取操作的唯一性, 从而保证同一时刻只有一个线程对共享数据存取.</p>
<p>通常加锁也有2种不同的粒度的锁:</p>
<ol>
<li>fine-grained(所谓的细粒度), 那么程序员需要自行地加,解锁来保证线程安全</li>
<li>coarse-grained(所谓的粗粒度), 那么语言层面本身维护着一个全局的锁机制,用来保证线程安全</li>
</ol>
<p>前一种方式比较典型的是<br><a href="http://en.wikipedia.org/wiki/Java_\(programming_language\" target="_blank" rel="external">java</a>),<br><a href="http://en.wikipedia.org/wiki/Jython" target="_blank" rel="external">Jython</a> 等, 后一种方式比较典型的是<br><a href="http://en.wikipedia.org/wiki/Cpython" target="_blank" rel="external">CPython</a> (即Python).</p>
<p>前一种本文不进行讨论, 具体可参考<br><a href="http://en.wikipedia.org/wiki/Java_\(programming_language\" target="_blank" rel="external">java</a>) 中的多线程编程部分.</p>
<p>至于Python中的全局锁机制,也即 <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a><br>(Global Interpreter Lock), 下面主要进行一些讨论.</p>
<h1 id="GIL-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety-and"><a href="#GIL-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety-and" class="headerlink" title="[GIL](http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-"></a>[GIL](<a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-" target="_blank" rel="external">http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-</a></h1><p>GIL.html#id20)</p>
<p><a href="http://www.cnblogs.com/mindsbook" target="_blank" rel="external">作者博客链接</a>.</p>
<p>什么是 <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a> ?<br>答案可参考wikipedia中的说明, 简单地说就是:</p>
<p><strong>每一个interpreter进程,只能同时仅有一个线程来执行, 获得相关的锁, 存取相关的资源</strong>.</p>
<p>那么很容易就会发现,如果一个interpreter进程只能有一个线程来执行, 多线程的并发则成为不可能, 即使这几个线程之间不存在资源的竞争.</p>
<p>从理论上讲,我们要尽可能地使程序更加并行, 能够充分利用多核的功能, 那么Python为什么要使用 全局的<br><a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a> 来限制这种并行呢?</p>
<p>这个问题,其实已经得到了很多的讨论, 不止十年, 可以参考下面的文档:</p>
<p>反对 <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a> 的声音:</p>
<ol>
<li><a href="http://blog.snaplogic.org/?p=94" target="_blank" rel="external">An open letter to Guido van Rossum</a> (这个文章值得一看,下面有很多的留言也值得一看)</li>
</ol>
<p>认为 <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a> 不能去除的:</p>
<ol>
<li><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=214235" target="_blank" rel="external">It isn’t Easy to Remove the GIL</a> (这个文章来自python作者 <a href="http://en.wikipedia.org/wiki/Guido_van_Rossum" target="_blank" rel="external">Guido</a>, 他说明了什么要使用 <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a>)</li>
</ol>
<p>其它的一些讨论很容易从Google来搜索得到, 譬如: <a href="http://www.google.com/search?hl=en&amp;newwindow=1&amp;q=global+interpreter+lock&amp;aq=0&amp;oq=Global+interpreter&amp;aqi=g3g-m6" target="_blank" rel="external">GIL at<br>google</a>.</p>
<p>那么,简单总结下双方的观点.</p>
<p>认为应该去除 <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a> 的:</p>
<ol>
<li>不顺应计算机的发展潮流(多核时代已经到来, 而 <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a> 会很影响多核的使用)</li>
<li>大幅度提升多线程程序的速度</li>
</ol>
<p>认为不应该去除 <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a> 的(如果去掉,会):</p>
<ol>
<li>写python的扩展(module)时会遇到锁的问题,程序员需要繁琐地加解锁来保证线程安全</li>
<li>会较大幅度地减低单线程程序的速度</li>
</ol>
<p>后者是 <a href="http://en.wikipedia.org/wiki/Guido_van_Rossum" target="_blank" rel="external">Guido</a> 最为关切的, 也是不去除<br><a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a> 最重要的原因,<br>一个简单的尝试是在1999年(十年前), 最终的结果是导致单线程的程序速度下降了几乎2倍.</p>
<p>归根结底,其实就是多进程与多线程的选择问题, 有一段话比较有意思, 可以参考<br><a href="http://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235" target="_blank" rel="external">http://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235</a>.</p>
<p>我引用如下:</p>
<pre><code>I actually don&apos;t think removing the GIL is a good solution.
But I don&apos;t think threads are a good solution, either.
They&apos;re too hard to get right, and I say that after spending literally years studying threading in both C++ and Java.
Brian Goetz has taken to saying that no one can get threading right.
</code></pre><p>引自 <a href="http://en.wikipedia.org/wiki/Bruce_Eckel" target="_blank" rel="external">Bruce Eckel</a> 对<br><a href="http://en.wikipedia.org/wiki/Guido_van_Rossum" target="_blank" rel="external">Guido</a> 的回复. 而 <a href="http://en.wikipedia.org/wiki/Bruce_Eckel" target="_blank" rel="external">Bruce<br>Eckel</a> 是何许人, 如果你了解<br><a href="http://en.wikipedia.org/wiki/Java_\(programming_language\" target="_blank" rel="external">java</a>) 或者 C++,<br>那么应该不会不知道他.</p>
<h1 id="个人的观点-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety"><a href="#个人的观点-http-www-cnblogs-com-mindsbook-archive-2009-10-15-thread-safety" class="headerlink" title="[个人的观点](http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-"></a>[个人的观点](<a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-" target="_blank" rel="external">http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-</a></h1><p>and-GIL.html#id21)</p>
<p><a href="http://www.cnblogs.com/mindsbook" target="_blank" rel="external">作者博客链接</a>.</p>
<p>那么,从我自己的角度来看(我没有太多的多线程编程经验), 先不论多线程的速度优势等,我更加喜欢多进程的是:</p>
<ol>
<li>简单,无需要人为(或者语言级别)的加解锁. 想想 <a href="http://en.wikipedia.org/wiki/Java_\(programming_language\" target="_blank" rel="external">java</a>) 中的多线程编程,程序员通常会在此处出错(java程序员可以思考下)</li>
<li>安全, 这也是浏览器为什么开始使用多进程的一个原因</li>
</ol>
<p>依照Python自身的哲学, <strong>简单</strong> 是一个很重要的原则,所以, 使用<br><a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" target="_blank" rel="external">GIL</a> 也是很好理解的.</p>
<p>当然你真的需要充分利用多核的速度优势,此时python可能并非你最佳的选择,请考虑别的语言吧,如<br><a href="http://en.wikipedia.org/wiki/Java_\(programming_language\" target="_blank" rel="external">java</a>),<br><a href="http://en.wikipedia.org/wiki/Erlang_\(programming_language\" target="_blank" rel="external">erlang</a>) 等.</p>
<p>转自：<a href="http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-
GIL.html" target="_blank" rel="external">http://www.cnblogs.com/mindsbook/archive/2009/10/15/thread-safety-and-
GIL.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python logging模块]]></title>
      <url>https://shijingjing07.github.io/2016/12/19/python%20logging%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<p>1.logging模块提供了四个组件<br>logger：日志类，有两个功能<br>1)配置日志的等级，处理器handler，过滤器filter<br>logger.setLevel(logging.INFO)<br>logger.addHandler(handler)<br>logger.addFilter(filter)<br>2)写日志<br>logger.info()</p>
<p>handler:处理器类，实际写日志的类<br>常用的处理器有StreamHandler和FileHandler<br>StreamHandler将日志输出到stream，如sys.stdout,sys.stderr<br>FileHandler将日志输出到文件<br>处理器类可以配置自己的等级，过滤器<br>一个logger可以配置多个处理器类</p>
<p>filter:过滤器类，过滤日志等级，内容<br>使用示例如下：<br>class InfoFilter(logging.Filter):<br>def filter(self,rec):<br>reurn rec.levelno==logging.INFO<br>logger.addFilter(InfoFilter())</p>
<p>formatter:内容格式化类，格式化输出的内容<br>格式化配置，使用%(&lt;dict key&gt;)s的形式，具体有哪些关键字，可以参照官网的介绍。<br>使用示例如下：<br>fmt=’%(asctime)s - %(filename)s:%(lineno)s - %(name)s - %(message)s’<br>formatter=logging.Formatter(fmt)<br>handler.setFormatter(formatter)</p>
<p>2.logger对象<br>使用logging.getLogger(name=None)函数找到一个logger对象，当name指定的logger不存在时，会自动创建一个该名称的对象，保存在logging.manage的loggerDict中。</p>
<p>3.logging日志输出流程</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161219133511603-20961325.png" alt=""></p>
<p>logger输出日志的流程：<br>1)用户代码调用打印日志函数（logging.info(),logging.debug()等）<br>2)若希望打印的日志级别不够，则流程停止。否则进入步骤3<br>3)建立一个LogRecord对象，该对象代表打印的日志<br>4)判断这条日志是否被filter过滤掉，如果被过滤，流程停止。否则进入步骤5<br>5)logger将LogRecord传递到它定义的handlers，进行处理<br>6)判断当前logger的propagate属性，为0，则流程停止，否则进入步骤7<br>7)判断当前logger有无父logger，如果没有，流程停止，否则设置当前logger为它的父logger，继续执行步骤5<br>注：logger对象是有继承关系的，如名为a.b,a.c的logger都是名为a的子logger，并且所有的logger对象都继承自root,如果子对象没有添加handler等配置，会从父对象继承，这样可以通过继承关系来复用配置。</p>
<p>handler处理日志的过程：<br>1)如果当前LogRecord的级别小于handler所设置的LogLevel,则停止流程，否则进入步骤2<br>2)判断当前LogRecord是否被handler设置的filter过滤，如果被过滤，流程停止，否则日志输出到最终目的地。</p>
<p>4.logging使用示例<br>logging有三种配置方式<br>1)代码定义logger,handler等</p>
<pre><code>#!/usr/bin/env python 
# -*- coding: utf-8 -*- 
import logging  
import logging.config

handler = logging.StreamHandler()
fmt = &apos;%(asctime)s - %(filename)s:%(lineno)s - %(name)s - %(message)s&apos;  

formatter = logging.Formatter(fmt)   # 实例化formatter  
handler.setFormatter(formatter)      # 为handler添加formatter  

logger = logging.getLogger(&apos;tst&apos;)    # 获取名为tst的logger  
logger.addHandler(handler)           # 为logger添加handler  
logger.setLevel(logging.DEBUG)  

logger.info(&apos;first info message&apos;)  
logger.debug(&apos;first debug message&apos;)  
</code></pre><p>2)logging配置文件<br>loggin.conf采用了模式匹配的方式进行配置，正则表达式是r’^[(.*)]$’，从而匹配出所有的组件。对于同一个组件具有多个实例的情况使用逗号’，’进行分隔。对于一个实例的配置采用componentName_instanceName配置块。使用这种方式还是蛮简单的。<br>logging.conf</p>
<pre><code>[loggers]
keys=root,simpleExample

[handlers]
keys=consoleHandler

[formatters]
keys=simpleFormatter

[logger_root]
level=DEBUG
handlers=consoleHandler

[logger_simpleExample]
level=DEBUG
handlers=consoleHandler
qualname=simpleExample
propagate=0

[handler_consoleHandler]
class=StreamHandler
level=DEBUG
formatter=simpleFormatter
args=(sys.stdout,)

[formatter_simpleFormatter]
format=%(asctime)s - %(name)s - %(levelname)s - %(message)s


#!/usr/bin/env python 
# -*- coding: utf-8 -*- 
import logging  
import logging.config  

logging.config.fileConfig(&apos;logging.conf&apos;)

# create logger
logger = logging.getLogger(&apos;simpleExample&apos;)

# &apos;application&apos; code
logger.debug(&apos;debug message&apos;)
logger.info(&apos;info message&apos;)
logger.warn(&apos;warn message&apos;)
logger.error(&apos;error message&apos;)
logger.critical(&apos;critical message&apos;)
</code></pre><p>3)logging配置字典</p>
<pre><code>#!/usr/bin/env python 
# -*- coding: utf-8 -*- 
import logging  
import logging.config  

LOGGING = {
    &apos;version&apos;: 1,
    &apos;disable_existing_loggers&apos;: False,
    &apos;handlers&apos;: {
        &apos;console&apos;: {
            &apos;class&apos;: &apos;logging.StreamHandler&apos;,
        },
    },
    &apos;loggers&apos;: {
        &apos;test&apos;: {
            &apos;handlers&apos;: [&apos;console&apos;],
            &apos;level&apos;: &apos;ERROR&apos;,
        },
    },
}     
logging.config.dictConfig(LOGGING)
logger = logging.getLogger(&apos;test&apos;)
logger.info(&apos;info message dict&apos;)
logger.warn(&apos;warn message dict&apos;)
logger.error(&apos;error message dict&apos;)
logger.critical(&apos;critical message dict&apos;)
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[postgresql修改最大连接数]]></title>
      <url>https://shijingjing07.github.io/2016/12/14/postgresql%E4%BF%AE%E6%94%B9%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>1.合适的最大连接数<br>used_connections/max_connections在85%左右<br>2.修改最大连接数<br>postgresql最大连接数默认为100<br>1)打开postgresql配置文件<br>vim /var/lib/pgsql/9.4/data/postgresql.conf<br>2)修改最大连接数<br>max_connections = 100<br>3)重启postgresql服务<br>在CentOS 6.x系统中<br>service postgresql-9.4 restart<br>在CentOS 7系统中<br>systemctl restart postgresql-9.4</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[socket详解]]></title>
      <url>https://shijingjing07.github.io/2016/12/02/socket%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>socket网络编程<br>1.进程间如何通信<br>本地进程间通信我们知道有以下几种方式：<br>1)消息传递(管道，FIFO，消息队列)<br>管道是一个进程的数据流到另一个进程的通道，即一个进程的数据输出作为另一个进程的数据输入，管道起到了桥梁的作用。<br>2)共享内存<br>不同进程访问同一个逻辑内存<br>3)同步<br>互斥量，条件变量，读写锁，信号量<br>4)远程过程调用<br>但是网络间的进程是如何通信的呢？如浏览器进程如何与web服务器通信，QQ聊天时，QQ进程如何与服务器或你好友所在的QQ进程通信？<br>答案是socket，网络间的进程通信几乎都是用的socket.  </p>
<p>2.如何识别网络中唯一进程<br>本地进程间可以通过PID来唯一标识一个进程<br>网络中我们根据TCP/IP协议族来标识唯一进程，网络层的”IP地址”可唯一标识网络中的主机，而传输层的”协议+端口”可唯一标识主机中的进程。”IP地址+协议+端口”就可以确定唯一进程了。<br>3.进程间如何通过socket进行通讯<br>Linux的哲学是一切皆文件，socket也是一种文件。可以使用”打开-读写-关闭”来操作。socket是应用层和运输层之间的一个抽象层。<br>socket通信流程：<br>1)服务端创建socket<br>socket()<br>2)服务端绑定端口号<br>bind()<br>3)服务端监听端口号<br>listen()<br>4)客户端创建socket<br>socket()<br>5)客户端主动打开socket,连接服务器端socket<br>connect()<br>6)服务端接收客户端请求，socket被动打开<br>同步：accept() 异步：beginaccept()<br>7)客户端socket向服务端socket写信息<br>send()<br>8)服务端socket读取信息<br>9)客户端socket关闭<br>10)服务端socket关闭  </p>
<p>4.socket建立连接的三次握手</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161202213659849-1737384138.png" alt=""></p>
<p>第一步，客户端调用connect，向服务器发送SYN J包，connect阻塞<br>第二步，服务端收到SYN J包，调用accept函数接收请求，向客户端发送 SYN K,ACK J+1<br>        accept函数阻塞<br>第三步，客户端收到服务器的SYN K,ACK J+1后，connect返回，进行SYN K确认，服务端收到ACK<br>K+1时，accept返回，三次握手完成，连接建立。</p>
<p>5.socket释放连接的四次握手</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201612/300946-20161202213749927-565791155.png" alt=""><br>第一步，客户端关闭连接，发送一个FIN M到服务端<br>第二步，服务端接收到FIN M后，执行被动关闭，对这个FIN M进行确认ACK M+1。<br>第三步，当服务端发送完毕后，再发送FIN N到客户端<br>第四步，客户端接收到FIN N调用close关闭它的socket,发送一个ACK N+1到服务端<br>服务端接收到这个ACK N+1关闭它的socket</p>
<p>6.为什么建立连接是三次握手，释放连接需要四次<br>这是因为进行释放连接的第二步时，有可能服务端仍有数据发送给客户端，因此，需要分开，先对客户端FIN报文应答，当服务端数据发送完毕后，再发送FIN报文到客户端。  </p>
<p>7.socket连接示例<br>服务器端</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;errno.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;

#define MAXLINE 4096

int main(int argc, char** argv)
{
    int    listenfd, connfd;
    struct sockaddr_in     servaddr;
    char    buff[4096];
    int     n;

    if( (listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1 ){
    printf(&quot;create socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);
    exit(0);
    }

    memset(&amp;servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    servaddr.sin_port = htons(6666);

    if( bind(listenfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) == -1){
    printf(&quot;bind socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);
    exit(0);
    }

    if( listen(listenfd, 10) == -1){
    printf(&quot;listen socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);
    exit(0);
    }

    printf(&quot;======waiting for client&apos;s request======\n&quot;);
    while(1){
    if( (connfd = accept(listenfd, (struct sockaddr*)NULL, NULL)) == -1){
        printf(&quot;accept socket error: %s(errno: %d)&quot;,strerror(errno),errno);
        continue;
    }
    n = recv(connfd, buff, MAXLINE, 0);
    buff[n] = &apos;\0&apos;;
    printf(&quot;recv msg from client: %s\n&quot;, buff);
    close(connfd);
    }

    close(listenfd);
}
</code></pre><p>客户端</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;errno.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;

#define MAXLINE 4096

int main(int argc, char** argv)
{
    int    sockfd, n;
    char    recvline[4096], sendline[4096];
    struct sockaddr_in    servaddr;

    if( argc != 2){
    printf(&quot;usage: ./client &lt;ipaddress&gt;\n&quot;);
    exit(0);
    }

    if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0){
    printf(&quot;create socket error: %s(errno: %d)\n&quot;, strerror(errno),errno);
    exit(0);
    }

    memset(&amp;servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(6666);
    if( inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;= 0){
    printf(&quot;inet_pton error for %s\n&quot;,argv[1]);
    exit(0);
    }

    if( connect(sockfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) &lt; 0){
    printf(&quot;connect error: %s(errno: %d)\n&quot;,strerror(errno),errno);
    exit(0);
    }

    printf(&quot;send msg to server: \n&quot;);
    fgets(sendline, 4096, stdin);
    if( send(sockfd, sendline, strlen(sendline), 0) &lt; 0)
    {
    printf(&quot;send msg error: %s(errno: %d)\n&quot;, strerror(errno), errno);
    exit(0);
    }

    close(sockfd);
    exit(0);
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[重放攻击（Replay Attacks）]]></title>
      <url>https://shijingjing07.github.io/2016/12/01/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB%EF%BC%88Replay%20Attacks%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>重放攻击（Replay Attacks）<br>1.什么是重放攻击<br>顾名思义，重复的会话请求就是重放攻击。<br>可能是因为用户重复发起请求，也可能是因为请求被攻击者获取，然后重新发给服务器。  </p>
<p>2.重放攻击的危害<br>请求被攻击者获取，并重新发送给认证服务器，从而达到认证通过的目的。<br>我们可以通过加密，签名的方式防止信息泄露，会话被劫持修改。但这种方式防止不了重放攻击。  </p>
<p>3.重放攻击的防御<br>1)时间戳验证<br>请求时加上客户端当前时间戳，同时签名（签名是为了防止会话被劫持，时间戳被修改），服务端对请求时间戳进行判断，如超过5分钟，认定为重放攻击，请求无效。<br>时间戳无法完全防止重放攻击。  </p>
<p>2)序号<br>顾名思义，在客户端和服务端通讯时，先定义一个初始序号，每次递增。这样，服务端就可以知道是否是重复发送的请求。  </p>
<p>3)挑战与应答的方式<br>我们一般采用这种方式来防御重放攻击。<br>客户端请求服务器时，服务器会首先生成一个随机数，然后返回给客户端，客户端带上这个随机数，访问服务器，服务器比对客户端的这个参数，若相同，说明正确，不是重放攻击。<br>这种方式下，客户端每次请求时，服务端都会先生成一个挑战码，客户端带上应答码访问，服务端进行比对，若挑战码和应答码不对应，视为重放攻击。  </p>
<p>4)Https防重放攻击<br>对于https，每个socket连接都会验证证书，交换密钥。攻击者截获请求，重新发送，因为socket不同，密钥也不同，后台解密后是一堆乱码，所以https本身就是防止重放攻击的，除非能复制socket，或者进行中间人攻击。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[IO-同步，异步，阻塞，非阻塞]]></title>
      <url>https://shijingjing07.github.io/2016/11/28/IO-%E5%90%8C%E6%AD%A5%EF%BC%8C%E5%BC%82%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%EF%BC%8C%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
      <content type="html"><![CDATA[<p>IO-同步，异步，阻塞，非阻塞<br>1.什么是IO<br>数据在系统内核(kernel)和用户进程之间的传递，称为IO。</p>
<p>2.IO操作步骤<br>以read为例，涉及两个系统对象，调用IO的process(or thread)，即用户进程；另一个为系统内核(kernel)。<br>当用户进程调用recvfrom操作时，会经历两个阶段<br>1)等待数据准备<br>2)将数据从内核拷贝至进程中</p>
<p>3.IO模型<br>根据用户进程在IO操作时的状态，可以分为5中IO类型：<br>blocking IO:阻塞IO<br>non-blocking IO：非阻塞IO<br>IO multiplexing：多Socket连接IO<br>signal driven IO：信号驱动IO<br>asynchronous IO：异步IO</p>
<p>signal driven IO实际中很少使用，在此不做介绍。</p>
<p>2.blocking IO:阻塞IO<br>当用户进程调用recvfrom时，首先开始IO第一阶段：kernel准备数据。<br>用户进程会被阻塞。当kernel数据准备好以后，会将数据从kernel拷贝到用户内存，然后kernel返回结果，用户进程才会解除block的状态，重新运行起来。<br>blocking IO在IO执行的两个阶段都被block了。</p>
<p>3.non-blocking IO:非阻塞IO<br>可以设置socket使其变为non-blocking。<br>当对一个non-blocking socket执行recvfrom操作时，流程如下：<br>用户进程调用recvfrom,如果kernel数据还没有准备好，此时用户进程不会被block。而是立刻返回一个error，从用户进程角度看，它并没有等待，而是立刻得到了一个结果。<br>用户进程判断是一个error时，它就知道数据还没有准备好，于是再次发送read操作。<br>一旦kernel中的数据准备好，并且再次收到了用户进程的system call,那么它马上将数据拷贝到用户内存，然后kernel返回结果。<br>non-blocking<br>IO在数据准备阶段，没有被block，而是不断的轮询kernel数据是否准备好；在数据拷贝阶段，用户进程被block，直到kernel拷贝结束，返回结果，用户进程才会解除block的状态。</p>
<p>4.IO multiplexing：多Socket连接IO<br>IO<br>multiplexing的特点是单个用户进程可以同时处理多个网络连接IO，它的原理是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。<br>当用户进程调用select时，整个进程会被block，当任何一个socket中的数据准备好了，select就会返回。这时用户进程再调用read操作，将数据从kernel拷贝到用户进程。我们可以看出，IO<br>multiplexing和blocking IO的流程类似，不同的是，IO multiplexing需要两个system<br>call(select和recvfrom)，而blocking IO只调用了一个system<br>call(recvfrom)。select的优势在于它可以同时处理多个socket连接。所以如果连接数不高的话，使用select/epoll的web<br>server不一定比multi-threading+blocking IO的web<br>server性能更好，select/epoll的优势在于能够处理更多的连接。<br>IO multiplexing中，每一个socket一般设置为non-blocking的，但是用户进程一直是被select函数block的。</p>
<p>5.asynchronous IO<br>用户进程发起read操作后，立刻返回可以去做其他的事情了。<br>此时，从kernel角度看，当它收到一个asynchronous<br>read后，首先他立刻返回，所以不会对用户进程产生任何block，然后,kernel等待数据准备完成，然后将数据拷贝到用户内存，当这一切完成之后，kernel会给用户进程发送一个signal告诉用户进程read操作完成了。</p>
<p>6.四种IO模型的区别<br>blocking和non-blocking,synchronous IO和asynchronous IO的区别。<br>blocking和non-blocking的区别很明显，blocking会一致阻塞，non-blocking在数据没准备完全时会立刻返回。<br>synchronous同步IO指的是在IO操作时会阻塞用户进程；asynchronous含义相反。<br>可以看出blocking，non-blocking，IO multiplexing都是synchronous<br>IO；而asynchronous不会对用户进程产生任何阻塞。</p>
<p>7.网上有一个比较形象的例子来说明这四种IO Model<br>有A，B，C，D四个人在钓鱼：<br>A用的是最老式的鱼竿，所以呢，得一直守着，等到鱼上钩了再拉杆；<br>B的鱼竿有个功能，能够显示是否有鱼上钩，所以呢，B就和旁边的MM聊天，隔会再看看有没有鱼上钩，有的话就迅速拉杆；<br>C用的鱼竿和B差不多，但他想了一个好办法，就是同时放好几根鱼竿，然后守在旁边，一旦有显示说鱼上钩了，它就将对应的鱼竿拉起来；<br>D是个有钱人，干脆雇了一个人帮他钓鱼，一旦那个人把鱼钓上来了，就给D发个短信。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vue.js使用详解]]></title>
      <url>https://shijingjing07.github.io/2016/11/19/vue.js%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>1.什么是vue.js<br>vue.js是一款数据驱动型的js框架。何为数据驱动型？html视图层定义模板，vue定义数据。html和vue数据，通过标签id关联。</p>
<p>2.vue.js引入<br>&lt;script src=”<a href="https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&amp;gt" target="_blank" rel="external">https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&amp;gt</a>;</p>
<p>3.使用示例<br>1)声明式渲染</p>
<pre><code>&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;app&quot;&gt;
{{message}}
&lt;/div&gt;

var app=new Vue({
    el:&apos;#app&apos;,
    data:{
        message:&apos;Hello Vue!&apos;
    }
})
</code></pre><p>运行结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201611/300946-20161119174130482-998803872.png" alt=""></p>
<p>2)条件判断</p>
<pre><code>&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;app-3&quot;&gt;
  &lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;
&lt;/div&gt;

var app3 = new Vue({
  el: &apos;#app-3&apos;,
  data: {
    seen: true
  }
})
</code></pre><p>运行结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201611/300946-20161119174215842-1944546714.png" alt=""></p>
<p>3)循环</p>
<pre><code>&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;app-4&quot;&gt;
    &lt;ol&gt;
        &lt;li v-for=&quot;todo in todos&quot;&gt;
            {{ todo.text }}
        &lt;/li&gt;
    &lt;/ol&gt;
&lt;/div&gt;

var app4 = new Vue({
    el: &apos;#app-4&apos;,
    data: {
        todos: [
          { text: &apos;Learn JavaScript&apos; },
          { text: &apos;Learn Vue&apos; },
          { text: &apos;Build something awesome&apos; }
        ]
    }
})
</code></pre><p>运行结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201611/300946-20161119174251670-2022701270.png" alt=""></p>
<p>4)客户端交互</p>
<p>vue.js和浏览器可实现双向通信，即浏览器中绑定值改变后，js中会同时改变，反之亦然。</p>
<pre><code>&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;app-5&quot;&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  &lt;button v-on:click=&quot;reverseMessage&quot;&gt;Reverse Message&lt;/button&gt;
&lt;/div&gt;

var app5 = new Vue({
  el: &apos;#app-5&apos;,
  data: {
    message: &apos;Hello Vue.js!&apos;
  },
  methods: {
    reverseMessage: function () {
      this.message = this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)
    }
  }
})
</code></pre><p>运行结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201611/300946-20161119174331310-1906400836.png" alt=""></p>
<p>4.组件<br>组件可以理解为在js中定义了一个html模板和一个vue.js，前台html可以直接使用这个模板，同时会被vue.js渲染。<br>需要注意的是，组件必须要有vue.js数据渲染才能显示。<br>如下例所示：</p>
<pre><code>&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;app-7&quot;&gt;
  &lt;ol&gt;
    &lt;todo-item v-for=&quot;item in groceryList&quot; v-bind:todo=&quot;item&quot;&gt;&lt;/todo-item&gt;
  &lt;/ol&gt;
&lt;/div&gt;

Vue.component(&apos;todo-item&apos;, {
  props: [&apos;todo&apos;],
  template: &apos;&lt;li&gt;{{ todo.text }}&lt;/li&gt;&apos;
})
var app7 = new Vue({
  el: &apos;#app-7&apos;,
  data: {
    groceryList: [
      { text: &apos;Vegetables&apos; },
      { text: &apos;Cheese&apos; },
      { text: &apos;Whatever else humans are supposed to eat&apos; }
    ]
  }
})
</code></pre><p>运行结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201611/300946-20161119174405810-1399612477.png" alt=""></p>
<p>我们在模板中增加了一个”props”字段，来接收数据，在html页面中将这个字段绑定到vue.js中的数据。<br>完成数据绑定。</p>
<p>5.使用场景</p>
<p>个人觉得适合数据量大，前端html页面模块重复复杂的情况。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python 类中staticmethod,classmethod,普通方法]]></title>
      <url>https://shijingjing07.github.io/2016/11/19/python%20%E7%B1%BB%E4%B8%ADstaticmethod,classmethod,%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>1.staticmethod:静态方法<br>和全局函数类似，但是通过类和对象调用。</p>
<p>2.classmethod:类方法<br>和类相关的方法，第一个参数是class对象（不是实例对象）。<br>在python中class也是一个真实存在于内存中的对象，不同于其他语言只存在于编译期间。</p>
<p>3.普通方法<br>和实例相关的方法，通过类实例调用。</p>
<p>4.代码示例</p>
<pre><code>#coding:utf-8
&apos;&apos;&apos;
Created on 2015年5月29日
@author: canx
&apos;&apos;&apos;

class Person:
    def __init__(self):
        print &quot;init&quot;

    @staticmethod
    def sayHello(hello):
        print &quot;sayHell %s&quot;%(hello)

    @classmethod
    def introduce(cls,hello):
        print &quot;introduce %s&quot;%(hello)

    def hello(self,hello):
        print &quot;hello %s&quot;%(hello)

def main():
    Person.sayHello(&quot;test&quot;)
    Person.introduce(&quot;test&quot;)
    p=Person()
    p.hello(&quot;test&quot;)

if __name__==&apos;__main__&apos;:
    main()
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201611/300946-20161119102339467-2036845135.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[cookie,session,sessionid]]></title>
      <url>https://shijingjing07.github.io/2016/11/07/cookie,session,sessionid/</url>
      <content type="html"><![CDATA[<p>cookie,session,sessionid</p>
<p>http协议是无状态的，意思是每次请求的状态不会保存。因此，产生了cookie,session之类保存会话状态的机制。<br>1.什么是cookie<br>cookie将信息存储在客户端浏览器中。<br>cookie的内容主要包括：key,value,expire_time,path(路径),domain(域)<br>浏览器发送请求是会查找对应的path,domain，把符合的cookie自动发送给服务器。</p>
<p>2.什么是session<br>session在服务器端生成，然后会将对应的sessionid在浏览器端使用cookie保存起来。<br>因此会话状态可以在session中保存。<br>cookie可以被人为禁止，可以使用url重写，将session id附在URL路径的后面。还可以使用表单隐藏字段。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[supervisor使用详解]]></title>
      <url>https://shijingjing07.github.io/2016/11/02/supervisor%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>1.什么是supervisor<br>supervisor是用python写的一个进程管理工具，用来启动，重启，关闭进程。</p>
<p>2.supervisor的安装</p>
<pre><code>pip install supervisor
</code></pre><p>3.supervisor的配置文件<br>supervisor安装完毕后，会有一个配置文件supervisord.conf<br>运行</p>
<pre><code>echo_supervisord_conf
</code></pre><p>命令，可输出文件详细<br>我们使用重定向运算符将配置文件定向到/etc路径下（方便管理）</p>
<pre><code>echo_supervisord_conf&gt;/etc/supervisord.conf
</code></pre><p>4.配置文件详解</p>
<pre><code>[unix_http_server]
file=/tmp/supervisor.sock ; UNIX socket 文件，supervisorctl 会使用
;chmod=0700 ; socket 文件的 mode，默认是 0700
;chown=nobody:nogroup ; socket 文件的 owner，格式： uid:gid

;[inet_http_server] ; HTTP 服务器，提供 web 管理界面
;port=127.0.0.1:9001 ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性
;username=user ; 登录管理后台的用户名
;password=123 ; 登录管理后台的密码

[supervisord]
logfile=/tmp/supervisord.log ; 日志文件，默认是 $CWD/supervisord.log
logfile_maxbytes=50MB ; 日志文件大小，超出会 rotate，默认 50MB
logfile_backups=10 ; 日志文件保留备份数量默认 10
loglevel=info ; 日志级别，默认 info，其它: debug,warn,trace
pidfile=/tmp/supervisord.pid ; pid 文件
nodaemon=false ; 是否在前台启动，默认是 false，即以 daemon 的方式启动
minfds=1024 ; 可以打开的文件描述符的最小值，默认 1024
minprocs=200 ; 可以打开的进程数的最小值，默认 200

; the below section must remain in the config file for RPC
; (supervisorctl/web interface) to work, additional interfaces may be
; added by defining them in separate rpcinterface: sections
[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

[supervisorctl]
serverurl=unix:///tmp/supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致
;serverurl=http://127.0.0.1:9001 ; 通过 HTTP 的方式连接 supervisord

; 包含其他的配置文件
[include]
files = relative/directory/*.ini ; 可以是 *.conf 或 *.ini
</code></pre><p>5.进程Program配置</p>
<pre><code>[program:usercenter]
directory = /home/leon/projects/usercenter ; 程序的启动目录
command = gunicorn -c gunicorn.py wsgi:app ; 启动命令，可以看出与手动在命令行启动的命令是一样的
autostart = true ; 在 supervisord 启动的时候也自动启动
startsecs = 5 ; 启动 5 秒后没有异常退出，就当作已经正常启动了
autorestart = true ; 程序异常退出后自动重启
startretries = 3 ; 启动失败自动重试次数，默认是 3
user = leon ; 用哪个用户启动
redirect_stderr = true ; 把 stderr 重定向到 stdout，默认 false
stdout_logfile_maxbytes = 20MB ; stdout 日志文件大小，默认 50MB
stdout_logfile_backups = 20 ; stdout 日志文件备份数
; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）
stdout_logfile = /data/logs/usercenter_stdout.log

; 可以通过 environment 来添加需要的环境变量，一种常见的用法是修改 PYTHONPATH
; environment=PYTHONPATH=$PYTHONPATH:/path/to/somewhere
</code></pre><p>将进程配置添加到supervisord.conf文件中<br>推荐将各个进程配置放到单独的文件中，然后通过[include]配置项引用</p>
<pre><code>[include]
files = /etc/supervisor/*.conf
</code></pre><p>6.supervisor服务启动<br>运行命令</p>
<pre><code>supervisord -c /etc/supervisord.conf
</code></pre><p>启动服务<br>若服务已启动会报以下错误：<br><img src="http://images2015.cnblogs.com/blog/300946/201611/300946-20161102190531861-1862207493.png" alt=""><br>查找服务进程，kill，重新运行<br><img src="http://images2015.cnblogs.com/blog/300946/201611/300946-20161102190540190-1592905441.png" alt=""></p>
<p>7.supervisor服务客户端管理<br>可以使用supervisord的命令行客户端管理工具supervisorctl，来管理进程。</p>
<pre><code>$ supervisorctl status
$ supervisorctl stop usercenter
$ supervisorctl start usercenter
$ supervisorctl restart usercenter
$ supervisorctl reread
$ supervisorctl update
</code></pre><p>8.supervisor web管理界面</p>
<pre><code>;[inet_http_server] ; HTTP 服务器，提供 web 管理界面
;port=127.0.0.1:9001 ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性
;username=user ; 登录管理后台的用户名
;password=123 ; 登录管理后台的密码
</code></pre><p>在浏览器中输入<a href="http://127.0.0.1:9001，可进入web管理界面" target="_blank" rel="external">http://127.0.0.1:9001，可进入web管理界面</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python unicode字节串转成中文问题]]></title>
      <url>https://shijingjing07.github.io/2016/11/01/python%20unicode%E5%AD%97%E8%8A%82%E4%B8%B2%E8%BD%AC%E6%88%90%E4%B8%AD%E6%96%87%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>如题，其实我的问题很简单，就是在写爬虫的时候拿到网页的信息包含类似”\u65b0\u6d6a\u5fae\u535a\u6ce8\u518c”的字符串，实际上这是unicode的中文编码，对应的中文为”新浪微博注册”。其实我就是想找一个函数让这一串东西显示中文而已，没想到百度了白天找到合适的。遇到这种问题千万不要用什么<br>“python编码” “unicode中文编码” “unicode解码”这样的关键字去搜，一大堆网页出来毫不相关。<br>其实这个问题一个函数搞定，如下：<br>Example 1:<br>&gt;&gt;&gt; s = r”\u65b0\u6d6a\u5fae\u535a\u6ce8\u518c”<br>&gt;&gt;&gt; s<br>‘\\u65b0\\u6d6a\\u5fae\\u535a\\u6ce8\\u518c’<br>&gt;&gt;&gt; print s<br>\u65b0\u6d6a\u5fae\u535a\u6ce8\u518c<br>&gt;&gt;&gt; s = s.decode(“unicode_escape”); #就是这个函数<br>&gt;&gt;&gt; print s<br>新浪微博注册</p>
<p>Example 2:<br>&gt;&gt;&gt; str<em> = “Russopho\xe9bic, clichd and just pl\xe9ain stupid.”<br>&gt;&gt;&gt; print str</em><br>Russopho?bic, clichd and just pl?ain stupid.<br>&gt;&gt;&gt; str<em> = str</em>.decode(“unicode<em>escape”)<br>&gt;&gt;&gt; print str</em><br>Russophoebic, clichd and just pleain stupid.<br>(这个方法解决了我在插入数据到mongodb时遇到的”bson.errors.InvalidStringData: strings in documents<br>must be valid UTF-8”问题)</p>
<p>附上关于这个问题的相关博客链接：<a href="http://www.cnblogs.com/yangze/archive/2010/11/16/1878469.html" target="_blank" rel="external">http://www.cnblogs.com/yangze/archive/2010/11/16/1878469.html</a></p>
<p>另外还有一个与unicode字节串有关的问题，遇到这样的错误提示：Unicode equal comparison failed to convert<br>both arguments to Unicode - interpreting them as being<br>unequal。说明我们在对两个字符（串）进行对比的时候等号两边的类型<br>不一样，可能是一边是unicode字节串，一边是字符串。详见<a href="http://stackoverflow.com/questions/3400171" target="_blank" rel="external">http://stackoverflow.com/questions/3400171</a><br>/python-utf-8-comparison。  </p>
<p>小结：<br>以后遇到奇葩问题要想好关键字再搜，不然很有可能一无所获。</p>
<p>转自：<a href="http://windkeepblow.blog.163.com/blog/static/1914883312013988185783/" target="_blank" rel="external">http://windkeepblow.blog.163.com/blog/static/1914883312013988185783/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[对称加密和非对称加密]]></title>
      <url>https://shijingjing07.github.io/2016/10/27/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</url>
      <content type="html"><![CDATA[<p>1.什么是对称加密,非对称加密<br>对称加密是指加解密使用的是同样的密钥<br>非对称加密是指加解密使用的密钥不同。</p>
<p>2.对称加密的优缺点<br>对称加密的特点是简单快速。<br>密钥越大，加密越强，但加解密过程越慢。<br>密钥容易被黑客拦截</p>
<p>3.非对称加密的优缺点<br>非对称加密使用了一对密钥，公钥和私钥。私钥由解密方安全保管，公钥可以发给任何请求它的人。数据使用公钥加密，私钥解密。因为私钥不通过网络发送出去，所以非对称加密的安全性很高。<br>非对称加密很安全，但和对称加密比起来，非常慢。</p>
<p>4.对称密钥使用非对称方式发送<br>对称密钥使用非对称方式发送，解决了对称密钥易被获取，和非对称密钥加解密慢的问题。<br>使用步骤如下：<br>1)A生成一个随机数作为对称密钥<br>2)A向B申请公钥<br>3)B将公钥发给A<br>4)A使用公钥加密对称密钥，将加密后的结果发给B<br>5)B使用私钥解密出对称密钥<br>6)A和B可以通过对称密钥对信息加解密了</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[公钥与私钥，HTTPS详解]]></title>
      <url>https://shijingjing07.github.io/2016/10/15/%E5%85%AC%E9%92%A5%E4%B8%8E%E7%A7%81%E9%92%A5%EF%BC%8CHTTPS%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>1.公钥与私钥原理<br>1)鲍勃有两把钥匙，一把是公钥，另一把是私钥<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161016005356828-1950036474.png" alt=""><br>2)鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161016005403984-463869082.png" alt=""><br>3)苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161016005412500-863295437.png" alt=""><br>4)鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161016005419500-1822328322.png" alt=""><br>5)鲍勃给苏珊回信，决定采用”数字签名”。他写完后先用Hash函数，生成信件的摘要（digest）。<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161016005515359-1934644907.png" alt=""></p>
<p>6)然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161016005524484-949087182.png" alt=""></p>
<p>7)鲍勃将这个签名，附在信件下面，一起发给苏珊。<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161016005532796-1863329312.png" alt=""></p>
<p>8)苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161016005603921-819577677.png" alt=""></p>
<p>9)苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161016005612421-407782857.png" alt=""></p>
<p>10)复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成”数字签名”，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161016005620921-1494099994.png" alt=""></p>
<p>11)后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate<br>authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital<br>Certificate）。<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161016005629812-1464508028.png" alt=""></p>
<p>12)鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161016005638625-1123889882.png" alt=""></p>
<p>13)苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161016005649046-1806234010.png" alt=""></p>
<p>2.HTTPS详解<br>HTTP协议的网站容易被篡改和劫持，如一些不良的运营商会通过代理服务器在你的页面中植入广告等。<br>因此很多网站选择使用HTTPS协议。HTTPS协议通过TLS层和证书机制提供了内容加密，身份认证，数据完整性三大功能。</p>
<p>1)下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161016005657562-174775354.png" alt=""></p>
<p>2)首先，客户端向服务器发出加密请求。<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161016005715031-1269092932.png" alt=""></p>
<p>3)服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161016005722375-1161331441.png" alt=""></p>
<p>4)客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161016005734640-106282859.png" alt=""></p>
<p>5)如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161016005743453-2106220000.png" alt=""></p>
<p>6)如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161016005800859-1519540213.png" alt=""></p>
<p>原文网址：<a href="http://www.youdzone.com/signature.html" target="_blank" rel="external">http://www.youdzone.com/signature.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[持续集成详解]]></title>
      <url>https://shijingjing07.github.io/2016/10/15/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>持续集成</p>
<p>1.什么是持续集成<br>针对系统的开发和发布，形成的一套标准流程。<br>持续集成指的是，频繁地（一天多次）将代码集成到主干<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161015220148390-1415314161.png" alt=""></p>
<p>2.持续集成的流程<br>1)开发者向代码仓库提交代码<br>本地代码commit到代码仓库<br>2)代码仓库对提交的代码进行测试<br>代码仓库对commit操作配置了钩子(hook)，只要提交代码或者合并进主干，就会跑自动化测试。<br>测试的种类如下：<br>单元测试：测试函数或模块功能<br>集成测试：针对整个产品的某个功能的测试，又称功能测试<br>端对端测试：从用户界面直达数据库的全链路测试<br>3)持续交付<br>通过上步测试后，代码就可以合并进主干了，此时称作可交付。<br>4)构建<br>构建指的是，交付后的源代码转为运行的实际代码，比如安装依赖，配置各种资源（样式表，js脚本，图片）等等。<br>5)测试<br>构建完毕后，会进入测试。以自动化测试为主，无法自动化的测试用例，需要人工跑。<br>6)部署到生产服务器<br>通过上步测试后，当前代码就是一个可以直接部署的版本。将这个版本的所有文件打包存档，发到生产服务器上。<br>生产服务器解包文件，再将运行路径符号链接指向文件目录，然后重新启动应用。<br>部署工具有Ansible,Chef,Puppet等。<br>7)回滚<br>若当前版本有问题，需要回滚上一个版本的构建结果。最简单的做法就是修改运行路径符号链接，指向上次构建的目录。</p>
<p>3.持续集成的优点<br>1)快速发现发错<br>每完成一点更新，就集成到主干，可快速发现和定位错误<br>2)防止分支大幅偏离主干<br>主干不断更新，会导致分支集成难度变大或难以集成。</p>
<p>4.持续集成的目的<br>让产品可以快速迭代，同时还能保持高质量。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python datetime]]></title>
      <url>https://shijingjing07.github.io/2016/10/14/python%20datetime/</url>
      <content type="html"><![CDATA[<p>不管何时何地，只要我们编程时遇到了跟时间有关的问题，都要想到 datetime 和 time<br>标准库模块，今天我们就用它内部的方法，详解python操作日期和时间的方法。<br><strong>1.将字符串的时间转换为时间戳  
</strong></p>
<p>复制代码代码如下:</p>
<p>方法:<br>a = “2013-10-10 23:40:00”  </p>
<p>#将其转换为时间数组<br>import time<br>timeArray = time.strptime(a, “%Y-%m-%d %H:%M:%S”)  </p>
<p>#转换为时间戳:<br>timeStamp = int(time.mktime(timeArray))<br>timeStamp == 1381419600</p>
<p><strong>2.格式更改</strong><br>如a = “2013-10-10 23:40:00”,想改为 a = “2013/10/10 23:40:00”<br>方法:先转换为时间数组,然后转换为其他格式</p>
<p>复制代码代码如下:</p>
<p>timeArray = time.strptime(a, “%Y-%m-%d %H:%M:%S”)<br>otherStyleTime = time.strftime(“%Y/%m/%d %H:%M:%S”, timeArray)</p>
<p><strong>3.时间戳转换为指定格式日期</strong><br>方法一:利用localtime()转换为时间数组,然后格式化为需要的格式,如：</p>
<p>复制代码代码如下:</p>
<p>timeStamp = 1381419600<br>timeArray = time.localtime(timeStamp)<br>otherStyleTime = time.strftime(“%Y-%m-%d %H:%M:%S”, timeArray)<br>otherStyletime == “2013-10-10 23:40:00”</p>
<p>方法二:</p>
<p>复制代码代码如下:</p>
<p>import datetime<br>timeStamp = 1381419600<br>dateArray = datetime.datetime.utcfromtimestamp(timeStamp)<br>otherStyleTime = dateArray.strftime(“%Y-%m-%d %H:%M:%S”)<br>otherStyletime == “2013-10-10 23:40:00”</p>
<p><strong>4.获取当前时间并转换为指定日期格式  
</strong>方法一:</p>
<p>复制代码代码如下:</p>
<p>import time  </p>
<p>#获得当前时间时间戳<br>now = int(time.time())  -&gt;这是时间戳  </p>
<p>#转换为其他日期格式,如:”%Y-%m-%d %H:%M:%S”<br>timeArray = time.localtime(timeStamp)<br>otherStyleTime = time.strftime(“%Y-%m-%d %H:%M:%S”, timeArray)</p>
<p>方法二:</p>
<p>复制代码代码如下:</p>
<p>import datetime  </p>
<p>#获得当前时间<br>now = datetime.datetime.now()  -&gt;这是时间数组格式  </p>
<p>#转换为指定的格式:<br>otherStyleTime = now.strftime(“%Y-%m-%d %H:%M:%S”)</p>
<p><strong>5.获得三天前的时间的方法</strong></p>
<p>复制代码代码如下:</p>
<p>import time<br>import datetime  </p>
<p>#先获得时间数组格式的日期<br>threeDayAgo = (datetime.datetime.now() - datetime.timedelta(days = 3))  </p>
<p>#转换为时间戳:<br>timeStamp = int(time.mktime(threeDayAgo.timetuple()))  </p>
<p>#转换为其他字符串格式:<br>otherStyleTime = threeDayAgo.strftime(“%Y-%m-%d %H:%M:%S”)<br>注:timedelta()的参数有:days,hours,seconds,microseconds</p>
<p><strong>6.给定时间戳,计算该时间的几天前时间</strong></p>
<p>复制代码代码如下:</p>
<p>timeStamp = 1381419600  </p>
<p>#先转换为datetime<br>import datetime<br>import time<br>dateArray = datetime.datetime.utcfromtimestamp(timeStamp)<br>threeDayAgo = dateArray - datetime.timedelta(days = 3)  </p>
<p>#参考5,可以转换为其他的任意格式了</p>
<p><strong>7、用Python计算昨天和明天的日期</strong></p>
<p>复制代码代码如下:</p>
<p>&gt;&gt;&gt; import datetime #导入日期时间模块<br>&gt;&gt;&gt; today = datetime.date.today() #获得今天的日期<br>&gt;&gt;&gt; print today #输出今天日期<br>2014-01-04<br>&gt;&gt;&gt; yesterday = today - datetime.timedelta(days=1)</p>
<p>#用今天日期减掉时间差，参数为1天，获得昨天的日期<br>&gt;&gt;&gt; print yesterday<br>2014-01-03<br>&gt;&gt;&gt; tomorrow = today + datetime.timedelta(days=1)</p>
<p>#用今天日期加上时间差，参数为1天，获得明天的日期<br>&gt;&gt;&gt; print tomorrow<br>2014-01-05<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; print “昨天:%s， 今天:%s， 明天：%s” % (yesterday, today, tomorrow)</p>
<p>#字符串拼接在一起输出，这3天的日期</p>
<p>昨天:2014-01-03， 今天:2014-01-04， 明天：2014-01-05<br><strong>8、python里使用time模块来获取当前的时间</strong></p>
<p>复制代码代码如下:</p>
<p>#!/usr/bin/python<br>import time<br>print (time.strftime(“%H:%M:%S”))  </p>
<h2 id="12-hour-format"><a href="#12-hour-format" class="headerlink" title="12 hour format"></a>12 hour format</h2><p>print (time.strftime(“%I:%M:%S”))  </p>
<p>#：输出  </p>
<p>#18:11:30  </p>
<p>#6：11:30</p>
<p><strong>9、打印出当前的日期的python程序  
</strong></p>
<p>复制代码代码如下:</p>
<p>!/usr/bin/python</p>
<p>import time  </p>
<h2 id="dd-mm-yyyy格式"><a href="#dd-mm-yyyy格式" class="headerlink" title="dd/mm/yyyy格式"></a>dd/mm/yyyy格式</h2><p>print (time.strftime(“%d/%m/%Y”))</p>
<p>#输出：<br>11/03/2014</p>
<p><strong>10、使用datetime模块来获取当前的日期和时间  
</strong></p>
<p>复制代码代码如下:</p>
<p>#!/usr/bin/python<br>import datetime<br>i = datetime.datetime.now()<br>print (“当前的日期和时间是 %s” % i)<br>print (“ISO格式的日期和时间是 %s” % i.isoformat() )<br>print (“当前的年份是 %s” %i.year)<br>print (“当前的月份是 %s” %i.month)<br>print (“当前的日期是  %s” %i.day)<br>print (“dd/mm/yyyy 格式是  %s/%s/%s” % (i.day, i.month, i.year) )<br>print (“当前小时是 %s” %i.hour)<br>print (“当前分钟是 %s” %i.minute)<br>print (“当前秒是  %s” %i.second)</p>
<p><strong>附：日期和时间的格式化参数</strong></p>
<p>复制代码代码如下:</p>
<p>%a 星期几的简写<br>%A 星期几的全称<br>%b 月分的简写<br>%B 月份的全称<br>%c 标准的日期的时间串<br>%C 年份的后两位数字<br>%d 十进制表示的每月的第几天<br>%D 月/天/年<br>%e 在两字符域中，十进制表示的每月的第几天<br>%F 年-月-日<br>%g 年份的后两位数字，使用基于周的年<br>%G 年分，使用基于周的年<br>%h 简写的月份名<br>%H 24小时制的小时<br>%I 12小时制的小时<br>%j 十进制表示的每年的第几天<br>%m 十进制表示的月份<br>%M 十时制表示的分钟数<br>%n 新行符<br>%p 本地的AM或PM的等价显示<br>%r 12小时的时间<br>%R 显示小时和分钟：hh:mm<br>%S 十进制的秒数<br>%t 水平制表符<br>%T 显示时分秒：hh:mm:ss<br>%u 每周的第几天，星期一为第一天 （值从0到6，星期一为0）<br>%U 第年的第几周，把星期日做为第一天（值从0到53）<br>%V 每年的第几周，使用基于周的年<br>%w 十进制表示的星期几（值从0到6，星期天为0）<br>%W 每年的第几周，把星期一做为第一天（值从0到53）<br>%x 标准的日期串<br>%X 标准的时间串<br>%y 不带世纪的十进制年份（值从0到99）<br>%Y 带世纪部分的十制年份<br>%z，%Z 时区名称，如果不能得到时区名称则返回空字符。<br>%% 百分号</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JSONP详解]]></title>
      <url>https://shijingjing07.github.io/2016/10/03/JSONP%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>1.什么是ajax跨域请求<br>当通过ajax异步请求其他域名的服务时，存在跨域无权限访问的问题。<br>此时，可以通过JSONP来实现跨域请求。</p>
<p>2.JSONP原理<br>ajax异步请求无权限访问。但我们发现，web页面调用js文件时不存在跨域问题(如在我们的页面中引入百度地图API， &lt;script<br>type=”text/javascript”<br>src=”<a href="http://api.map.baidu.com/api?v=2.0&amp;ak=e3ZohdqyB0RL98hFOiC29xqh&quot;&gt;&lt;/script&gt;)，总结发现，凡是拥有&quot;src&quot;属性的标签都拥有跨域的能力，如&lt;script&gt;,&lt;img&gt;,&lt;iframe&gt;等。" target="_blank" rel="external">http://api.map.baidu.com/api?v=2.0&amp;ak=e3ZohdqyB0RL98hFOiC29xqh&quot;&gt;&lt;/script&gt;)，总结发现，凡是拥有&quot;src&quot;属性的标签都拥有跨域的能力，如&lt;script&gt;,&lt;img&gt;,&lt;iframe&gt;等。</a><br>这种非正式的传输协议，就是JSONP。JSONP的一个要点是允许客户端传一个callback参数给服务器，然后服务器返回数据时会用这个callback参数作为函数名，包裹住JSON数据，返回客户端，客户端执行返回函数。</p>
<p>3.JSONP客户端具体实现<br>1)直接执行返回函数<br>本地服务器local.com下有个jsonp.html页面代码如下：</p>
<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;http://remote.com/remote.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>远程服务器remote.com下有个remote.js文件代码如下：</p>
<pre><code>alert(&apos;我是远程文件&apos;);
</code></pre><p>运行jsonp.html，会弹出”我是远程文件”，显示跨域调用成功。</p>
<p>2)客户端执行回调函数<br>jsonp.html页面代码如下：</p>
<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    var localHandler = function(data){
        alert(&apos;我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：&apos; + data.result);
    };
    &lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;http://remoteserver.com/remote.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>remote.js文件代码如下：</p>
<pre><code>localHandler({&quot;result&quot;:&quot;我是远程js带来的数据&quot;});
</code></pre><p>运行jsonp.html，会弹出”我是远程js带来的数据”，显示跨域调用成功。</p>
<p>3)客户端传递回调函数<br>jsonp.html页面代码如下：</p>
<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    // 得到航班信息查询结果后的回调函数
    var flightHandler = function(data){
        alert(&apos;你查询的航班结果是：票价 &apos; + data.price + &apos; 元，&apos; + &apos;余票 &apos; + data.tickets + &apos; 张。&apos;);
    };
    // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）
    var url = &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler&quot;;
    // 创建script标签，设置其属性
    var script = document.createElement(&apos;script&apos;);
    script.setAttribute(&apos;src&apos;, url);
    // 把script标签加入head，此时调用开始
    document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); 
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html</p>
<pre><code>flightHandler({
    &quot;code&quot;: &quot;CA1998&quot;,
    &quot;price&quot;: 1780,
    &quot;tickets&quot;: 5
});
</code></pre><p>运行jsonp.html，成功弹出提示窗口。</p>
<p>4)JSONP封装了3)中的代码，以方便客户端使用。<br>jsonp.html页面代码如下：</p>
<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
 &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; &gt;
 &lt;head&gt;
     &lt;title&gt;Untitled Page&lt;/title&gt;
      &lt;script type=&quot;text/javascript&quot; src=jquery.min.js&quot;&gt;&lt;/script&gt;
      &lt;script type=&quot;text/javascript&quot;&gt;
     jQuery(document).ready(function(){ 
        $.ajax({
             type: &quot;get&quot;,
             async: false,
             url: &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&quot;,
             dataType: &quot;jsonp&quot;,
             jsonp: &quot;callback&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)
             jsonpCallback:&quot;flightHandler&quot;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据
             success: function(json){
                 alert(&apos;您查询到航班信息：票价： &apos; + json.price + &apos; 元，余票： &apos; + json.tickets + &apos; 张。&apos;);
             },
             error: function(){
                 alert(&apos;fail&apos;);
             }
         });
     });
     &lt;/script&gt;
     &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
 &lt;/html&gt;
</code></pre><p>示例中没有定义flightHandler函数，但代码成功运行了。<br>这是因为jquery自动把success属性方法作为了回调函数。</p>
<p>4.JSONP总结<br>由上面的讲解可知，ajax和jsonp两种技术看起来很像，但实质上是完全不同。</p>
<p>5.JSON格式数据优点补充<br>1)基于纯文本，跨平台传递简单<br>2)javascript原生支持，后台语言几乎全部支持<br>3)可读性强<br>4)容易编写和解析</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数字证书]]></title>
      <url>https://shijingjing07.github.io/2016/10/02/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/</url>
      <content type="html"><![CDATA[<p>1.什么是数字证书</p>
<p>证书用来证明某个网站或文件。<br>简单可以理解为类似公司公章，用来证明合同文件等是该公司的。</p>
<p>2.什么是CA证书</p>
<p>CA是”证书授权中心”的简称，是负责管理和签发证书的第三方机构。<br>CA证书即为CA颁发的证书。<br>证书人人都可以制作，但只有权威机构颁发的证书，大家才能一致认可。</p>
<p>3.根证书</p>
<p>如下图所示，假设C证书信任A证书，A证书信任A1证书，证书之间的关系构成一个树。<br>根节点的证书即为”根证书”，根证书是不需要证明的，其他证书都需要上一级去证明可靠性。<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161003033138765-602752021.png" alt=""></p>
<p>4.证书的作用<br>1)验证网站是否可信(针对HTTPS)</p>
<p>因为HTTP协议是明文的，如果有人偷窥你的网络通讯，他就可以看到通讯的内容。而HTTPS是加密协议。<br>但是光有加密是不够的，比如有人伪造了一个HTTPS站点，就可能获取到你的账户密码信息。<br>为了防止伪造站点，HTTPS协议除了加密机制，还有一套证书机制。<br>有了证书以后，当访问这个HTTPS网站时，会验证该站点上的CA证书。<br>如果浏览器发现该证书没有问题(证书被某个根证书信任，证书上绑定的域名和该网站的域名一致，证书没有过期)，那么页面直接打开。否则浏览器会弹出警告，下图是IE和Firefox的抓图：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161003033304005-1939107415.png" alt=""></p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161003033313709-540663648.png" alt=""></p>
<p>2)验证文件是否可信</p>
<p>证书还可以用来验证某个文件是否被篡改。<br>具体是通过证书来制作文件的数字签名。<br>如Firefox的安装文件，右键点击”属性”，会看到有个”数字签名”的标签页。<br>如果没有，说明该文件没有附带数字签名。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161003033444481-454542060.png" alt=""></p>
<p>点击”详细信息”，可以看到”数字签名信息”，<br>若为”该数字签名正常”，说明该文件从出厂到你手里，中途没有被篡改过。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161003033518639-851094955.png" alt=""></p>
<p>若为”该数字签名无效”，说明该文件被篡改过了（比如感染了病毒，被注入木马等）<br><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161003033555642-1430002718.png" alt=""></p>
<p>点击”查看证书”，会 弹出证书对话框，点击”证书路径”，可看到证书信任链。如下所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201610/300946-20161003033625332-2141633884.png" alt=""></p>
<p>第一层为根证书Thawte<br>第二层为Thawte用来签名的证书<br>第三层为Mozilla自己的证书</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PostgreSQL9.6新功能]]></title>
      <url>https://shijingjing07.github.io/2016/09/30/PostgreSQL9.6%E6%96%B0%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>PostgreSQL是世界上最先进的开源数据库，9.6最新版本由PostgreSQL全球开发者今天发布。 此版本将允许用户纵向扩展(scale-<br>up)和横向扩展(scale-out)来提高数据库的查询性能。 新功能包括并行查询、同步复制改进、短语搜索、<br>性能和易用性方面的改进，并提供了其他许多方面的功能。</p>
<h3 id="纵向扩展的并行查询"><a href="#纵向扩展的并行查询" class="headerlink" title="纵向扩展的并行查询"></a>纵向扩展的并行查询</h3><p>9.6版本现支持一些并行查询操作，因而能够利用服务器上的几个或所有的CPU内核来进行运算，这样返回查询结果更快。<br>此版本的并行功能包括并行顺序表扫描、聚合和联接。根据详细信息和可用内核，并行性可以加快大数据查询，最快时可高达32倍。</p>
<p>Synthetic Genomics的首席数据库架构师Mike Sofen表示， “我们将我们整个基因组数据平台-<br>250亿行旧的MySQL数据迁移到一个Postgres数据库， 利用了 JSONB 数据类型的行压缩功能，以及优秀的GIN,BRIN和B-Tree索引模式。<br>期待在9.6版本中，利用并行查询功能，在我们查询大表数据时，拥有更强劲的伸缩性，更优的查询性能”</p>
<h3 id="横向扩展的同步复制与postgres-fdw"><a href="#横向扩展的同步复制与postgres-fdw" class="headerlink" title="横向扩展的同步复制与postgres_fdw"></a>横向扩展的同步复制与postgres_fdw</h3><p>PostgreSQL的同步复制功能,添加了两个选项，使它能够用于数据库集群一致读取维护。 首先，它现在允许配置一组的同步的复制数据库。<br>第二，”remote_apply”模式创建多个跨数据节点的一致的读视图。 这些功能使用内置的复制来维护一组的”相同的”节点实现，可以用于数据库的读负载均衡。</p>
<p>postgres_fdw(PostgreSQL-to-PostgreSQL数据外部表驱动程序)提供了新的功能， 支持在远程服务器上执行操作。<br>通过”下推”(Push Down)排序(sort),Join联接，批量数据更新(update)任务,<br>用户可以调度多个PostgreSQL服务器来完成数据查询。 这些功能很快会添加到其他fdw模块中。</p>
<p>Equnix商务解决方案主管Julyanto Sutandang表示， “fdw支持远程联接，更新和删除的功能，是当下其他数据库和<br>PostgreSQL共享数据的完整解决方案。 比如，PostgreSQL可以实现所录入的数据保存到两个或多个不同类型的数据库的功能”</p>
<h3 id="更好的文本短语搜索"><a href="#更好的文本短语搜索" class="headerlink" title="更好的文本短语搜索"></a>更好的文本短语搜索</h3><p>PostgreSQL的全文搜索功能,现在支持短语搜索。 这允许用户搜索精确的短语，或是搜索有一定相似性的短语，<br>使用快速的GIN索引中的单词，结合可精细调整的文本搜索选项的新功能， PostgreSQL是”混合搜索”的超优选择，集成了关系表，JSON和全文的搜索支持。</p>
<h3 id="更畅、更快和更易使用"><a href="#更畅、更快和更易使用" class="headerlink" title="更畅、更快和更易使用"></a>更畅、更快和更易使用</h3><p>感谢大批PostgreSQL 用户使用他们的包含大量数据生产数据库来进行PostgreSQL的反馈和测试，<br>这个版本包括了大量有关性能提升和可用性等方面的内容。复制、聚合、索引、 排序和存储过程变得更加高效，<br>在新的Linux内核上，PostgreSQL现在可以可以更好的利用资源，降低了大型表查询和复杂查询的系统负载， 尤其是VACUUM的改进。</p>
<h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p>9.6版本累计近一年来的很多新特性，主要包括︰</p>
<ul>
<li><p>新的系统视图和函数:pg_stat_wal_receiver，pg_visbility，pg_config，pg_blocking_pids，pg_notification_queue_usage</p>
</li>
<li><p>支持命令执行进度状态报告</p>
</li>
<li><p>支持级联操作(需安装扩展模块实现)</p>
</li>
<li><p>支持pg_basebackup的并发</p>
</li>
<li><p>逻辑复制插槽</p>
</li>
<li><p>等待事件支持</p>
</li>
<li><p>在psql中编辑视图和crosstabs</p>
</li>
<li><p>用户定义旧快照过期</p>
</li>
<li><p>只扫描局部索引</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python程序的调试方法]]></title>
      <url>https://shijingjing07.github.io/2016/09/30/python%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><p>【转自：<a href="http://blog.csdn.net/luckeryin/article/details/4477233" target="_blank" rel="external">http://blog.csdn.net/luckeryin/article/details/4477233</a>】</p>
<p>本文讨论在没有方便的IDE工具可用的情况下，使用pdb调试python程序</p>
<p><strong>源码例子</strong></p>
<p>例如，有模拟税收计算的程序：</p>
<p>#!/usr/bin/python<br>def debug_demo(val):<br>                if val &lt;= 1600 :<br>                                print “level 1”<br>                                print 0<br>                elif val &lt;= 3500 :<br>                                print “level 2”<br>                                print (val - 1600) <em> 0.05<br>                elif val &lt;= 6500 :<br>                                print “level 3”<br>                                print (val - 3500) </em> 0.10 + (3500-1600) <em> 0.05<br>                else:<br>                                print “level 4”<br>                                print (val - 6500) </em> 0.20 + (6500-3500) <em> 0.10 + (3500-1600) </em> 0.05   </p>
<p>#~def debug_demo<br>if <strong>name</strong> == “<strong>main</strong>“:<br>                debug_demo(4500)</p>
<p>debug_demo函数计算4500的入账所需的税收。</p>
<p><strong>如何调试?</strong></p>
<p><strong>1.加入断点</strong></p>
<p>在需要插入断点的地方，加入红色部分代码：如果_DEBUG值为True，则在该处开始调试（加入_DEBUG的原因是为了方便打开/关闭调试）。</p>
<p>#!/usr/bin/python<br>_DEBUG=True<br>def debug_demo(val):<br>                if _DEBUG == True:<br>                                import pdb<br>                                pdb.set_trace()<br>                if val &lt;= 1600 :<br>                                print “level 1”<br>                                print 0<br>                elif val &lt;= 3500 :<br>                                print “level 2”<br>                                print (val - 1600) <em> 0.05<br>                elif val &lt;= 6500 :<br>                                print “level 3”<br>                                print (val - 3500) </em> 0.10 + (3500-1600) <em> 0.05<br>                else:<br>                                print “level 4”<br>                                print (val - 6500) </em> 0.20 + (6500-3500) <em> 0.10 + (3500-1600) </em> 0.05   </p>
<p>#~def debug_demo<br>if <strong>name</strong> == “<strong>main</strong>“:<br>                debug_demo(4500)</p>
<p><strong>2.开始运行调试</strong></p>
<p>  运行程序./debug_demo.py,得到</p>
<p>&gt; /usr/local/qspace/user_network/debug_demo.py(7)debug_demo()<br>-&gt; if val &lt;= 1600 :<br>(Pdb)</p>
<p>-&gt; val &lt;= 1600 : 指示当前执行的语句，（Pdb）等待你的调试指令. pdb的指令很丰富，输入h指令可以查看指令的使用方法。下面简单介绍常用指令：</p>
<p>  查看代码上下文，l（小写L）</p>
<p>(Pdb) l<br>    2         _DEBUG=True<br>    3         def debug_demo(val):<br>    4                         if _DEBUG == True:<br>    5                                         import pdb<br>    6                                         pdb.set_trace()<br>    7    -&gt;                 if val &lt;= 1600 :<br>    8                                         print “level 1”<br>    9                                         print 0<br>  10                         elif val &lt;= 3500 :<br>  11                                         print “level 2”<br>  12                                         print (val - 1600) * 0.05<br>(Pdb)  </p>
<p>左边是行号，右边是代码正文。</p>
<p>  监视变量：p 变量名</p>
<p>(Pdb) p val<br>4500<br>(Pdb)  </p>
<p>单步执行: n</p>
<p>-&gt; elif val &lt;= 3500 :<br>(Pdb) l<br>  5                                         import pdb<br>  6                                         pdb.set_trace()<br>  7                         if val &lt;= 1600 :<br>  8                                         print “level 1”<br>  9                                         print 0<br>10    -&gt;                 elif val &lt;= 3500 :<br>11                                         print “level 2”<br>12                                         print (val - 1600) <em> 0.05<br>13                         elif val &lt;= 6500 :<br>14                                         print “level 3”<br>15                                         print (val - 3500) </em> 0.10 +<br>(3500-1600) * 0.05</p>
<p>加入断点:b 行号</p>
<p>(Pdb) b 14</p>
<p>运行到断点: c</p>
<p>(Pdb) c<br>&gt; /<strong>*</strong><br>-&gt; print “level 3”<br>(Pdb) l<br>  9                                         print 0<br>10                         elif val &lt;= 3500 :<br>11                                         print “level 2”<br>12                                         print (val - 1600) <em> 0.05<br>13                         elif val &lt;= 6500 :<br>14 B-&gt;                                 print “level 3”<br>15                                         print (val - 3500) </em> 0.10 +<br>(3500-1600) <em> 0.05<br>16                         else:<br>17                                         print “level 4”<br>18                                         print (val - 6500) </em> 0.20 +<br>(6500-3500) <em> 0.10 + (3500-1600) </em> 0.05<br>19  </p>
<p>执行到函数返回前: r</p>
<p>(Pdb) r<br>level 3<br>195.0<br>--Return–<br>&gt; /<em>**</em>()</p>
<p>-&gt;None<br>-&gt; print (val - 3500) <em> 0.10 + (3500-1600) </em> 0.05<br>(Pdb)  </p>
<p><strong>说明：</strong></p>
<p>  pdb还有很多其他很多有用的指令，读者可以自行探索。输入h，h 命令。就可以得到命令的详细帮助。</p>
<p>  不过，我个人认为一般无需启动这种调试方法，一般使用日志输出进行调试即可，除非遇到了非常微妙的错误。这时，单步调试的威力便显示出来了</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux ps命令]]></title>
      <url>https://shijingjing07.github.io/2016/09/23/Linux%20ps%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>1.什么是ps命令<br>ps命令是Process Status的缩写。用来显示当前进程的快照，若想动态显示进程信息，可使用top命令。<br>2.Linux进程的5中状态<br>1)运行：R<br>2)中断：S<br>3)不可中断：D<br>4)僵死：Z<br>5)停止：T<br>3.使用示例：<br>ps -ef<br>输出：<br><img src="http://images2015.cnblogs.com/blog/300946/201609/300946-20160923170245934-1089472555.png" alt=""><br>输出信息含义：<br>UID:进程拥有者<br>PID：进程ID<br>PPID:上级父进程ID<br>C：CPU使用百分比<br>TTY：登入者终端机位置<br>TIME：使用掉的CPU时间<br>CMD：进程命令位置</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[http,ftp]]></title>
      <url>https://shijingjing07.github.io/2016/09/21/http,ftp/</url>
      <content type="html"><![CDATA[<p>#<br><a href="http://blog.csdn.net/xiaoxiangzhu660810/article/details/8291656" target="_blank" rel="external">HTTP和FTP的区别</a></p>
<p>标签：<br><a href="http://www.csdn.net/tag/ftp" target="_blank" rel="external">ftp</a><a href="http://www.csdn.net/tag/FTP" target="_blank" rel="external">FTP</a><a href="http://www.csdn.net/tag/http" target="_blank" rel="external">http</a><a href="http://www.csdn.net/tag/Http" target="_blank" rel="external">Http</a><a href="http://www.csdn.net/tag/HTTP" target="_blank" rel="external">HTTP</a></p>
<p>2012-12-13 19:51 10544人阅读<br><a href="http://blog.csdn.net/xiaoxiangzhu660810/article/details/8291656#comments" target="_blank" rel="external">评论</a>(1)<br>收藏 <a href="http://blog.csdn.net/xiaoxiangzhu660810/article/details/8291656#report" title="举报" target="_blank" rel="external">举报</a></p>
<p><img src="http://static.blog.csdn.net/images/category_icon.jpg" alt=""> 分类：</p>
<p>网络（2） <img src="http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg" alt=""></p>
<p>目录<a href="http://blog.csdn.net/xiaoxiangzhu660810/article/details/8291656#" title="系统根据文章中H1到H6标签自动生成文章目录" target="_blank" rel="external">(?)</a><a href="http://blog.csdn.net/xiaoxiangzhu660810/article/details/8291656#" title="展开" target="_blank" rel="external">[+]</a></p>
<p>今天去面试，面试官问我这个问题，好吧，我好不容易记起来两个协议的中文名字，又含糊其辞地说FTP是传输文件的，很怂，回来补补课，每次面试完都觉得啥啥都不懂，大家共勉吧^_^</p>
<h2 id="一、字面上来看"><a href="#一、字面上来看" class="headerlink" title="一、字面上来看"></a>一、字面上来看</h2><p>HTTP是Hyper Text Transfer Protocol，超文本传输协议；</p>
<p>FTP是File Transfer Protocol,文件传输协议；</p>
<p>简单说HTTP是面向网页的，而FTP是面向文件的。</p>
<h2 id="二、复杂点儿"><a href="#二、复杂点儿" class="headerlink" title="二、复杂点儿"></a>二、复杂点儿</h2><h3 id="1-FTP"><a href="#1-FTP" class="headerlink" title="1.FTP"></a>1.FTP</h3><h4 id="1-FTP比HTTP复杂"><a href="#1-FTP比HTTP复杂" class="headerlink" title="(1)FTP比HTTP复杂"></a>(1)FTP比HTTP复杂</h4><p>FTP和HTTP一样都是Internet上广泛使用的协议，用来在两台计算机之间互相传送文件。相比于HTTP，FTP协议要复杂得多。复杂的原因，是因为FTP协议要用到两个TCP连接，一个是命令链路，用来在FTP客户端与服务器之间传递命令；另一个是数据链路，用来上传或下载数据。</p>
<h4 id="2-FTP协议有两种工作方式：PORT方式和PASV方式，中文意思为主动式和被动式。"><a href="#2-FTP协议有两种工作方式：PORT方式和PASV方式，中文意思为主动式和被动式。" class="headerlink" title="(2)FTP协议有两种工作方式：PORT方式和PASV方式，中文意思为主动式和被动式。"></a>(2)FTP协议有两种工作方式：PORT方式和PASV方式，中文意思为主动式和被动式。</h4><p>PORT（主动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。当需要传送数据时，客户端在命令链上用PORT命令告诉服务器：”我打开了XXXX端口，你过来连接我”。于是服务器从20端口向客户端的XXXX端口发送连接请求，建立一条数据链路来传送数据。  </p>
<p>PASV（被动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。当需要传送数据时，服务器在命令链上用PASV命令告诉客户端：”我打开了XXXX端口，你过来连接我”。于是客户端向服务器的XXXX端口发送连接请求，建立一条数据链路来传送数据。  </p>
<p>从上面可以看出，两种方式的命令链路连接方法是一样的，而数据链路的建立方法就完全不同。而FTP的复杂性就在于此。</p>
<h3 id="2-HTTP"><a href="#2-HTTP" class="headerlink" title="2.HTTP"></a>2.HTTP</h3><p>当我们想浏览一个网站的时候，只要在浏览器的地址栏里输入网站的地址就可以了，例如<a href="http://www.microsoft.com,但是在浏览...w.microsoft.com" target="_blank" rel="external">http://www.microsoft.com,但是在浏览...w.microsoft.com</a><br>,你知道为什么会多出一个”http”吗？</p>
<h4 id="1-HTTP协议是什么"><a href="#1-HTTP协议是什么" class="headerlink" title="(1)HTTP协议是什么"></a>(1)HTTP协议是什么</h4><p>我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource<br>Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。因此，在我们认识HTTP之前，有必要先弄清楚URL的组成,例如：<a href="http://www.microsoft.com/china/index.htm。它的含义如下：" target="_blank" rel="external">http://www.microsoft.com/china/index.htm。它的含义如下：</a><br>1. <a href="http://：代表超文本传输协议，通知microsoft.com服务器显示Web页，通常不用输入；" target="_blank" rel="external">http://：代表超文本传输协议，通知microsoft.com服务器显示Web页，通常不用输入；</a><br>2. www：代表一个Web（万维网）服务器；<br>3. Microsoft.com/：这是装有网页的服务器的域名，或站点服务器的名称；<br>4. China/：为该服务器上的子目录，就好像我们的文件夹；<br>5. Index.htm：index.htm是文件夹中的一个HTML文件（网页）。  </p>
<p>我们知道，Internet的基本协议是TCP/IP协议，然而在TCP/IP模型最上层的是应用层（Application<br>layer），它包含所有高层的协议。高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等。</p>
<p>HTTP协议（Hypertext Transfer<br>Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。这就是你为什么在浏览器中看到的网页地址都是以<a href="http://开头的原因。" target="_blank" rel="external">http://开头的原因。</a><br>自WWW诞生以来，一个多姿多彩的资讯和虚拟的世界便出现在我们眼前，可是我们怎么能够更加容易地找到我们需要的资讯呢？当决定使用超文本作为WWW文档的标准格式后，于是在1990年，科学家们立即制定了能够快速查找这些超文本文档的协议，即HTTP协议。  </p>
<h4 id="（2）HTTP是怎样工作的"><a href="#（2）HTTP是怎样工作的" class="headerlink" title="（2）HTTP是怎样工作的"></a>（2）HTTP是怎样工作的</h4><p>由于HTTP协议是基于请求/响应范式的（相当于客户机/服务器）。一个客户机与服务器建立连接后，发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME（关于MIME，看百度百科里是这样解释的<a href="http://baike.baidu.com/view/160611.htm）信息包括请求修饰符、客户机信息和可能的内容。服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。" target="_blank" rel="external">http://baike.baidu.com/view/160611.htm）信息包括请求修饰符、客户机信息和可能的内容。服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</a><br>许多HTTP通讯是由一个用户代理初始化的并且包括一个申请在源服务器上资源的请求。最简单的情况可能是在用户代理和服务器之间通过一个单独的连接来完成。在Internet上，HTTP通讯通常发生在TCP/IP连接之上。缺省端口是TCP<br>80，但其它的端口也是可用的。但这并不预示着HTTP协议在Internet或其它网络的其它协议之上才能完成。HTTP只预示着一个可靠的传输。<br>这个过程就好像我们打电话订货一样，我们可以打电话给商家，告诉他我们需要什么规格的商品，然后商家再告诉我们什么商品有货，什么商品缺货。这些，我们是通过电话线用电话联系（HTTP是通过TCP/IP），当然我们也可以通过传真，只要商家那边也有传真。  </p>
<p>以上简要介绍了HTTP协议的宏观运作方式，下面介绍一下HTTP协议的内部操作过程。</p>
<p>在WWW中，”客户”与”服务器”是一个相对的概念，只存在于一个特定的连接期间，即在某个连接中的客户在另一个连接中可能作为服务器。基于HTTP协议的客户/服务器模式的信息交换过程，它分四个过程：建立连接、发送请求信息、发送响应信息、关闭连接。这就好像上面的例子，我们电话订货的全过程。</p>
<p>其实简单说就是任何服务器除了包括HTML文件以外，还有一个HTTP驻留程序，用于响应用户请求。你的浏览器是HTTP客户，向服务器发送请求，当浏览器中输入了一个开始文件或点击了一个超级链接时，浏览器就向服务器发送了HTTP请求，此请求被送往由IP地址指定的URL。驻留程序接收到请求，在进行必要的操作后回送所要求的文件。在这一过程中，在网络上发送和接收的数据已经被分成一个或多个数据包（packet），每个数据包包括：要传送的数据；控制信息，即告诉网络怎样处理数据包。TCP/IP决定了每个数据包的格式。如果事先不告诉你，你可能不会知道信息被分成用于传输和再重新组合起来的许多小块。<br>也就是说商家除了拥有商品之外，它也有一个职员在接听你的电话，当你打电话的时候，你的声音转换成各种复杂的数据，通过电话线传输到对方的电话机，对方的电话机又把各种复杂的数据转换成声音，使得对方商家的职员能够明白你的请求。这个过程你不需要明白声音是怎么转换成复杂的数据的。  </p>
<h4 id="（3）-ipc-是什么"><a href="#（3）-ipc-是什么" class="headerlink" title="（3） ipc$ 是什么"></a>（3） ipc$ 是什么</h4><p>IPC$(Internet Process<br>Connection)是共享”命名管道”的资源(大家都是这么说的)，它是为了让进程间通信而开放的命名管道，可以通过验证用户名和密码获得相应的权限,在远程管理计算机和查看计算机的共享资源时使用。<br>利用IPC$,连接者甚至可以与目标主机建立一个空的连接而无需用户名与密码(当然,对方机器必须开了ipc$共享,否则你是连接不上的)，而利用这个空的连接，连接者还可以得到目标主机上的用户列表(不过负责的管理员会禁止导出用户列表的)。<br>我们总在说ipc$漏洞ipc$漏洞,其实,ipc$并不是真正意义上的漏洞,它是为了方便管理员的远程管理而开放的远程网络登陆功能,而且还打开了默认共享,即所有的逻辑盘(c$,d$,e$……)和系统目录winnt或windows(admin$)。<br>所有的这些,初衷都是为了方便管理员的管理,但好的初衷并不一定有好的收效,一些别有用心者(到底是什么用心?我也不知道,代词一个)会利用IPC$，访问共享资源,导出用户列表,并使用一些字典工具，进行密码探测,寄希望于获得更高的权限,从而达到不可告人的目的.<br>解惑:<br>1)IPC连接是Windows NT及以上系统中特有的远程网络登陆功能，其功能相当于Unix中的Telnet,由于IPC$功能需要用到Windows<br>NT中的很多DLL函数，所以不能在Windows 9.x中运行。<br>也就是说只有nt/2000/xp才可以建立ipc$连接,98/me是不能建立ipc$连接的(但有些朋友说在98下能建立空的连接,不知道是真是假,不过现在都2003年了,建议98的同志换一下系统吧,98不爽的)<br>2)即使是空连接也不是100%都能建立成功,如果对方关闭了ipc$共享,你仍然无法建立连接<br>3)并不是说建立了ipc$连接就可以查看对方的用户列表,因为管理员可以禁止导出用户列表.  </p>
<h4 id="（4）-ASP-是什么"><a href="#（4）-ASP-是什么" class="headerlink" title="（4） ASP 是什么?"></a>（4） ASP 是什么?</h4><p>ASP即Active Server Page的缩写。它是一种包含了使用VB Script或Jscript脚本程序代码的网页。当浏览器浏览ASP网页时,<br>Web服务器就会根据请求生成相应的HTML代码然后再返回给浏览器,这样浏览器端看到的<br>就是动态生成的网页。ASP是微软公司开发的代替CGI脚本程序的一种应用,它可以与数据库和其它程序进行交互。是一种简单、方便的编程工具。在了解了VBSCRIPT的基本语法后，只需要清楚各个组件的用途、属性、方法，就可以轻松编写出自己的ASP系统。ASP的网页文件的格式是.ASP。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SecureCRT注册机使用方法]]></title>
      <url>https://shijingjing07.github.io/2016/09/20/SecureCRT%E6%B3%A8%E5%86%8C%E6%9C%BA%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>SecureCRT_7.3注册机激活步骤如下：</p>
<p>1）准备工作</p>
<p>安装好SecureCRT软件，</p>
<p>下载并得到该注册机。</p>
<p>2）保持SecureCRT软件关闭（运行的话会提示你正在运行的，关闭就好）。</p>
<p>3）将注册机拷贝到你的CRT软件的安装的目录下；</p>
<p>4）点击【Patch】按钮，会让你选择文件<br>，选择SecureCRT.exe可执行文件，还会再提示一次选择一个help什么文件。总之，确定后都会提示成功信息。</p>
<p>5）然后打开CRT软件，按照相应的提示输入注册机上显示的信息（当然重新生成也是可以的）。注意，默认打开CRT时候会是一个输入key的页面，什么都不输入，点击下一步，选择输入自己的相关信息。就会看到分别让你输入名称、序列号等相关日期了。完成结束。看看自己的是否有激活成功。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信消息的处理和应答]]></title>
      <url>https://shijingjing07.github.io/2016/09/18/%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%E7%9A%84%E5%A4%84%E7%90%86%E5%92%8C%E5%BA%94%E7%AD%94/</url>
      <content type="html"><![CDATA[<p>1.微信消息应答流程<br>微信服务器是客户手机和开发服务器信息流通的桥梁。消息流程图如下：<br><img src="http://images2015.cnblogs.com/blog/300946/201609/300946-20160918231623647-1594288246.png" alt=""></p>
<p>2.微信服务器向开发服务器请求消息<br>1)文本消息处理<br>2)事件消息处理<br>3)开发者认证处理<br><img src="http://images2015.cnblogs.com/blog/300946/201609/300946-20160918231637429-148934776.png" alt=""></p>
<p>微信消息处理入口操作，代码示例如下：</p>
<pre><code>public void ProcessRequest(HttpContext context)
{
    //WHC.Framework.Commons.LogTextHelper.Info(&quot;测试记录&quot;);

    string postString = string.Empty;
    if (HttpContext.Current.Request.HttpMethod.ToUpper() == &quot;POST&quot;)
    {
        using (Stream stream = HttpContext.Current.Request.InputStream)
        {
            Byte[] postBytes = new Byte[stream.Length];
            stream.Read(postBytes, 0, (Int32)stream.Length);
            postString = Encoding.UTF8.GetString(postBytes);
        }

        if (!string.IsNullOrEmpty(postString))
        {
            Execute(postString);
        }
    }
    else
    {
        Auth();
    }
}
</code></pre><p>WeixinApiDispatch消息分发管理类，它提取请求消息的内容，并构建不同类型的消息参数，传递给不同的响应函数进行处理，然后返回封装好的XML内容，作为响应。</p>
<pre><code>/// &lt;summary&gt;
/// 处理各种请求信息并应答（通过POST的请求）
/// &lt;/summary&gt;
/// &lt;param name=&quot;postStr&quot;&gt;POST方式提交的数据&lt;/param&gt;
private void Execute(string postStr)
{
    WeixinApiDispatch dispatch = new WeixinApiDispatch();
    string responseContent = dispatch.Execute(postStr);

    HttpContext.Current.Response.ContentEncoding = Encoding.UTF8;
    HttpContext.Current.Response.Write(responseContent);
}
</code></pre><p>代码处理逻辑如下图所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201609/300946-20160918231731840-1285622410.png" alt=""></p>
<p>具体的消息处理类：</p>
<pre><code>/// &lt;summary&gt;
/// 客户端请求的数据接口
/// &lt;/summary&gt;
public interface IWeixinAction
{
    /// &lt;summary&gt;
    /// 对文本请求信息进行处理
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;info&quot;&gt;文本信息实体&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    string HandleText(RequestText info);

    /// &lt;summary&gt;
    /// 对图片请求信息进行处理
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;info&quot;&gt;图片信息实体&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    string HandleImage(RequestImage info);

...........................


    /// &lt;summary&gt;
    /// 对订阅请求事件进行处理
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;info&quot;&gt;订阅请求事件信息实体&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    string HandleEventSubscribe(RequestEventSubscribe info);

    /// &lt;summary&gt;
    /// 对菜单单击请求事件进行处理
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;info&quot;&gt;菜单单击请求事件信息实体&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    string HandleEventClick(RequestEventClick info);

..............................
}
</code></pre><p>其中，实体类参数是我们根据程序开发自己定义的，继承关系如下所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201609/300946-20160918231806967-1391534270.png" alt=""></p>
<p>3.开发者服务器向微信服务器进行的消息请求消息<br>我们可以通过微信，进行相关的消息回复或者数据管理操作。<br>如下如所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201609/300946-20160918231825453-2039232473.png" alt=""></p>
<p>微信的回复消息处理，处理逻辑如下图所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201609/300946-20160918231842407-1088216109.png" alt=""></p>
<p>参考资料：<a href="http://www.cnblogs.com/wuhuacong/p/3614175.html" target="_blank" rel="external">http://www.cnblogs.com/wuhuacong/p/3614175.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信公众号开发--开发服务器接入微信服务器]]></title>
      <url>https://shijingjing07.github.io/2016/09/17/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91--%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<p><strong>1.微信公众号注册</strong><br>到微信公众平台（<a href="https://mp.weixin.qq.com/）注册公众号。" target="_blank" rel="external">https://mp.weixin.qq.com/）注册公众号。</a><br>公众号有”服务号”，”订阅号”，”企业号”三种类别，”服务号”主要面向企业和个人，”订阅号”主要面向组织和个人。<br>申请完毕后，登陆公众号，进入管理界面，公众号对应的二维码如下所示：<br><img src="http://images2015.cnblogs.com/blog/300946/201609/300946-20160918001355273-1496569262.png" alt=""><br><strong>2.开发服务器配置</strong><br><img src="http://images2015.cnblogs.com/blog/300946/201609/300946-20160918001455711-2130774720.png" alt=""><br>URL是开发者用来接收微信消息和事件的接口URL<br>Token可由开发者任意填写，用作生成签名<br>EncodingAESKey由开发者手动填写或随机生成，将用作消息体加解密秘钥</p>
<p><strong>3.验证开发服务器地址有效性</strong><br>开发者提交信息后，微信服务器将发送GET请求到开发服务器URL，GET请求有四个参数：<br>signature:微信加密签名<br>signature结合了token，timestamp，nonce三个参数<br>timestamp:时间戳<br>nonce:随机数<br>echostr:随机字符串</p>
<p>开发者通过检验signature对请求进行检验，若检验成功，接入生效，否则接入失败</p>
<p>加密/检验流程如下：<br>1)将token,timestamp,nonce三个参数进行字典序排序<br>2)将三个参数字符串拼接成一个字符串进行sha1加密<br>3)开发者获得加密后的字符串雨signature对比</p>
<p>检验signature的C#示例代码如下：</p>
<p>wxapi.ashx</p>
<pre><code>&lt;%@ WebHandler Language=&quot;C#&quot; Class=&quot;wxapi&quot; %&gt;

using System;
using System.Web;
using System.IO;
using System.Text;
using System.Web.Security;
public class wxapi : IHttpHandler {

    public void ProcessRequest (HttpContext context) {
        string postString = string.Empty;
        Auth(); //微信接入的测试
    }
    /// &lt;summary&gt;
    /// 成为开发者的第一步，验证并相应服务器的数据
    /// &lt;/summary&gt;
    private void Auth()
    {
        string token = &quot;weixin&quot;;//从配置文件获取Token
        if (string.IsNullOrEmpty(token))
        {

        }

        string echoString = HttpContext.Current.Request.QueryString[&quot;echoStr&quot;];
        string signature = HttpContext.Current.Request.QueryString[&quot;signature&quot;];
        string timestamp = HttpContext.Current.Request.QueryString[&quot;timestamp&quot;];
        string nonce = HttpContext.Current.Request.QueryString[&quot;nonce&quot;];

        if (CheckSignature(token, signature, timestamp, nonce))
        {
            if (!string.IsNullOrEmpty(echoString))
            {
                HttpContext.Current.Response.Write(echoString);
                HttpContext.Current.Response.End();
            }
        }
    }
    /// &lt;summary&gt;
    /// 验证微信签名
    /// &lt;/summary&gt;
    public bool CheckSignature(string token, string signature, string timestamp, string nonce)
    {
        string[] ArrTmp = { token, timestamp, nonce };

        Array.Sort(ArrTmp);
        string tmpStr = string.Join(&quot;&quot;, ArrTmp);

        tmpStr = FormsAuthentication.HashPasswordForStoringInConfigFile(tmpStr, &quot;SHA1&quot;);
        tmpStr = tmpStr.ToLower();

        if (tmpStr == signature)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    public bool IsReusable {
        get {
            return false;
        }
    }

}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RESTful架构]]></title>
      <url>https://shijingjing07.github.io/2016/09/08/RESTful%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<h1 id="RESTful架构"><a href="#RESTful架构" class="headerlink" title="RESTful架构"></a><strong>RESTful架构</strong></h1><p>1.什么是RESTful API设计原则</p>
<p>REST是Representational State Transfer的简写，意为”表现层状态转换”</p>
<p>是一种对资源状态进行操作的设计规则，如查询，新增，删除，修改</p>
<p>（1）每个URI代表一种资源</p>
<p>（2）客户端和服务器之间，传递这种资源的某种表现层</p>
<p>（3）客户端通过四个HTTP动作，对服务器端资源进行操作，实现”表现层状态转换”</p>
<p>2.资源</p>
<p>资源即为实体，如一个文件，图片等</p>
<p>3.表现层</p>
<p>资源的表现形式，如文本可以用txt,html,xml,json,二进制等多种不同格式来表现。</p>
<p>资源的具体表现形式，是在http请求头中使用Accept和Content-Type来指定的。</p>
<p>4.状态转换</p>
<p>操作一个资源表现层转换，只能是HTTP协议。</p>
<p>具体，在HTTP协议里面，有四个表示操作方式的动词：GET,POST,PUT,DELETE，分别用来获取，新建，更新，删除资源。</p>
<p>5.RESTful设计指南</p>
<p>（1）总是使用HTTPs协议</p>
<p>（2）域名</p>
<p><a href="https://api.example.com" target="_blank" rel="external">https://api.example.com</a></p>
<p>（3）版本</p>
<p><a href="https://api.example.com/v1/" target="_blank" rel="external">https://api.example.com/v1/</a></p>
<p>（4）路径</p>
<p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表名对应，名词应该使用复数。</p>
<p><a href="https://api.example.com/v1/zoos" target="_blank" rel="external">https://api.example.com/v1/zoos</a></p>
<p><a href="https://api.example.com/v1/animals" target="_blank" rel="external">https://api.example.com/v1/animals</a></p>
<p>（5）HTTP动词</p>
<p>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>
<p>GET（SELECT）：从服务器取出资源（一项或多项）。</p>
<p>POST（CREATE）：在服务器新建一个资源。</p>
<p>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</p>
<p>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</p>
<p>DELETE（DELETE）：从服务器删除资源。</p>
<p>示例如下：</p>
<p>GET /zoos：列出所有动物园</p>
<p>POST /zoos：新建一个动物园</p>
<p>GET /zoos/ID：获取某个指定动物园的信息</p>
<p>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</p>
<p>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</p>
<p>DELETE /zoos/ID：删除某个动物园</p>
<p>GET /zoos/ID/animals：列出某个指定动物园的所有动物</p>
<p>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</p>
<p>（6）过滤信息</p>
<p>下面是一些常见的参数</p>
<p>?limit=10：指定返回记录的数量</p>
<p>?offset=10：指定返回记录的开始位置。</p>
<p>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</p>
<p>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</p>
<p>?animal_type_id=1：指定筛选条件</p>
<p>（7）状态码</p>
<p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）</p>
<p>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</p>
<p>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</p>
<p>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</p>
<p>204 NO CONTENT - [DELETE]：用户删除数据成功。</p>
<p>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</p>
<p>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</p>
<p>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</p>
<p>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</p>
<p>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</p>
<p>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</p>
<p>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</p>
<p>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</p>
<p>（8）错误处理</p>
<p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可</p>
<p>{</p>
<p>error: “Invalid API key”</p>
<p>}</p>
<p>（9）返回结果</p>
<p>GET /collection：返回资源对象的列表（数组）</p>
<p>GET /collection/resource：返回单个资源对象</p>
<p>POST /collection：返回新生成的资源对象</p>
<p>PUT /collection/resource：返回完整的资源对象</p>
<p>PATCH /collection/resource：返回完整的资源对象</p>
<p>DELETE /collection/resource：返回一个空文档</p>
<p>（10）提供Hypermedia</p>
<p>返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p>
<p>（11）其他</p>
<p>API使用OAuth2.0框架</p>
<p>服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OAuth2.0详解]]></title>
      <url>https://shijingjing07.github.io/2016/09/08/OAuth2.0%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>1.使用场景</p>
<p>A系统存放着订单信息</p>
<p>B系统需要查询A系统中的订单信息，但是必须要A系统验证通过后，才能查询。</p>
<p>此时，我们有两种验证方式：</p>
<p>1)拥有A系统的账户/密码</p>
<p>  弊端是对A系统来说，直接提供账户/密码的方式非常不安全。</p>
<p>2)A系统给B系统颁发一个令牌，规定了令牌的使用范围和有效期，可以理解为一个通行证。</p>
<p>第二种方式，就是我们所说的OAuth授权。</p>
<p>2.OAuth原理</p>
<p>我们称待授权系统为”客户端”，授权系统为”服务器”</p>
<p>OAuth的原理是，”客户端”不能直接登录”服务器”，”客户端”登录时，”服务端”有一个”授权层”，会首先检验颁发给”客户端”的”令牌”是否有效，若有效，则允许登录。</p>
<p>3.OAuth验证流程</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201609/300946-20160908171316113-195409067.png" alt=""></p>
<p>（A）客户端请求用户授权</p>
<p>（B）用户同意授权给客户端</p>
<p>（C）客户端使用上一步获得的授权，像服务器申请令牌</p>
<p>（D）服务器对客户端进行认证后，确认无误，同意发送令牌</p>
<p>（E）客户端使用令牌，向服务器请求资源</p>
<p>（F）服务器确认令牌无误，返回资源</p>
<p>上述步骤中，关键是用户如何给客户端授权。有了授权后，客户端就可以获得令牌，继而获得资源。</p>
<p>4.客户端授权的四种模式</p>
<p>授权码模式</p>
<p>简化模式</p>
<p>密码模式</p>
<p>客户端模式</p>
<p>5.授权码模式</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201609/300946-20160908171336691-1061817565.png" alt=""></p>
<p>（A）用户访问客户端，客户端将用户导向服务器，包含了”重定向URI”地址</p>
<p>（B）用户选择是否给予客户端授权</p>
<p>（C）若给予，服务器将用户导向”重定向URI”地址，同时附上一个授权码</p>
<p>（D）客户端收到授权码，附上”重定向URI”地址，向服务器申请令牌</p>
<p>（E）服务端核对授权码和重定向URI，确认无误，向客户端发送访问令牌和更新令牌</p>
<p>授权模式的特点是，需要通过客户端服务器，来和服务器端进行交互。</p>
<p>6.简化模式</p>
<p>简化模式不需要客户端服务器，直接通过浏览器向服务器申请令牌，跳过了”授权码”</p>
<p>所有步骤在浏览器中完成，不需要认证客户端。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201609/300946-20160908171351238-623752089.png" alt=""></p>
<p>（A）客户端将用户导向服务器</p>
<p>（B）用户决定是否给予客户端授权</p>
<p>（C）若授权，服务器将用户导向客户端指定的”重定向URI”，URI的hash部分包含了访问令牌。</p>
<p>（D）浏览器向服务器发出请求，不包括上一步收到的hash值</p>
<p>（E）服务器返回一个网页，其中包含的代码可以获取hash值中的令牌</p>
<p>（F）浏览器执行上一步获得的脚本，提取出令牌</p>
<p>（G）浏览器将令牌发给客户端</p>
<p>7.密码模式</p>
<p>用户向客户端提供自己的用户名和密码，客户端使用用户名/密码，向服务器索要授权</p>
<p>客户端不得储存密码，通常是一些大品牌信誉好的公司，才用这种模式。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201609/300946-20160908171403879-1720556914.png" alt=""></p>
<p>（A）用户向客户端提供用户名/密码</p>
<p>（B）客户端讲用户名/密码发给服务器，请求令牌</p>
<p>（C）服务器确认无误，向客户端提供访问令牌</p>
<p>8.客户端模式</p>
<p>客户端以自己的名义，而不是用户的名义，向服务器进行认证。用户直接向客户端注册，客户端以自己的名义要求服务器提供服务，其实不存在授权问题。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201609/300946-20160908171413441-1479058253.png" alt=""></p>
<p>（A）客户端向服务器进行身份认证，并要求一个访问令牌</p>
<p>（B）服务器确认无误，向客户端提供访问令牌</p>
<p>9.更新令牌</p>
<p>客户端的访问令牌过期后，需要使用更新令牌申请一个新的访问令牌</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTTP头详解]]></title>
      <url>https://shijingjing07.github.io/2016/09/08/HTTP%E5%A4%B4%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>HTTP 头部解释</p>
<p>1. Accept：告诉WEB服务器自己接受什么介质类型，<em>/</em> 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。</p>
<p>2. Accept-Charset： 浏览器申明自己接收的字符集<br>Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法 （gzip，deflate）<br>Accept-Language：：浏览器申明自己接收的语言语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。</p>
<p>3. Accept-<br>Ranges：WEB服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。bytes：表示接受，none：表示不接受。</p>
<p>4. Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。</p>
<p>5. Authorization：当客户端接收到来自WEB服务器的 WWW-Authenticate<br>响应时，该头部来回应自己的身份验证信息给WEB服务器。</p>
<p>6. Cache-Control：请求：no-cache（不要缓存的实体，要求现在从WEB服务器去取）<br>max-age：（只接受 Age 值小于 max-age 值，并且没有过期的对象）<br>max-stale：（可以接受过去的对象，但是过期时间必须小于<br>max-stale 值）<br>min-fresh：（接受其新鲜生命期大于其当前 Age 跟 min-fresh 值之和的<br>缓存对象）<br>响应：public(可以用 Cached 内容回应任何用户)<br>private（只能用缓存内容回应先前请求该内容的那个用户）<br>no-cache（可以缓存，但是只有在跟WEB服务器验证了其有效后，才能返回给客户端）<br>max-age：（本响应包含的对象的过期时间）<br>ALL: no-store（不允许缓存）</p>
<p>7. Connection：请求：close（告诉WEB服务器或者代理服务器，在完成本次请求的响应<br>后，断开连接，不要等待本次连接的后续请求了）。<br>keepalive（告诉WEB服务器或者代理服务器，在完成本次请求的<br>响应后，保持连接，等待本次连接的后续请求）。<br>响应：close（连接已经关闭）。<br>keepalive（连接保持着，在等待本次连接的后续请求）。<br>Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持<br>连接多长时间（秒）。<br>例如：Keep-Alive：300</p>
<p>8. Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。<br>例如：Content-Encoding：gzip<br>Content-Language：WEB 服务器告诉浏览器自己响应的对象的语言。<br>Content-Length： WEB 服务器告诉浏览器自己响应的对象的长度。<br>例如：Content-Length: 26012<br>Content-Range： WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。<br>例如：Content-Range: bytes 21010-47021/47022<br>Content-Type： WEB 服务器告诉浏览器自己响应的对象的类型。<br>例如：Content-Type：application/xml</p>
<p>9. ETag：就是一个对象（比如URL）的标志值，就一个对象而言，比如一个 html 文件，<br>如果被修改了，其 Etag 也会别修改， 所以，ETag 的作用跟 Last-Modified 的<br>作用差不多，主要供 WEB 服务器 判断一个对象是否改变了。<br>比如前一次请求某个 html 文件时，获得了其 ETag，当这次又请求这个文件时，<br>浏览器就会把先前获得的 ETag 值发送给 WEB 服务器，然后 WEB 服务器<br>会把这个 ETag 跟该文件的当前 ETag 进行对比，然后就知道这个文件<br>有没有改变了。</p>
<p>10. Expired：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在<br>跟WEB服务器验证了其有效性后，才能用来响应客户请求。<br>是 HTTP/1.0 的头部。<br>例如：Expires：Sat, 23 May 2009 10:02:12 GMT</p>
<p>11. Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。<br>例如：Host：rss.sina.com.cn</p>
<p>12. If-Match：如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作。<br>If-None-Match：如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作。</p>
<p>13. If-Modified-Since：如果请求的对象在该头部指定的时间之后修改了，才执行请求<br>的动作（比如返回对象），否则返回代码304，告诉浏览器该对象<br>没有修改。<br>例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT<br>If-Unmodified-Since：如果请求的对象在该头部指定的时间之后没修改过，才执行<br>请求的动作（比如返回对象）。</p>
<p>14. If-Range：浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分<br>给我，如果对象改变了，就把整个对象给我。 浏览器通过发送请求对象的<br>ETag 或者 自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否<br>改变了。<br>总是跟 Range 头部一起使用。</p>
<p>15. Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，<br>动态页面的最后产生时间等等。<br>例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT</p>
<p>16. Location：WEB 服务器告诉浏览器，试图访问的对象已经被移到别的位置了，<br>到该头部指定的位置去取。<br>例如：Location：<br><a href="http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif" target="_blank" rel="external">http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif</a></p>
<p>17. Pramga：主要使用 Pramga: no-cache，相当于 Cache-Control： no-cache。<br>例如：Pragma：no-cache</p>
<p>18. Proxy-Authenticate： 代理服务器响应浏览器，要求其提供代理身份验证信息。<br>Proxy-Authorization：浏览器响应代理服务器的身份验证请求，提供自己的身份信息。</p>
<p>19. Range：浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。<br>例如：Range: bytes=1173546-</p>
<p>20. Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。<br>例如：Referer：<a href="http://www.sina.com/" target="_blank" rel="external">http://www.sina.com/</a></p>
<p>21. Server: WEB 服务器表明自己是什么软件及版本等信息。<br>例如：Server：Apache/2.0.61 (Unix)</p>
<p>22. User-Agent: 浏览器表明自己的身份（是哪种浏览器）。<br>例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN;<br>rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14</p>
<p>23. Transfer-Encoding: WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）<br>作了怎样的编码，比如是否分块（chunked）。<br>例如：Transfer-Encoding: chunked</p>
<p>24. Vary: WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应<br>所返回的对象响应后续的请求。<br>假如源WEB服务器在接到第一个请求消息时，其响应消息的头部为：<br>Content-Encoding: gzip; Vary: Content-Encoding 那么 Cache 服务器会分析后续<br>请求消息的头部，检查其 Accept-Encoding，是否跟先前响应的 Vary 头部值<br>一致，即是否使用相同的内容编码方法，这样就可以防止 Cache 服务器用自己<br>Cache 里面压缩后的实体响应给不具备解压能力的浏览器。<br>例如：Vary：Accept-Encoding</p>
<p>25. Via： 列出从客户端到 OCS 或者相反方向的响应经过了哪些代理服务器，他们用<br>什么协议（和版本）发送的请求。<br>当客户端请求到达第一个代理服务器时，该服务器会在自己发出的请求里面<br>添加 Via 头部，并填上自己的相关信息，当下一个代理服务器 收到第一个代理<br>服务器的请求时，会在自己发出的请求里面复制前一个代理服务器的请求的Via<br>头部，并把自己的相关信息加到后面， 以此类推，当 OCS 收到最后一个代理服<br>务器的请求时，检查 Via 头部，就知道该请求所经过的路由。<br>例如：Via：1.0 236-81.D07071953.sina.com.cn:80 (squid/2.6.STABLE13)</p>
<p>====================================</p>
<p>HTTP 请求消息头部实例：<br>Host：rss.sina.com.cn<br>User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.14)<br>Gecko/20080404 Firefox/2.0.0.14<br>Accept：text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,<em>/</em>;q=0.5<br>Accept-Language：zh-cn,zh;q=0.5<br>Accept-Encoding：gzip,deflate<br>Accept-Charset：gb2312,utf-8;q=0.7,*;q=0.7<br>Keep-Alive：300<br>Connection：keep-alive<br>Cookie：userId=C5bYpXrimdmsiQmsBPnE1Vn8ZQmdWSm3WRlEB3vRwTnRtW &lt;-- Cookie<br>If-Modified-Since：Sun, 01 Jun 2008 12:05:30 GMT<br>Cache-Control：max-age=0<br>HTTP 响应消息头部实例：<br>Status：OK - 200 &lt;-- 响应状态码，表示 web 服务器处理的结果。<br>Date：Sun, 01 Jun 2008 12:35:47 GMT<br>Server：Apache/2.0.61 (Unix)<br>Last-Modified：Sun, 01 Jun 2008 12:35:30 GMT<br>Accept-Ranges：bytes<br>Content-Length：18616<br>Cache-Control：max-age=120<br>Expires：Sun, 01 Jun 2008 12:37:47 GMT<br>Content-Type：application/xml<br>Age：2<br>X-Cache：HIT from 236-41.D07071951.sina.com.cn &lt;-- 反向代理服务器使用的 HTTP 头部<br>Via：1.0 236-41.D07071951.sina.com.cn:80 (squid/2.6.STABLE13)  </p>
<h1 id="Connection：close"><a href="#Connection：close" class="headerlink" title="Connection：close  "></a>Connection：close  </h1><p>HTTP头部信息简单说明</p>
<p>一、HTTP响应码响应码由三位十进制数字组成，它们出现在由HTTP服务器发送的响应的第一行。<br>响应码分五种类型，由它们的第一位数字表示：<br>1xx：信息，请求收到，继续处理<br>2xx：成功，行为被成功地接受、理解和采纳<br>3xx：重定向，为了完成请求，必须进一步执行的动作<br>4xx：客户端错误，请求包含语法错误或者请求无法实现<br>5xx：服务器错误，服务器不能实现一种明显无效的请求<br>下表显示每个响应码及其含义：<br>100 继续101 分组交换协200 OK201 被创建202 被采纳203 非授权信息204 无内容205 重置内容206 部分内容300 多选项301<br>永久地传送302 找到303 参见其他304 未改动305 使用代理307 暂时重定向400 错误请求401 未授权402 要求付费403 禁止404<br>未找到405 不允许的方法406 不被采纳407 要求代理授权408 请求超时409 冲突410 过期的411 要求的长度412 前提不成立413<br>请求实例太大414 请求URI太大415 不支持的媒体类型416 无法满足的请求范围417 失败的预期500 内部服务器错误501 未被使用502<br>网关错误503 不可用的服务504 网关超时505 HTTP版本未被支持</p>
<p>二、HTTP头标头标由主键/值对组成。它们描述客户端或者服务器的属性、被传输的资源以及应该实现连接。<br>四种不同类型的头标：<br>1.通用头标：即可用于请求，也可用于响应，是作为一个整体而不是特定资源与事务相关联。<br>2.请求头标：允许客户端传递关于自身的信息和希望的响应形式。<br>3.响应头标：服务器和于传递自身信息的响应。<br>4.实体头标：定义被传送资源的信息。即可用于请求，也可用于响应。<br>头标格式：&lt;name&gt;:&lt;value&gt;&lt;CRLF&gt;<br>下表描述在HTTP/1.1中用到的头标<br>Accept 定义客户端可以处理的媒体类型，按优先级排序；在一个以逗号为分隔的列表中，可以定义多种类型和使用通配符。例如：Accept:<br>image/jpeg,image/png,<em>/</em>Accept-Charset<br>定义客户端可以处理的字符集，按优先级排序；在一个以逗号为分隔的列表中，可以定义多种类型和使用通配符。例如：Accept-Charset:<br>iso-8859-1,*,utf-8<br>Accept-Encoding 定义客户端可以理解的编码机制。例如：Accept-Encoding:gzip,compress<br>Accept-Language 定义客户端乐于接受的自然语言列表。例如：Accept-Language: en,de<br>Accept-Ranges 一个响应头标，它允许服务器指明：将在给定的偏移和长度处，为资源组成部分的接受请求。该头标的值被理解为请求范围的度量单位<br>。例如Accept-Ranges: bytes或Accept-Ranges: none<br>Age 允许服务器规定自服务器生成该响应以来所经过的时间长度，以秒为单位。该头标主要用于缓存响应。例如：Age: 30<br>Allow 一个响应头标，它定义一个由位于请求URI中的次源所支持的HTTP方法列表。例如：Allow: GET,PUT<br>aUTHORIZATION 一个响应头标，用于定义访问一种资源所必需的授权（域和被编码的用户ID与口令）。例如：Authorization: Basic<br>YXV0aG9yOnBoaWw=<br>Cache-Control 一个用于定义缓存指令的通用头标。例如：Cache-Control: max-age=30<br>Connection 一个用于表明是否保存socket连接为开放的通用头标。例如：Connection: close或Connection: keep-<br>alive<br>Content-Base 一种定义基本URI的实体头标，为了在实体范围内解析相对URLs。如果没有定义Content-<br>Base头标解析相对URLs，使用Content- Location URI（存在且绝对）或使用URI请求。例如：Content-Base:</p>
<p>Content-Encoding 一种介质类型修饰符，标明一个实体是如何编码的。例如：Content-Encoding: zipContent-<br>Language 用于指定在输入流中数据的自然语言类型。例如：Content-Language: en<br>Content-Length 指定包含于请求或响应中数据的字节长度。例如：Content-Length:382<br>Content-Location 指定包含于请求或响应中的资源定位（URI）。如果是一绝。对URL它也作为被解析实体的相对URL的出发点。例如<br>：Content-Location: <a href="http://www.myweb.com/news" target="_blank" rel="external">http://www.myweb.com/news</a><br>Content-MD5 实体的一种MD5摘要，用作校验和。发送方和接受方都计算MD5摘要，接受方将其计算的值与此头标中传递的值进行比较。例如<br>：Content-MD5: &lt;base64 of 128 MD5 digest&gt;<br>Content-Range 随部分实体一同发送；标明被插入字节的低位与高位字节偏移，也标明此实体的总长度。例如：Content-Range:<br>1001-2000/5000<br>Contern-Type 标明发送或者接收的实体的MIME类型。例如：Content-Type: text/html<br>Date 发送HTTP消息的日期。例如：Date: Mon,10PR 18:42:51 GMT<br>ETag<br>一种实体头标，它向被发送的资源分派一个唯一的标识符。对于可以使用多种URL请求的资源，ETag可以用于确定实际被发送的资源是否为同一资源。例如：ETag:<br>‘208f-419e-30f8dc99’<br>Expires 指定实体的有效期。例如：Expires: Mon,05 Dec 2008 12:00:00 GMT<br>Form 一种请求头标，给定控制用户代理的人工用户的电子邮件地址。例如：From: webmaster@myweb.com<br>Host 被请求资源的主机名。对于使用HTTP/1.1的请求而言，此域是强制性的。例如：Host: www.myweb.com<br>If-Modified-Since<br>如果包含了GET请求，导致该请求条件性地依赖于资源上次修改日期。如果出现了此头标，并且自指定日期以来，此资源已被修改，应该反回一个304响应代码。例如<br>：If-Modified-Since: Mon,10PR 18:42:51 GMT<br>If-Match 如果包含于一个请求，指定一个或者多个实体标记。只发送其ETag与列表中标记区配的资源。例如：If-Match: ‘208f-419e-<br>308dc99’<br>If-None-Match 如果包含一个请求，指定一个或者多个实体标记。资源的ETag不与列表中的任何一个条件匹配，操作才执行。例如：If-None-<br>Match: ‘208f-419e-308dc99’<br>If-Range<br>指定资源的一个实体标记，客户端已经拥有此资源的一个拷贝。必须与Range头标一同使用。如果此实体自上次被客户端检索以来，还不曾修改过，那么服务器只发送指定的范围，否则它将发送整个资源。例如：Range:<br>byte=0-499&lt;CRLF&gt;If-Range:’208f-419e-30f8dc99’<br>If-Unmodified-Since 只有自指定的日期以来，被请求的实体还不曾被修改过，才会返回此实体。例如：If-Unmodified-<br>Since:Mon,10PR 18:42:51 GMT<br>Last-Modified 指定被请求资源上次被修改的日期和时间。例如：Last-Modified: Mon,10PR 18:42:51 GMT<br>Location<br>对于一个已经移动的资源，用于重定向请求者至另一个位置。与状态编码302（暂时移动）或者301（永久性移动）配合使用。例如：Location:<br><a href="http://www2.myweb.com/index.jsp" target="_blank" rel="external">http://www2.myweb.com/index.jsp</a><br>Max-Forwards<br>一个用于TRACE方法的请求头标，以指定代理或网关的最大数目，该请求通过网关才得以路由。在通过请求传递之前，代理或网关应该减少此数目。例如：Max-<br>Forwards: 3<br>Pragma 一个通用头标，它发送实现相关的信息。例如：Pragma: no-cache<br>Proxy-Authenticate 类似于WWW-Authenticate，便是有意请求只来自请求链（代理）的下一个服务器的认证。例如：Proxy-<br>Authenticate: Basic realm-admin<br>Proxy-Proxy-Authorization 类似于授权，但并非有意传递任何比在即时服务器链中更进一步的内容。例如：Proxy-Proxy-<br>Authorization: Basic YXV0aG9yOnBoaWw=<br>Public 列表显示服务器所支持的方法集。例如：Public: OPTIONS,MGET,MHEAD,GET,HEAD<br>Range 指定一种度量单位和一个部分被请求资源的偏移范围。例如：Range: bytes=206-5513<br>Refener 一种请求头标域，标明产生请求的初始资源。对于HTML表单，它包含此表单的Web页面的地址。例如：Refener:<br><a href="http://www.myweb.com/news/search.html" target="_blank" rel="external">http://www.myweb.com/news/search.html</a><br>Retry-After<br>一种响应头标域，由服务器与状态编码503（无法提供服务）配合发送，以标明再次请求之前应该等待多长时间。此时间即可以是一种日期，也可以是一种秒单位。例如<br>：Retry-After: 18<br>Server 一种标明Web服务器软件及其版本号的头标。例如：Server: Apache/2.0.46(Win32)<br>Transfer-Encoding 一种通用头标，标明对应被接受方反向的消息体实施变换的类型。例如：Transfer-Encoding: chunked<br>Upgrade 允许服务器指定一种新的协议或者新的协议版本，与响应编码101（切换协议）配合使用。例如：Upgrade: HTTP/2.0<br>User-Agent 定义用于产生请求的软件类型（典型的如Web浏览器）。例如：User-Agent: Mozilla/4.0(compatible;<br>MSIE 5.5; Windows NT; DigExt)<br>Vary 一个响应头标，用于表示使用服务器驱动的协商从可用的响应表示中选择响应实体。例如：Vary: *Via<br>一个包含所有中间主机和协议的通用头标，用于满足请求。例如：Via: 1.0 fred.com, 1.1 wilma.com<br>Warning 用于提供关于响应状态补充信息的响应头标。例如：Warning: 99 www.myweb.com Piano needs tuning<br>www-Authenticate 一个提示用户代理提供用户名和口令的响应头标，与状态编码401（未授权）配合使用。响应一个授权头标。例如：www-<br>Authenticate: Basic realm=zxm.mgmt</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[学习tornado：安全]]></title>
      <url>https://shijingjing07.github.io/2016/08/29/%E5%AD%A6%E4%B9%A0tornado%EF%BC%9A%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/siddontang/article/details/18053915" target="_blank" rel="external">http://blog.csdn.net/siddontang/article/details/18053915</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python tornado框架实现CRUD]]></title>
      <url>https://shijingjing07.github.io/2016/08/23/python%20tornado%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0CRUD/</url>
      <content type="html"><![CDATA[<p>1.本例采用postgresql数据库，创建数据表 user_tbl</p>
<pre><code>create table user_tbl(name varchar(20),signup_date date);
</code></pre><p>2.webapi接口</p>
<p>(1)tornado框架配置 t_tornado.py</p>
<pre><code>#-*- coding:UTF-8 -*-
import tornado.httpserver
import tornado.ioloop
import tornado.options
import tornado.web
from tornado.options import define,options
import t_url
import psycopg2
app=tornado.web.Application(t_url.url)
define(&quot;port&quot;,default=8000,help=&quot;run on port&quot;,type=int)
if __name__==&quot;__main__&quot;:
   tornado.options.parse_command_line()
   app.listen(options.port)
   tornado.ioloop.IOLoop.instance().start()
</code></pre><p>(2)路径映射 t_url.py</p>
<pre><code>from t_handler import *
url=[
(r&apos;/&apos;,IndexHandler),
(r&apos;/AddUser&apos;,AddHandler),
(r&apos;/EditUser&apos;,EditHandler),
(r&apos;/DelUser&apos;,DelHandler)
]
</code></pre><p>(3)处理类 t_handler.py</p>
<pre><code>from tornado.web import RequestHandler
from tornado.escape import json_decode,json_encode
import psycopg2

#解决js跨域请求问题
class BaseHandler(RequestHandler):
     def set_default_headers(self):
        self.set_header(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;)
        self.set_header(&apos;Access-Control-Allow-Methods&apos;, &apos;POST, GET, OPTIONS&apos;)
        self.set_header(&apos;Access-Control-Max-Age&apos;, 1000)
        self.set_header(&apos;Access-Control-Allow-Headers&apos;, &apos;*&apos;)
        self.set_header(&apos;Content-type&apos;, &apos;application/json&apos;)

#删除用户
class DelHandler(BaseHandler):
    def post(self):
        name=self.get_argument(&apos;name&apos;,None)
        result={}
        conn=psycopg2.connect(host=&apos;127.0.0.1&apos;,port=5432,user=&apos;leo&apos;,password=&apos;king&apos;,database=&apos;testdb&apos;)
        cursor=conn.cursor()
        try:
          sqlstr=&quot;delete from  user_tbl where name=&apos;%s&apos;&quot;%name
          cursor.execute(sqlstr)
        except(psycopg2.Warning,psycopg2.Error) as error:
          result[&quot;result&quot;]=&quot;DB Error:&quot;+error.message
          result[&quot;status&quot;]=&quot;false&quot;
          result[&quot;code&quot;]=300
          self.write(json_encode(result))
          conn.rollback()
          cursor.close()
          conn.close()
          return
        result[&quot;result&quot;]=&quot;success&quot;
        result[&quot;status&quot;]=&quot;true&quot;
        result[&quot;code&quot;]=200
        if(result[&quot;status&quot;]==&quot;true&quot;):
          conn.commit()
        cursor.close()
        conn.close()
        self.write(json_encode(result))

#修改用户  
class EditHandler(BaseHandler):
   def post(self):
      o_name=self.get_argument(&apos;o_name&apos;,None)
      name=self.get_argument(&apos;name&apos;,None)
      time=self.get_argument(&apos;time&apos;,None)
      result={}
      conn=psycopg2.connect(host=&apos;127.0.0.1&apos;,port=5432,user=&apos;leo&apos;,password=&apos;king&apos;,database=&apos;testdb&apos;)
      cursor=conn.cursor()
      try:
        sqlstr=&quot;update user_tbl set name=&apos;%s&apos;,signup_date=&apos;%s&apos; where name=&apos;%s&apos;&quot;%(name,time,o_name)
        cursor.execute(sqlstr)
      except(psycopg2.Warning,psycopg2.Error) as error:
        result[&quot;result&quot;]=&quot;DB Error:&quot;+error.message
        result[&quot;status&quot;]=&quot;false&quot;
        result[&quot;code&quot;]=300
        self.write(json_encode(result))
        conn.rollback()
        cursor.close()
        conn.close()
        return
      result[&quot;result&quot;]=&quot;success&quot;
      result[&quot;status&quot;]=&quot;true&quot;
      result[&quot;code&quot;]=200
      if(result[&quot;status&quot;]==&quot;true&quot;):
         conn.commit()
      cursor.close()
      conn.close()
      self.write(json_encode(result))

#新增用户
class AddHandler(BaseHandler):
    def post(self):
      time=self.get_argument(&apos;time&apos;,None)
      result={}
      conn=psycopg2.connect(host=&apos;127.0.0.1&apos;,port=5432,user=&apos;leo&apos;,password=&apos;king&apos;,database=&apos;testdb&apos;)
      cursor=conn.cursor()
      try:
        sqlstr=&quot;insert into user_tbl(name,signup_date) values(&apos;%s&apos;,&apos;%s&apos;)&quot;%(name,time)
        cursor.execute(sqlstr)
      except(psycopg2.Warning,psycopg2.Error) as error:
        result[&quot;result&quot;]=&quot;DB Error:&quot;+error.message
        result[&quot;status&quot;]=&quot;false&quot;
        result[&quot;code&quot;]=300
        self.write(json_encode(result))
        conn.rollback()
        cursor.close()
        conn.close()
        return
      result[&quot;result&quot;]=&quot;success&quot;
      result[&quot;status&quot;]=&quot;true&quot;
      result[&quot;code&quot;]=200
      if(result[&quot;status&quot;]==&quot;true&quot;):
         conn.commit()
      cursor.close()
      conn.close()
      self.write(json_encode(result)) 

class IndexHandler(BaseHandler):
   def get(self):
      conn=psycopg2.connect(host=&apos;127.0.0.1&apos;,port=5432,user=&apos;leo&apos;,password=&apos;king&apos;,database=&apos;testdb&apos;)
      cursor=conn.cursor()
      result={}
      try:
         sqlstr=&quot;select name,signup_date from user_tbl&quot;
         cursor.execute(sqlstr)
         if(cursor.rowcount==0):
            result[&quot;total&quot;]=0
            result[&quot;rows&quot;]=&quot;no data.&quot;
            result[&quot;status&quot;]=&quot;false&quot;
            result[&quot;code&quot;]=300
            self.write(json_encode(result))
            conn.close()
            return
         else:
            res=cursor.fetchall()
            content=[]
            t=1
            for item in res:
              tempItem={}
              tempItem[&quot;id&quot;]=t
              tempItem[&quot;name&quot;]=item[0]
              try:
                tempItem[&quot;signup_date&quot;]=item[1].strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)
              except:
                tempItem[&quot;signup_date&quot;]=&apos;&apos;
              t+=1
              content.append(tempItem)
            result[&quot;total&quot;]=1000
            result[&quot;rows&quot;]=content
            result[&quot;status&quot;]=&quot;true&quot;
            result[&quot;code&quot;]=200
      except(psycopg2.Warning,psycopg2.Error) as error:
         result[&quot;result&quot;]=&quot;DB error:&quot;+error.message
         result[&quot;status&quot;]=&quot;false&quot;
         result[&quot;code&quot;]=300
         self.write(json_encode(result))
         conn.rollback()
         conn.close()
         return
      if(result[&quot;status&quot;]==&quot;true&quot;):
        conn.commit()
      conn.close()
      print json_encode(result)
      self.write(json_encode(result)) 
</code></pre><p>3.html请求</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;script src=&quot;Scripts/jquery.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;     
    &lt;script src=&quot;Scripts/jquery.easyui.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;     
    &lt;link href=&quot;Css/easyui.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;   
    &lt;script type=&quot;text/javascript&quot;&gt;
    var o_name;
        var userUrl = &quot;http://127.0.0.1:8000&quot;;
        $(function () {
            initUser();
            $(&apos;#dri_grid&apos;).datagrid(&apos;load&apos;, userUrl);
            $(&quot;#dri_tools_add&quot;).click(function() {
        $(&quot;#n_name&quot;).val(&quot;&quot;);
        $(&quot;#n_time&quot;).val(&quot;&quot;);
        var a = document.getElementById(&apos;driver_add&apos;);
        a.href = &quot;javascript:driver_adddd()&quot;;
        $(&quot;#adduser&quot;).show();
        });
        $(&quot;#dri_tools_edit&quot;).click(function() {
                var row=$(&quot;#dri_grid&quot;).datagrid(&apos;getSelected&apos;);
                if(row){
                       var name = row.name;
               o_name = name;
                       var time = row.signup_date;
                       $(&quot;#n_name&quot;).val(name);
                       $(&quot;#n_time&quot;).val(time);
            var a = document.getElementById(&apos;driver_add&apos;);
            a.href = &quot;javascript:driver_editdd()&quot;;
                       $(&quot;adduser&quot;).show();
        }
        else{
            alert(&quot;please select&quot;);
        }
        $(&quot;#adduser&quot;).show();
        });
            $(&quot;#dri_tools_del&quot;).click(function() {
        var row = $(&apos;#dri_grid&apos;).datagrid(&apos;getSelected&apos;);
        if (row) {
            if(confirm(&quot;really delete?&quot;)){
            var t_name = row.name;
                var datas = {
                    name: t_name
                };
            var driver_delurl=&quot;http://127.0.0.1:8000/DelUser&quot;;
                $.post(driver_delurl, datas, function (v) {
                    if (v.status==&quot;true&quot;) {
                        $(&quot;#dri_grid&quot;).datagrid(&quot;reload&quot;);
                        alert(&quot;success&quot;);
                    } else {
                alert(&quot;error&quot;);
                    }
                });
            }
        } else {
            alert(&quot;please select&quot;);
        }
        });
        });
        function driver_adddd(){
        var n_name = $(&quot;#n_name&quot;).val();
        var n_time = $(&quot;#n_time&quot;).val(); 
        var userdata = {
                name: n_name,
                time: n_time
            };
                var driver_addurl=&quot;http://127.0.0.1:8000/AddUser&quot;;
        $.post(driver_addurl, userdata, function(s) {
            if (s.status == &quot;true&quot;) {
                $(&quot;#dri_grid&quot;).datagrid(&quot;reload&quot;);
                alert(&apos;新增成功&apos;);
            } else {
                    alert(s.result);
            }
        });
}
    function driver_editdd(){
        var n_name = $(&quot;#n_name&quot;).val();
        var n_time = $(&quot;#n_time&quot;).val(); 
        var userdata = {
                                o_name:o_name,
                name: n_name,
                time: n_time
            };
                var driver_addurl=&quot;http://127.0.0.1:8000/EditUser&quot;;
        $.post(driver_addurl, userdata, function(s) {
            if (s.status == &quot;true&quot;) {
                $(&quot;#dri_grid&quot;).datagrid(&quot;reload&quot;);
                alert(&apos;更新成功&apos;);
            } else {
                    alert(s.result);
            }
        });
    }
function initUser() {
            $(&apos;#dri_grid&apos;).datagrid({
                border: false,
                fit: true,
                singleSelect: true,
                method: &apos;get&apos;,
                pagination: true,
                striped: true,
                pageSize: 20,
                onBeforeLoad: function() {
                },
                columns: [
                    [{
                        field: &apos;name&apos;,
                        title: &apos;t_name&apos;,
                        width: &apos;8%&apos;,
                        align: &apos;center&apos;
                    }, {
                        field: &apos;signup_date&apos;,
                        title: &apos;t_signup_date&apos;,
                        width: &apos;14%&apos;,
                        align: &apos;center&apos;
                    }
                    ]
                ],
                onLoadSuccess: function(data) {
                }
            });
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt; 
&lt;span id=&quot;dri_tools_add&quot;&gt;
&lt;a href=&quot;#&quot; style=&quot;width: 100px&quot;&gt;新增&lt;/a&gt;
&lt;/span&gt;&amp;nbsp;&amp;nbsp;
&lt;span id=&quot;dri_tools_edit&quot;&gt;
&lt;a href=&quot;#&quot; style=&quot;width: 100px&quot;&gt;修改&lt;/a&gt;
&lt;/span&gt;&amp;nbsp;&amp;nbsp;
&lt;span id=&quot;dri_tools_del&quot;&gt;
&lt;a href=&quot;#&quot; style=&quot;width: 100px&quot;&gt;删除&lt;/a&gt;
&lt;/span&gt;
&lt;div id=&quot;adduser&quot; style=&quot;display:none;&quot;&gt;
&lt;table style=&quot;padding-left: 4%; padding-right: 4%&quot;&gt;
&lt;tr&gt;
    &lt;td&gt;
        &lt;span style=&quot;color: red&quot;&gt;*&lt;/span&gt;
        &lt;label&gt;姓名：&lt;/label&gt;
    &lt;/td&gt;
    &lt;td style=&quot;padding-right: 80px; padding-bottom: 5px;&quot;&gt;
        &lt;input id=&quot;n_name&quot; style=&quot;width:100px;&quot; type=&quot;text&quot;&gt;
    &lt;/td&gt;
    &lt;td&gt;
        &lt;label&gt;注册时间：&lt;/label&gt;
    &lt;/td&gt;
    &lt;td style=&quot;padding-bottom: 5px; width: 175px;&quot;&gt;
        &lt;input id=&quot;n_time&quot;  style=&quot;width:100px;&quot; type=&quot;text&quot;&gt;
    &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;div&gt;&lt;a id=&quot;driver_add&quot; class=&quot;easyui-linkbutton&quot; data-options=&quot;iconCls:&apos;icon-ok&apos;&quot; href=&quot;javascript:void(0)&quot; style=&quot;width: 120px&quot;&gt;提交&lt;/a&gt; &lt;/div&gt;
&lt;/div&gt;
 &lt;table id=&quot;dri_grid&quot;&gt;&lt;/table&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><p>4.浏览器显示结果：</p>
<p>(1)查询</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201608/300946-20160823152659964-1970116390.png" alt=""></p>
<p>(2)新增</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201608/300946-20160823152801542-733156144.png" alt=""></p>
<p>(3)修改</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201608/300946-20160823153017855-1556185775.png" alt=""></p>
<p>(4)删除</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201608/300946-20160823153134370-1494527675.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MyISAM 和InnoDB区别]]></title>
      <url>https://shijingjing07.github.io/2016/08/19/MyISAM%20%E5%92%8CInnoDB%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>MyISAM 和InnoDB 讲解</p>
<p>　　InnoDB和MyISAM是许多人在使用<a href="http://lib.csdn.net/base/14" title="undefined" target="_blank" rel="external">MySQL</a>时最常用的两个表类型，这两个表类型各有优劣，视具体应用而定。基本的差别为：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。</p>
<p>　　以下是一些细节和具体实现的差别：</p>
<p>　　◆1.InnoDB不支持FULLTEXT类型的索引。</p>
<p>　　◆2.InnoDB 中不保存表的具体行数，也就是说，执行select count(<em>) from<br>table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含<br>where条件时，两种表的操作是一样的。</p>
<p>　　◆3.对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</p>
<p>　　◆4.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。</p>
<p>　　◆5.LOAD TABLE FROM<br>MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</p>
<p>◆6.InnoDB支持数据行锁定，MyISAM不支持行锁定，只支持锁定整个表。即MyISAM同一个表上的读锁和写锁是互斥的，MyISAM并发读写时如果等待队列中既有读请求又有写请求，默认写请求的优先级高，即使读请求先到，所以MyISAM不适合于有大量查询和修改并存的情况，那样查询进程会长时间阻塞。因为MyISAM是锁表，所以某项读操作比较耗时会使其他写进程饿死。</p>
<p>　　另外，InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update<br>table set num=1 where name like “%aaa%”</p>
<p>　　<strong>两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁。</strong>而MyISAM不支持.所以MyISAM往往就容易被人认为只适合在小项目中使用。</p>
<p>作为使用MySQL的用户角度出发，Innodb和MyISAM都是比较喜欢的，如果数据库平台要达到需求：99.9%的稳定性，方便的扩展性和高可用性来说的话，MyISAM绝对是首选。</p>
<p>　　原因如下：</p>
<p>　　1、平台上承载的大部分项目是读多写少的项目，而MyISAM的读性能是比Innodb强不少的。</p>
<p>2、MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。</p>
<p>3、经常隔1，2个月就会发生应用开发人员不小心update一个表where写的范围不对，导致这个表没法正常用了，这个时候MyISAM的优越性就体现出来了，随便从当天拷贝的压缩包取出对应表的文件，随便放到一个数据库目录下，然后dump成sql再导回到主库，并把对应的binlog补上。如果是Innodb，恐怕不可能有这么快速度，别和我说让Innodb定期用导出xxx.sql机制备份，因为最小的一个数据库实例的数据量基本都是几十G大小。</p>
<p>　　4、从接触的应用逻辑来说，select count(*) 和order by<br>是最频繁的，大概能占了整个sql总语句的60%以上的操作，而这种操作Innodb其实也是会锁表的，很多人以为Innodb是行级锁，那个只是where对它主键是有效，非主键的都会锁全表的。</p>
<p>5、还有就是经常有很多应用部门需要我给他们定期某些表的数据，MyISAM的话很方便，只要发给他们对应那表的frm.MYD,MYI的文件，让他们自己在对应版本的数据库启动就行，而Innodb就需要导出xxx.sql了，因为光给别人文件，受字典数据文件的影响，对方是无法使用的。</p>
<p>6、如果和MyISAM比insert写操作的话，Innodb还达不到MyISAM的写性能，如果是针对基于索引的update操作，虽然MyISAM可能会逊色Innodb,但是那么高并发的写，从库能否追的上也是一个问题，还不如通过多实例分库分表架构来解决。</p>
<p>　　7、如果是用MyISAM的话，merge引擎可以大大加快应用部门的开发速度，他们只要对这个merge表做一些select<br>count(*)操作，非常适合大项目总量约几亿的rows某一类型(如日志，调查统计)的业务表。</p>
<p>　　当然Innodb也不是绝对不用，用事务的项目就用Innodb的。另外，可能有人会说你MyISAM无法抗太多写操作，但是可以通过架构来弥补。</p>
<p>转自：<a href="http://blog.csdn.net/xifeijian/article/details/20316775" target="_blank" rel="external">http://blog.csdn.net/xifeijian/article/details/20316775</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jQuery easyui datagrid数据绑定]]></title>
      <url>https://shijingjing07.github.io/2016/08/18/jQuery%20easyui%20datagrid%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
      <content type="html"><![CDATA[<p>1.绑定json数据</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;script src=&quot;Scripts/jquery.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;     
     &lt;script src=&quot;Scripts/jquery.easyui.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;     
     &lt;link href=&quot;Css/easyui.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;   
     &lt;script type=&quot;text/javascript&quot;&gt; 
         $(function () {      
             var json={&quot;total&quot;:28,&quot;rows&quot;:[
{&quot;productid&quot;:&quot;FI-SW-01&quot;,&quot;unitcost&quot;:10.00,&quot;status&quot;:&quot;P&quot;,&quot;listprice&quot;:36.50,&quot;attr1&quot;:&quot;Large&quot;,&quot;itemid&quot;:&quot;EST-1&quot;},
{&quot;productid&quot;:&quot;K9-DL-01&quot;,&quot;unitcost&quot;:12.00,&quot;status&quot;:&quot;P&quot;,&quot;listprice&quot;:18.50,&quot;attr1&quot;:&quot;Spotted Adult Female&quot;,&quot;itemid&quot;:&quot;EST-10&quot;},
{&quot;productid&quot;:&quot;RP-SN-01&quot;,&quot;unitcost&quot;:12.00,&quot;status&quot;:&quot;P&quot;,&quot;listprice&quot;:28.50,&quot;attr1&quot;:&quot;Venomless&quot;,&quot;itemid&quot;:&quot;EST-11&quot;},
{&quot;productid&quot;:&quot;RP-SN-01&quot;,&quot;unitcost&quot;:12.00,&quot;status&quot;:&quot;P&quot;,&quot;listprice&quot;:26.50,&quot;attr1&quot;:&quot;Rattleless&quot;,&quot;itemid&quot;:&quot;EST-12&quot;},
{&quot;productid&quot;:&quot;RP-LI-02&quot;,&quot;unitcost&quot;:12.00,&quot;status&quot;:&quot;P&quot;,&quot;listprice&quot;:35.50,&quot;attr1&quot;:&quot;Green Adult&quot;,&quot;itemid&quot;:&quot;EST-13&quot;},
{&quot;productid&quot;:&quot;FL-DSH-01&quot;,&quot;unitcost&quot;:12.00,&quot;status&quot;:&quot;P&quot;,&quot;listprice&quot;:158.50,&quot;attr1&quot;:&quot;Tailless&quot;,&quot;itemid&quot;:&quot;EST-14&quot;},
{&quot;productid&quot;:&quot;FL-DSH-01&quot;,&quot;unitcost&quot;:12.00,&quot;status&quot;:&quot;P&quot;,&quot;listprice&quot;:83.50,&quot;attr1&quot;:&quot;With tail&quot;,&quot;itemid&quot;:&quot;EST-15&quot;},
{&quot;productid&quot;:&quot;FL-DLH-02&quot;,&quot;unitcost&quot;:12.00,&quot;status&quot;:&quot;P&quot;,&quot;listprice&quot;:63.50,&quot;attr1&quot;:&quot;Adult Female&quot;,&quot;itemid&quot;:&quot;EST-16&quot;},
{&quot;productid&quot;:&quot;FL-DLH-02&quot;,&quot;unitcost&quot;:12.00,&quot;status&quot;:&quot;P&quot;,&quot;listprice&quot;:89.50,&quot;attr1&quot;:&quot;Adult Male&quot;,&quot;itemid&quot;:&quot;EST-17&quot;},
{&quot;productid&quot;:&quot;AV-CB-01&quot;,&quot;unitcost&quot;:92.00,&quot;status&quot;:&quot;P&quot;,&quot;listprice&quot;:63.50,&quot;attr1&quot;:&quot;Adult Male&quot;,&quot;itemid&quot;:&quot;EST-18&quot;}
             ]};
             $(&apos;#tbl&apos;).datagrid({
                 title: &apos;测试DataGrid&apos;,
                 width: 700,
                 height: &apos;auto&apos;,
                 fitColumns: true,
                 columns:[[
                 {field:&apos;itemid&apos;,title:&apos;Item ID&apos;,width:80},
                 {field:&apos;productid&apos;,title:&apos;Product ID&apos;,width:120},
                 {field:&apos;listprice&apos;,title:&apos;List Price&apos;,width:80,align:&apos;right&apos;},
                 {field:&apos;unitcost&apos;,title:&apos;Unit Cost&apos;,width:80,align:&apos;right&apos;},
                 {field:&apos;attr1&apos;,title:&apos;Attribute&apos;,width:250},
                 {field:&apos;status&apos;,title:&apos;Status&apos;,width:60,align:&apos;center&apos;}
                 ]]
             }).datagrid(&quot;loadData&quot;,json);
         });
     &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;table id=&quot;tbl&quot;&gt;     
    &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>浏览器显示结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201608/300946-20160818175001406-827948937.png" alt=""></p>
<p>2.查询后台数据，然后绑定</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;script src=&quot;Scripts/jquery.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;     
    &lt;script src=&quot;Scripts/jquery.easyui.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;     
    &lt;link href=&quot;Css/easyui.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;   
    &lt;script type=&quot;text/javascript&quot;&gt;
        var userUrl = &quot;http://127.0.0.1:9998/getUser&quot;;
        function initUser() {
            $(&apos;#dri_grid&apos;).datagrid({
                border: false,
                fit: true,
                singleSelect: true,
                method: &apos;get&apos;,
                pagination: true,
                striped: true,
                pageSize: 20,
                onBeforeLoad: function() {
                },
                columns: [
                    [{
                        field: &apos;id&apos;,
                        title: &apos;&amp;#12288;编号&apos;,
                        width: &apos;8%&apos;,
                        align: &apos;center&apos;
                    }, {
                        field: &apos;lasttimeonline&apos;,
                        title: &apos;&amp;#12288;最后登录时间&apos;,
                        width: &apos;14%&apos;,
                        align: &apos;center&apos;
                    }
                    ]
                ],
                onLoadSuccess: function(data) {
                }
            });
        }
        $(function () {
            initUser();
            $(&apos;#dri_grid&apos;).datagrid(&apos;load&apos;, userUrl);
        });
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;table id=&quot;dri_grid&quot;&gt;&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>浏览器显示结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201608/300946-20160818180125328-1201691621.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js调用百度地图API创建地图，搜索位置]]></title>
      <url>https://shijingjing07.github.io/2016/08/18/js%E8%B0%83%E7%94%A8%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BEAPI%E5%88%9B%E5%BB%BA%E5%9C%B0%E5%9B%BE%EF%BC%8C%E6%90%9C%E7%B4%A2%E4%BD%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>实现代码：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-store&quot; /&gt;
    &lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot; /&gt;
    &lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=e3ZohdqyB0RL98hFOiC29xqh&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
            function initMap(){
                createMap();//创建地图
                setMapEvent();//设置地图事件
            }
            //创建地图函数：
            function createMap(){
                var map = new BMap.Map(&quot;BaiduDitu&quot;);//在百度地图容器中创建一个地图
                map.centerAndZoom(&apos;上海&apos;,11);//设定地图的中心点和坐标并将地图显示在地图容器中
                window.map = map;//将map变量存储在全局
            }
            //地图事件设置函数：
            function setMapEvent(){
                map.enableDragging();//启用地图拖拽事件，默认启用(可不写)
                map.enableScrollWheelZoom();//启用地图滚轮放大缩小
                map.enableDoubleClickZoom();//启用鼠标双击放大，默认启用(可不写)
                map.enableKeyboard();//启用键盘上下左右键移动地图
            }
            $(function(){
                initMap();//创建和初始化地图
                createSearch();
                createAutocomlete();
                $(&quot;#s_p_search_btn&quot;).click(function () {
                    searchPlace($(&quot;#searchplace&quot;).val());
                });
            });
            function createSearch() {
                var map = window.map;
                var local = new BMap.LocalSearch(map,
                    {
                        renderOptions: { map: map, panel: &quot;searchlist&quot; }
                    });
                window.local = local;
            }
            //搜索
            function searchPlace(value) {
                window.local.search(value);
            }
            function createAutocomlete() {
                var map = window.map;
                var ac = new BMap.Autocomplete(    //建立一个自动完成的对象
                    {
                        &quot;input&quot;: &quot;searchplace&quot;,
                        &quot;location&quot;: map
                    });
                ac.addEventListener(&quot;onconfirm&quot;, function (e) {    //鼠标点击下拉列表后的事件
                    var _value = e.item.value;
                    var addr =_value.business+ _value.province + _value.city + _value.district + _value.street + _value.streetNumber ;
                    searchPlace(addr);
                });
            }
        &lt;/script&gt;
&lt;/head&gt;
&lt;body class=&quot;easyui-layout&quot;&gt;
     &lt;div class=&quot;Ditumap&quot;&gt;  
        &lt;div style=&quot;margin-bottom:10px;&quot;&gt;
            &lt;input id=&quot;searchplace&quot; style=&quot;width: 550px;&quot; class=&quot;easyui-textbox-simple&quot; placeholder=&quot;输入搜索关键字&quot; /&gt;
            &lt;a id=&quot;s_p_search_btn&quot; href=&quot;#&quot; class=&quot;easyui-linkbutton&quot; style=&quot;width: 80px;&quot; iconcls=&quot;icon-search&quot;&gt;搜索&lt;/a&gt;
        &lt;/div&gt;
        &lt;div id=&quot;searchlist&quot; style=&quot;width: 350px; height: 460px; margin-right:10px; float:left;&quot;&gt;&lt;/div&gt;
        &lt;div style=&quot;width:600px;height:460px;border:none; float:left;&quot; id=&quot;BaiduDitu&quot;&gt;&lt;/div&gt;
        &lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>浏览器显示结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201608/300946-20160818090005093-64399963.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python tornado框架使用]]></title>
      <url>https://shijingjing07.github.io/2016/08/12/python%20tornado%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>处理方法 t_handler.py</p>
<pre><code>from tornado.web import RequestHandler
class IndexHandler(RequestHandler):
   def get(self):
     name=self.get_argument(&apos;name&apos;,&apos;world&apos;)
     self.write(&apos;hello &apos;+name)

class AddHandler(RequestHandler):
  def get(self):
    val1=self.get_argument(&apos;val1&apos;,0)
    val2=self.get_argument(&apos;val2&apos;,0)
    val3=int(val1)+int(val2)
    self.write(str(val3))

class MinusHandler(RequestHandler):
  def get(self):
    val1=self.get_argument(&apos;val1&apos;,0)
    val2=self.get_argument(&apos;val2&apos;,0)
    val3=int(val1)-int(val2)
    self.write(str(val3))
</code></pre><p>Url路径，处理方法对应关系 t_url.py</p>
<pre><code>from t_handler import *
url=[
(r&apos;/&apos;,IndexHandler),
(r&apos;/page1&apos;,AddHandler),
(r&apos;/page2&apos;,MinusHandler)
]
</code></pre><p>启动进程 t_tornado.py</p>
<pre><code>tornado.options
import tornado.web
from tornado.options import define,options
import t_url
define(&quot;port&quot;,default=8000,help=&quot;run on port&quot;,type=int)

if __name__==&quot;__main__&quot;:
tornado.options.parse_command_line()

#初始化web框架
app=tornado.web.Application(t_url.url)
#开启端口监听服务
http_server=tornado.httpserver.HTTPServer(app)
http_server.listen(options.port)
#启动服务进程
tornado.ioloop.IOLoop.instance().start()
</code></pre><p><em>运行结果：</em></p>
<p><em><img src="http://images2015.cnblogs.com/blog/300946/201608/300946-20160812171637562-536504645.png" alt=""></em></p>
<p><em>浏览器访问结果：</em></p>
<p><em><img src="http://images2015.cnblogs.com/blog/300946/201608/300946-20160812171703843-2097541928.png" alt=""></em></p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201608/300946-20160812171717656-1610577565.png" alt=""></p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201608/300946-20160812171727015-490108431.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python数据库连接池]]></title>
      <url>https://shijingjing07.github.io/2016/08/12/python%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
      <content type="html"><![CDATA[<pre><code>python数据库连接池


import psycopg2
import psycopg2.pool
dbpool=psycopg2.pool.PersistentConnectionPool(1,1,dbname=&apos;postgis&apos;,user=&apos;postgres&apos;,host=&apos;127.0.0.1&apos;,password=&apos;1&apos;,port=&apos;5432&apos;)
conn=dbpool.getconn()
cursor=conn.cursor()
sqlstr=&quot;select name,type,state from wy&quot;
cursor.execute(sqlstr)
rows=cursor.fetchall()
for row in rows:
   print &quot;name&quot;,row[0]
   print &quot;type&quot;,row[1]
   print &quot;state&quot;,row[2]
   print &quot;***&quot;
dbpool.putconn(conn)
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python操作数据库]]></title>
      <url>https://shijingjing07.github.io/2016/08/12/python%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>psycopg查询</p>
<pre><code>#coding:utf-8
import psycopg2
conn=psycopg2.connect(host=&apos;127.0.0.1&apos;,port=5432,user=&apos;postgres&apos;,password=&apos;1&apos;,database=&apos;postgis&apos;)
print &quot;opened db successfully&quot;
cursor=conn.cursor()
cursor.execute(&quot;select name,type,state from wy&quot;)
rows=cursor.fetchall()
for row in rows:
   print &quot;name:&quot;,row[0]
   print &quot;type:&quot;,row[1]
   print &quot;state:&quot;,row[2]
   print &quot;*****&quot;
print &quot;Records select successfully&quot;;
conn.close()
</code></pre><p>psycopg插入</p>
<pre><code>#coding:utf-8
import psycopg2
conn=psycopg2.connect(host=&apos;127.0.0.1&apos;,port=5432,user=&apos;postgres&apos;,password=&apos;1&apos;&apos;,database=&apos;postgis&apos;)
print &quot;opened db successfully&quot;
cursor=conn.cursor()
cursor.execute(&quot;insert into wy(mid,name,psw,type,state,creat_time) \
values(&apos;7762cc64-5de1-11e6-ba75-000c2923b59f&apos;,&apos;admin2&apos;,&apos;1&apos;,&apos;测试组&apos;,&apos;1&apos;,CURRENT_TIMESTAMP)&quot;)
conn.commit()
print &quot;Records created successfully&quot;;
conn.close()
</code></pre><p>psycopg修改</p>
<pre><code>#coding:utf-8
import psycopg2
conn=psycopg2.connect(host=&apos;127.0.0.1&apos;,port=5432,user=&apos;postgres&apos;,password=&apos;1&apos;,database=&apos;postgis&apos;)
print &quot;opened db successfully&quot;
cursor=conn.cursor()
cursor.execute(&quot;update wy set type=&apos;UI组&apos; where name=&apos;admin2&apos;&quot;)
conn.commit()
print &quot;Total number of rows updated:&quot;,cursor.rowcount
cursor.execute(&quot;select name,type,state from wy&quot;)
rows=cursor.fetchall()
for row in rows:
print &quot;name:&quot;,row[0]
print &quot;type:&quot;,row[1]
print &quot;state:&quot;,row[2]
print &quot;*******&quot;
print &quot;done&quot;;
conn.close()
</code></pre><p>psycopg删除</p>
<pre><code>#coding:utf-8
import psycopg2
conn=psycopg2.connect(host=&apos;127。0.0.1&apos;,port=5432,user=&apos;postgres&apos;,password=&apos;1&apos;,database=&apos;postgis&apos;)
print &quot;opened db successfully&quot;
cursor=conn.cursor()
cursor.execute(&quot;delete from wy where name=&apos;admin2&apos;&quot;)
conn.commit()
print &quot;Total number of rows updated:&quot;,cursor.rowcount
cursor.execute(&quot;select name,type,state from wy&quot;)
rows=cursor.fetchall()
for row in rows:
   print &quot;name:&quot;,row[0]
   print &quot;type:&quot;,row[1]
   print &quot;state:&quot;,row[2]
   print &quot;*******&quot;
print &quot;done&quot;;
conn.close()   
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python三种数据库连接池方式]]></title>
      <url>https://shijingjing07.github.io/2016/08/12/python%E4%B8%89%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>#<br>[<code>psycopg2.pool</code>](<a href="http://students.mimuw.edu.pl/~jd334392/project/psycopg2-2.5.2/doc/html/pool.html" target="_blank" rel="external">http://students.mimuw.edu.pl/~jd334392/project/psycopg2-2.5.2/doc/html/pool.html</a></p>
<p>#module-psycopg2.pool “psycopg2.pool” ) - Connections pooling</p>
<p>Creating new PostgreSQL connections can be an expensive operation. This module<br>offers a few pure Python classes implementing simple connection pooling<br>directly in the client application.</p>
<p><em>class </em><code>psycopg2.pool.``AbstractConnectionPool</code>(<em>minconn</em>, <em>maxconn</em>,<br><em>*args</em>, <em>**kwargs</em>)</p>
<p>Base class implementing generic key-based pooling code.</p>
<p>New <em>minconn</em> connections are created automatically. The pool will support a<br>maximum of about <em>maxconn</em> connections. <em>*args</em> and _**kwargs_are passed to<br>the<br><a href="http://students.mimuw.edu.pl/~jd334392/project/psycopg2-2.5.2/doc/html/module.html#psycopg2.connect" title="psycopg2.connect" target="_blank" rel="external"><code>connect()</code></a> function.</p>
<p>The following methods are expected to be implemented by subclasses:</p>
<p><code>getconn</code>(<em>key=None</em>)</p>
<p>Get a free connection and assign it to <em>key</em> if not <code>None</code>.</p>
<p><code>putconn</code>(<em>conn</em>, <em>key=None</em>, <em>close=False</em>)</p>
<p>Put away a connection.</p>
<p>If <em>close</em> is <code>True</code>, discard the connection from the pool.</p>
<p><code>closeall</code>()</p>
<p>Close all the connections handled by the pool.</p>
<p>Note that all the connections are closed, including ones eventually in use by<br>the application.</p>
<p>The following classes are<br><a href="http://students.mimuw.edu.pl/~jd334392/project/psycopg2-2.5.2/doc/html/pool.html#psycopg2.pool.AbstractConnectionPool" title="psycopg2.pool.AbstractConnectionPool" target="_blank" rel="external"><code>AbstractConnectionPool</code></a> subclasses ready to be used.</p>
<p><em>class </em><code>psycopg2.pool.``SimpleConnectionPool</code>(<em>minconn</em>, <em>maxconn</em>, <em>*args</em>,<br><em>**kwargs</em>)</p>
<p>A connection pool that can’t be shared across different threads.</p>
<p>Note</p>
<p>This pool class is useful only for single-threaded applications.</p>
<p><em>class </em><code>psycopg2.pool.``ThreadedConnectionPool</code>(<em>minconn</em>, <em>maxconn</em>,<br><em>*args</em>, <em>**kwargs</em>)</p>
<p>A connection pool that works with the threading module.</p>
<p>Note</p>
<p>This pool class can be safely used in multi-threaded applications.</p>
<p><em>class </em><code>psycopg2.pool.``PersistentConnectionPool</code>(<em>minconn</em>, <em>maxconn</em>,<br><em>*args</em>, <em>**kwargs</em>)</p>
<p>A pool that assigns persistent connections to different threads.</p>
<p>Note that this connection pool generates by itself the required keys using the<br>current thread id. This means that until a thread puts away a connection it<br>will always get the same connection object by successive <code>getconn()</code> calls.<br>This also means that a thread can’t use more than one single connection from<br>the pool.</p>
<p>Note</p>
<p>This pool class is mostly designed to interact with Zope and probably not<br>useful in generic applications.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[20 款超棒免费的 Bootstrap 管理和前端模板]]></title>
      <url>https://shijingjing07.github.io/2016/08/12/20%20%E6%AC%BE%E8%B6%85%E6%A3%92%E5%85%8D%E8%B4%B9%E7%9A%84%20Bootstrap%20%E7%AE%A1%E7%90%86%E5%92%8C%E5%89%8D%E7%AB%AF%E6%A8%A1%E6%9D%BF/</url>
      <content type="html"><![CDATA[<p><a href="http://www.oschina.net/news/62506/20-best-free-bootstrap-admin-and-frontend-" target="_blank" rel="external">http://www.oschina.net/news/62506/20-best-free-bootstrap-admin-and-frontend-</a><br>templates-2015</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[解析ASP.NET WebForm和Mvc开发的区别]]></title>
      <url>https://shijingjing07.github.io/2016/08/12/%E8%A7%A3%E6%9E%90ASP.NET%20WebForm%E5%92%8CMvc%E5%BC%80%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="解析ASP-NET"><a href="#解析ASP-NET" class="headerlink" title="[解析ASP.NET"></a>[解析ASP.NET</h1><p>WebForm和Mvc开发的区别](<a href="http://blog.csdn.net/yisuowushinian/article/details/17646121" target="_blank" rel="external">http://blog.csdn.net/yisuowushinian/article/details/17646121</a>)</p>
<p>2013-12-29 01:59 30052人阅读<br><a href="http://blog.csdn.net/yisuowushinian/article/details/17646121#comments" target="_blank" rel="external">评论</a>(9)<br>收藏 <a href="http://blog.csdn.net/yisuowushinian/article/details/17646121#report" title="举报" target="_blank" rel="external">举报</a></p>
<p><img src="http://static.blog.csdn.net/images/category_icon.jpg" alt=""> 分类：</p>
<p>ASP.NET（14） <img src="http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg" alt=""></p>
<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>
<p>因为以前主要是做WebFrom开发，对MVC开发并没有太深入的了解。自从来到创新工场的新团队后，用的技术都是自己以前没有接触过的，比如：MVC<br>和EF还有就是WCF，压力一直很大。在很多问题都是不清楚的情况下，问周围的人，别人也只是给自己讲一个大概。而且前两天因为问了一个比较细的问题，还被别人的一句话打击。”我只能告诉你方法，你还指望我手把手的交给你呀，不会你得自己学呀。。。”。没办法只能自己找时间在下面找一些资料学习。</p>
<p>在初步了解MVC后，发现很多人对于MVC和三层架构开发概念上会有很大的混淆，所以把这两天的学习笔记整理一下，分享给自己的同学们。同时也做一个小Demo，让没有接触过MVC开发的同学，能对MVC有一个简单的了解。</p>
<p><strong>一，MVC和三层架构的区别</strong></p>
<p><strong>①什么是三层架构？</strong></p>
<p>在学校的时候，和同学或者老师一起讨论MVC的时候，别人可能会说，”不就是三层架构嘛！实体层（Model）,用来创建对象的实体；业务逻辑层（BLL），用来处理复杂的数据间的关系或者是业务间的关系；数据库访问层（DAL），用来用来访问数据库的；当然还会有，View(视图层)，用来展示数据；”其实自己虽然知道不是这样，但是自己也仅仅是了解一点点，也解释不清楚，所以也就算了。（具体的三层架构之间的操作的关系可以看我以前的博客<a href="http://www.cnblogs.com/qq731109249/archive/2013/01/16/2863201.html" target="_blank" rel="external">【ASP.NET开发】.NET三层架构简单解析</a>）。</p>
<p>它们之间互相操作的关系，基本的示意图如下：</p>
<p><img src="http://images.cnitblog.com/blog/326954/201312/28154532-06f0467013af44f7bd6afa207eaf9967.jpg" alt=""></p>
<p>还记的暑假在郑州找实习工作的时候，被别人问过一个n层架构的概念，当时就懵了，尼玛的压根就没听说过啊！不过后来查询资料知道，所谓的n曾架构就是根据系统的需要把业务逻辑层（BLL）或者数据库访问层（DAL）再抽象成几个层次（具体的就是再抽象成类），便于逻辑的处理和代码模块的维护。其基本原理还是基于三层架构。</p>
<p><strong>②什么是MVC呢？</strong></p>
<p>MVC其实是软件架构的一种模式，也就是我们经常说的设计模式。其中主要包括三个模块，就是如MVC名字所显示的那样：模型（Model），视图（View），控制器（Controller）；</p>
<p>其中这里的模型（Model）和视图（View ）是完全区别于三层架构中的模型（Model）和视图（View）的。</p>
<p><strong>1）MVC中的模型（Model）指的是数据模型，</strong>用于封装与应用程序的业务逻辑相关的数据，除此之外还可以封装数据的处理方法（相当于业务逻辑）。这是完全区别于三层架构的模型层（Model）的。</p>
<p>MVC中模型（Model）的特点：</p>
<p>①有对数据直接访问的权利，如：对数据库的访问；</p>
<p>②模型（Model）”不依赖”视图（View）和控制器（Controller），即模型（Model）不关心它会被如何显示或者如何被操作；</p>
<p>③模型（Model）中数据的变化一般会通过一种刷新机制被”公布”；</p>
<p>④为了实现③中的”机制”用于监视此模型的视图必须事先在此模型上注册。从而，视图可以了解在数据模型上发生的改变。</p>
<p><strong>2）视图（View），</strong>这里的视图基本跟三层中的视图一样，都是为了显示数据，没有程序上的逻辑。为了实现视图上数据的刷新，视图（View）需要访问它监视的模型（Model），所以应该事先在被它监视的数据那里进行注册。</p>
<p><strong>3）控制器（Controller），</strong>这个概念是在三层中不存在的概念。它主要起到不同层面的组织作用，用于控制应用程序的流程。主要处理事件并作出相应。”事件”主要包括：用户的行为和数据的改变。</p>
<p>以上就是关于三层架构和MVC在概念上的区别。</p>
<p><strong>二，WebForm网站和MVC网站运行机制的区别</strong></p>
<p><strong>①WebForm网站的运行机制</strong></p>
<p>比如说我们现在要访问一个WebForm站点：<a href="http://www.google.com.hk/Default.aspx" target="_blank" rel="external">www.google.com.hk/Default.aspx</a>(仅仅是示例)。我们的浏览器和服务器都是做了哪些动作呢？</p>
<p><strong>1）首先浏览器会向目的服务器发送请求报文。</strong></p>
<p>配置过IIS的都知道，网站挂载在服务器上，我们是通过访问虚拟目录的方式访问网站的。这时候目的主机的IIS接收的是访问该虚拟目录下Default.aspx文件的请求；（当然这也是一个非常复杂的过程，包括请求DNS服务器，找到目的主机IP，根据IP地址访问目的主机。复杂的网络过程就不叙述，有兴趣的自己找资料学习）；</p>
<p><strong>2）服务器端的IIS软件接收到请求后，把请求交给.NET FramWork进行处理；</strong></p>
<p><strong>3）.NET FramWork会创建Default_aspx类的对象，也就是我们所说的页面对象。</strong>（在WebFrom网站创建完，并且编译后Default.aspx会被编译成Default_aspx类）</p>
<p>到现在的整个过程都还是Http请求，IIS的内部机制会去实现一个IHttphandler的接口，其中该接口实现一个ProcessRequestfang方法</p>
<p>MSDN是这样解释的</p>
<p><img src="http://images.cnitblog.com/blog/326954/201312/28164236-c40457a9a6f74c5c8cbbe0b5cf7d8345.png" alt=""></p>
<p>该ProcessRequest（）方法会去调用对应页面的Page_Load（） 方法</p>
<pre><code>1 protected void Page_Load(object sender, EventArgs e)
2         {
3             //处理的业务逻辑或者是访问数据库的代码
4             //要输出的Html或者其它内容
5         }
</code></pre><p><strong>4）返回给浏览器（包括Html，CSS，Js等等）</strong></p>
<p>流程示意图如下：</p>
<p><img src="http://images.cnitblog.com/blog/326954/201312/28171603-3e50320974b54e989b9fb7eb44875f41.png" alt=""></p>
<p><strong>②MVC网站的运行机制</strong></p>
<p>还比如说我们现在要访问一个MVC站点：<a href="http://www.google.com.hk/Firstpage/Default" target="_blank" rel="external">www.google.com.hk/FirstPage/Default</a>(仅仅是示例)。我们的浏览器和服务器又做了哪些动作呢？</p>
<p><strong>1)浏览器向服务器发送Request请求报文（FirstPage/Default）</strong></p>
<p><strong>2)服务器端的IIS相应Request请求</strong></p>
<p><strong>3）.NET FramWork根据路由配置，解析URL，并创建FirstPage类的对象，并调用相应的Default方法</strong></p>
<pre><code>1 public ActionResult Default()
2         {
3 
4                 return View();//返回给视图
5         }
</code></pre><p><strong>4)然后会访问视图文件夹下的Default.cshtml，返回给浏览器（其中包括html,css,js等等）</strong></p>
<p>流程的示意图如下：</p>
<p><img src="http://images.cnitblog.com/blog/326954/201312/28230241-4d392722e2aa42c9b7de2c6dd9dde349.png" alt=""></p>
<p>这只是一个比较简单的运行过程。其实在这过程中发生了很多事情，比如说：执行Global.asax中的Application_Start()方法来完成一些初始化的工作等等，会在以后的文章中继续解析。</p>
<p>以上就是WebForm网站和MVC网站运行机制的区别。</p>
<p><strong>那么到底使用MVC的优点比WebForm到底有哪些优点呢？</strong></p>
<p>①最重要的就是.NET程序员在开发的时候再也不会使用那些被很多人诟病的微软封装的控件了。</p>
<p>②MVC设计模式降低了模型（Model,业务和数据）和视图的耦合关系。包括我们在开发WebForm网站使用三层架构的思想也是为了降低数据和视图的耦合等；</p>
<p>③可以复用视图，也就是说同样的数据可以使用不同的视图以不同的图标展示出来。</p>
<p>-——————————————————理论到此结束—————————————————————</p>
<p>常用的WebForm开发方式就不举例了，我下边主要演示一个基本的MVC程序的创建和运行过程。</p>
<p>要创建MVC程序VS肯定是必不可少的，我的开发环境是VS2013，大家请酌情考虑自己的VS版本。</p>
<p><strong>①首先的打开”文件”-&gt;”新建项目”，在左侧的项目栏选择”Visual C#”-&gt;”Web”,在右边就可以看到有”ASP.NET Web窗体应用程序”和”ASP.NET MVC 4 Web应用程序”如下图：</strong></p>
<p><img src="http://images.cnitblog.com/blog/326954/201312/28233447-de089ae275ee417e9a6ba6578a08a8d3.png" alt=""></p>
<p><strong>②因为要创建MVC程序就选择点击第二个选项然后会看到项目模板，默认的是选择”Internet应用程序”，如果选择默认的话，就会默认的创建一个具有基本功能的站点。我们这里选择”基本”，VS只会创建包含基本框架简的模板</strong></p>
<p><img src="http://images.cnitblog.com/blog/326954/201312/28234400-1f0ba90fdb514ed88fd2dd1da09eb242.png" alt=""></p>
<p><strong>③创建完以后我们会在解决方案下看到代码的树状结构，其中包含Models,Views和Controllers三个文件夹</strong></p>
<p><img src="http://images.cnitblog.com/blog/326954/201312/29004448-3560b6dd86184a7689b6864989d8faed.png" alt=""></p>
<p><strong>④我们首先创建实体对象Model，在Models文件夹下创建一个Child类，并声明属性和初始化</strong></p>
<p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<pre><code> 1     public class Child
 2     {
 3         //编号
 4         private int id;
 5 
 6         
 7         public int Id
 8         {
 9             get { return id; }
10             set { id = value; }
11         }
12 
13         //姓名
14         private string strName;
15 
16         public string StrName
17         {
18             get { return strName; }
19             set { strName = value; }
20         }
21 
22     }
</code></pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>⑤在Controllers文件夹上右键，”添加”，会看到有”控制器”的选项，如下图：</strong></p>
<p><img src="http://images.cnitblog.com/blog/326954/201312/29005103-e859cfa5a8d2472e9cd74b77a5b4fd84.png" alt=""></p>
<p>点击”控制器”后会出现一个”添加控制器”窗体，在控制器名称中”Default1Controller”中”Default1”是默认选中的，我们修改其名称为”HomeController”，</p>
<p><img src="http://images.cnitblog.com/blog/326954/201312/29010113-dde65162b975441cb60edc946e06a1ec.png" alt=""></p>
<p>注意：这里的”Default1Controller”中的”*Controller”是必须保留的，主要是因为MVC框架有一个”约定大于配置”的规则</p>
<p>单击”添加”添加控制器，默认生成的控制器代码，如下：</p>
<p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<pre><code> 1     //默认生成的控制器代码
 2     public class HomeController : Controller
 3     {
 4         //
 5         // GET: /Home/
 6 
 7         //包含一个Action方法
 8         public ActionResult Index()
 9         {
10             //返回给视图
11             return View();
12         }
13 
14     }
</code></pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>⑥然后我们创建一个集合来初始化在Models中创建的Child类的属性值</strong></p>
<p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<pre><code> 1 #region 初始化数据集合 +List InitData()
 2         /// &lt;summary&gt;
 3         /// 初始化数据集合
 4         /// &lt;/summary&gt;
 5         /// &lt;returns&gt;&lt;/returns&gt;
 6         public List&lt;Models.Child&gt; InitData()
 7         {
 8 
 9             List&lt;Models.Child&gt; list = new List&lt;Models.Child&gt;()
10             {
11                 new Child(){Id=1,StrName=&quot;你好啊！&quot;},
12                 new Child(){Id=2,StrName=&quot;不好啊！&quot;}
13             };
14 
15             return list;
16         }
17 
18         #endregion
</code></pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>然后开始编写Action方法，即”ActionResult Index()”方法，</p>
<p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<pre><code> 1 /// &lt;summary&gt;
 2         /// Action方法（相当于MVC设计模式的Model）
 3         /// &lt;/summary&gt;
 4         /// &lt;returns&gt;&lt;/returns&gt;
 5 
 6         public ActionResult Index()
 7         {
 8             //可以处理当前业务（你比如读取数据库，判断等）
 9             StringBuilder strBuilder = new StringBuilder();
10             //创建数据集合，获取数据
11             List&lt;Models.Child&gt; list = InitData();
12             //遍历集合获取生成的Html代码
13             list.ForEach(d =&gt;
14             {
15                 strBuilder.AppendLine(&quot;&lt;div&gt;&quot; + d.Id.ToString() + &quot;&lt;/div&gt;&quot;);
16             });
17 
18             //使用ViewBag传输数据给同名的Indexcshtml视图
19             //ViewBag是一个dynamic类型的集合，可以动态添加任意类型的任意名称和属性
20             ViewBag.HtmlStrBuilder = strBuilder.ToString();
21             //加载同名视图Index.cshtml
22             return View();
23         }
</code></pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>在其中我们使用ViewBag把数据传输给同名的Views文件夹下的同名视图。</p>
<p><strong>⑦创建视图接收数据，上面代码的Index方法上右键，会出现”添加视图”，如下图</strong></p>
<p><img src="http://images.cnitblog.com/blog/326954/201312/29011655-2fc1d2e298d641588ff9a949c044065b.png" alt=""></p>
<p> 之后会在Views文件夹下，生成一个Home文件夹，Home文件夹下面会有一个Index.cshtml文件(这个就是视图文件)</p>
<p><strong> ⑧视图接收数据</strong></p>
<p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<pre><code> 1 &lt;html&gt;
 2 &lt;head&gt;
 3     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&gt;
 4     &lt;title&gt;Index&lt;/title&gt;
 5 &lt;/head&gt;
 6 &lt;body&gt;
 7     &lt;div&gt;
 8        &lt;!---------相当于把Action方法中保存的内容输出---------&gt;
 9        @Html.Raw( @ViewBag.HtmlStrBuilder)
10     &lt;/div&gt;
11 &lt;/body&gt;
12 &lt;/html&gt;
</code></pre><p><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>到这里基本上就完成了一个MVC程序的创建，我们运行程序，结果如下：</p>
<p><img src="http://images.cnitblog.com/blog/326954/201312/29013232-fd960f9fb9a74d639c9e5cbd76b5a330.png" alt=""><br>注意：因为MVC的运行机制跟WebForm不一样，所以浏览的方式也不一样。我们可以直接在Views文件夹上右键，选择在浏览器中查看就可以预览到结果。</p>
<p>-—————————————-分割线——————————————-</p>
<p>到这里，关于ASP.NET WebForm和Mvc开发的区别和基本MVC程序的创建过程已经完成。</p>
<p>下次我会做的是使用EF（Entity<br>FramWork），来操作数据库（抛开WebForm中的ADO.NET），实现一个MVC小网站程序的创建。请大家继续关注！</p>
<p>如果在文章中出现错误，欢迎大家留言指正。我会虚心接受大家的意见。</p>
<p>转自：<a href="http://blog.csdn.net/yisuowushinian/article/details/17646121" target="_blank" rel="external">http://blog.csdn.net/yisuowushinian/article/details/17646121</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python编程规范(PEP8)]]></title>
      <url>https://shijingjing07.github.io/2016/08/10/Python%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83(PEP8)/</url>
      <content type="html"><![CDATA[<h1 id="Python编程规范-PEP8"><a href="#Python编程规范-PEP8" class="headerlink" title="Python编程规范(PEP8)"></a>Python编程规范(PEP8)</h1><h3 id="代码布局"><a href="#代码布局" class="headerlink" title="代码布局"></a>代码布局</h3><h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>对于每一次缩进使用4个空格。使用括号、中括号、大括号进行垂直对齐，或者缩进对齐。</p>
<h4 id="制表符还是空格"><a href="#制表符还是空格" class="headerlink" title="制表符还是空格?"></a>制表符还是空格?</h4><p>永远不要将制表符与空格混合使用。Python最常用的缩进方式是只是用空格。</p>
<p>当调用Python命令行的 -t 选项时，它会检测并警告代码非法混合使用制表符和空格。当使用 -tt 选项时，警告变成了错误。</p>
<h4 id="最大行长度"><a href="#最大行长度" class="headerlink" title="最大行长度"></a>最大行长度</h4><p>限制所有行最长为79个字符。</p>
<p>使用反斜杠来分行是一个很好的选择。</p>
<p>我们应当选择在二元操作符之后进行分行，而不是之前。</p>
<h4 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h4><p>使用两行空行来分隔顶层函数和类定义。</p>
<p>使用单行空行来分隔类方法定义。</p>
<p>在函数中使用空行来表示不同的逻辑块。</p>
<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>Python核心发行代码里面优先使用ASCII码或Latin-1编码。3.0后UTF-8编码优先于Latin-1。</p>
<h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>每一个导入通常应当使用单独的行。</p>
<p>导入应当位于文件顶部，在模块注释和文档字符串之后，在全局变量和常量之前。</p>
<p>导入应当按以下顺序分组，且每组导入之间使用空行隔开：</p>
<p>1、标准库导入</p>
<p>2、第三方库导入</p>
<p>3、本地应用程序/定制库导入</p>
<p>使用绝对包路径导入。</p>
<p>表达式和语句中的空格</p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>误导的注释不如没有注释</p>
<p>注释应当为完整的句子，且句号结尾的句子后面应当有2个空格。如果注释很短，那么结尾的句号可以忽略。</p>
<h4 id="块注释"><a href="#块注释" class="headerlink" title="块注释"></a>块注释</h4><p>块注释应当和代码缩进保持一致。每行注释开头应以#开头，然后紧跟一个空格。</p>
<h4 id="行注释"><a href="#行注释" class="headerlink" title="行注释"></a>行注释</h4><p>行注释至少和语句间隔2个空格。同样的注释应当以#开头，然后紧跟一个空格。</p>
<h4 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h4><p>对于所有的公有模块、类、函数和方法都需要编写文档字符串。</p>
<p>“”” 作为多行的文档字符串的结束，应该单独一行，并且之前有一个空行。</p>
<p>对于只有一行的文档字符串来说，结尾的 “”” 在同一行。</p>
<p>更详细的文档字符串规范见 PEP 257。</p>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>目前Python库的命名规范尚未达成一致，但有一些推荐的标准。</p>
<p>在Python里面，有一些具有特定意义的下划线前缀或者后继的特殊格式。如：</p>
<p>1、_single_leading_underscore：（单下划线开始）弱”内部使用”指示器。例如：from M import *<br>不会导入以下划线开始的对象。</p>
<p>2、single_trailing<em>underscore</em>：（单下划线结束）规定使用其来避免与Python关键字冲突，例如：</p>
<p>Tkinter.Toplevel(master, class_=’ClassName’) 在参数class后面加单下划线，避免与关键字class冲突</p>
<p>3、<strong>double_leading_underscore：（双下划线开始）命名一个类的属性时，调用”name<br>mangling”（类FooBar中，</strong>boo 变为了 _FooBar__boo; 见下文）</p>
<p>4、<strong>double_leading_and_trailing_underscore</strong>：（双下划线开始和结束）存活在用户控制命名空间的”magic”对象或属性。<br>例如<strong>init</strong>, <strong>import</strong> 或 <strong>file</strong>。永远不要起这样的名字。</p>
<h4 id="避免使用的命名"><a href="#避免使用的命名" class="headerlink" title="避免使用的命名"></a>避免使用的命名</h4><p>不要使用小写的L、大写的O、以及大写的I作为单字符变量名。</p>
<h4 id="包与模块名称"><a href="#包与模块名称" class="headerlink" title="包与模块名称"></a>包与模块名称</h4><p>模块应当使用简短、全小写的名字，也可使用下划线连接来提高可读性。</p>
<p>包也应当使用简短、全小写的名字，但不要使用下划线。</p>
<p>这是由于模块名与文件名关联，而在某些文件系统中大小写不敏感，且会截断过长的名字。</p>
<p>当使用C/C++来编写一个扩展模块时，应当使用下划线作为模块名的前缀。</p>
<h4 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h4><p>类名应当使用驼峰式（CapWords）。内部使用的类名应当加下划线前缀。</p>
<h4 id="异常名"><a href="#异常名" class="headerlink" title="异常名"></a>异常名</h4><p>异常也是一个类，所以需要遵循类名规则。但如果你的异常确实是个错误的话，请使用Error前缀。</p>
<h4 id="全局变量名"><a href="#全局变量名" class="headerlink" title="全局变量名"></a>全局变量名</h4><p>遵循函数规则。</p>
<h4 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h4><p>函数名全小写，可以使用下划线分隔来提高可读性。</p>
<h4 id="函数与方法参数"><a href="#函数与方法参数" class="headerlink" title="函数与方法参数"></a>函数与方法参数</h4><p>使用self作为实例方法的第一个参数。</p>
<p>使用cls作为类方法的第一个参数。</p>
<p>当函数的参数名与保留字冲突时，使用下划线后缀（第二次提醒）。</p>
<h4 id="方法名与实例变量"><a href="#方法名与实例变量" class="headerlink" title="方法名与实例变量"></a>方法名与实例变量</h4><p>遵循函数规则。</p>
<p>在私有方法和实例变量前用单下划线前缀。</p>
<p>使用双下划线前缀来调用”name mangling”来避免与子类命名冲突。</p>
<p>如果类Foo有个属性叫<strong>a，那么它不能使用Foo.</strong>a读取，但仍然可以Foo._Foo__a来读取。</p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量通常在模块级别定义，使用全大写和下划线分隔的形式。</p>
<h4 id="继承设计"><a href="#继承设计" class="headerlink" title="继承设计"></a>继承设计</h4><p>在设计类的方法或实例变量时，应当觉得其实公有的还是非公有的。当不能确定时，设计为私有的。</p>
<p>在Python中没有真正的私有属性。</p>
<p>公有属性不应当使用下划线开始。</p>
<p>当公有属性与保留字冲突时，在名称后面加下划线后缀（第三次提醒）。</p>
<p>对于简单的公有属性，最好直接访问其属性名，而非get/set方法。</p>
<h3 id="编程建议"><a href="#编程建议" class="headerlink" title="编程建议"></a>编程建议</h3><p>代码应当适用于Python的多个实现。比如不要依赖CPython的高效字符串语句 a+=b，而应当使用join，从而保证在不同实现上的线性开销。</p>
<p>当与类似于None的单例（singleton)进行比较式，要使用is 或者 is not， 而不是使用等于操作。</p>
<p>当使用复杂比较实现排序操作时，最好实现全部的六个比较操作。</p>
<p>使用基于对象的异常。</p>
<p>模块或者包应当定义自己的异常基类，这个类应当继承自内置的Exception类。</p>
<p>当抛出一个异常的时候，使用raise ValueError(‘message’)代替旧的raise ValueError,<br>‘message’格式。这是由于当异常的参数很长或者是格式化字符串的时候，由于括号的关系，我们不需要使用多行连接符。 旧的格式在Python 3 中被移除。</p>
<p>当捕获一个异常的时候，要用详细的异常声明来代替简单的except: 语句。</p>
<p>一个空的except:语句将会捕获 SystemExit 和 KeyboardInterrrupt 异常。这会使得很难用Control-<br>C来中断一个程序，并且还会隐藏其他的问题。</p>
<p>另外，对于所有的try/except语句，限制try语句来减少必要代码的数量。 再者，可以避免掩盖问题。</p>
<h4 id="Yes"><a href="#Yes" class="headerlink" title="Yes:"></a>Yes:</h4><pre><code>try:
    value = collection[key]
except KeyError:
    return key_not_found(key)
else:
    return handle_value(value)
</code></pre><h4 id="No"><a href="#No" class="headerlink" title="No:"></a>No:</h4><pre><code>try:
    # Too broad!
    return handle_value(collection[key])
except KeyError:
    # Will also catch KeyError raised by handle_value()
    return key_not_found(key)
</code></pre><p>使用’’.startswith() 和 ‘’.endswith()而非字符切片去检测前缀或后缀。</p>
<p>对象类型比较总要用 isinstance() 而非直接比较。</p>
<p>对于序列，(strings, lists, tuples)，利用空序列为false这一点来进行判断，而非使用长度来判断。</p>
<p>别用’==’进行布尔值和 True 或者 False 的比较。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[scp命令详解]]></title>
      <url>https://shijingjing07.github.io/2016/08/10/scp%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title="\"></a>\</h3><h3 id="svn-删除所有的-svn文件"><a href="#svn-删除所有的-svn文件" class="headerlink" title="svn 删除所有的 .svn文件"></a>svn 删除所有的 .svn文件</h3><h3 id="find-name-svn-type-d-exec-rm-fr"><a href="#find-name-svn-type-d-exec-rm-fr" class="headerlink" title="find . -name .svn -type d -exec rm -fr {} \;"></a>find . -name .svn -type d -exec rm -fr {} \;</h3><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><h3 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h3><h3 id="linux之cp-scp命令＋scp命令详解"><a href="#linux之cp-scp命令＋scp命令详解" class="headerlink" title="linux之cp/scp命令＋scp命令详解"></a>linux之cp/scp命令＋scp命令详解</h3><p>名称：cp</p>
<p>使用权限：所有使用者</p>
<p>使用方式：</p>
<p>cp [options] source dest</p>
<p>cp [options] source… directory</p>
<p>说明：将一个档案拷贝至另一档案，或将数个档案拷贝至另一目录。</p>
<p>把计</p>
<p>-a 尽可能将档案状态、权限等资料都照原状予以复制。</p>
<p>-r 若 source 中含有目录名，则将目录下之档案亦皆依序拷贝至目的地。</p>
<p>-f 若目的地已经有相同档名的档案存在，则在复制前先予以删除再行复制。</p>
<p>范例：</p>
<p>将档案 aaa 复制(已存在)，并命名为 bbb :</p>
<p>cp aaa bbb</p>
<p>将所有的C语言程式拷贝至 Finished 子目录中 :</p>
<p>cp *.c Finished</p>
<p>命令：scp</p>
<p>不同的Linux之间copy文件常用有3种方法：</p>
<p>第一种就是ftp，也就是其中一台Linux安装ftp Server，这样可以另外一台使用ftp的client程序来进行文件的copy。</p>
<p>第二种方法就是采用samba服务，类似Windows文件copy 的方式来操作，比较简洁方便。</p>
<p>第三种就是利用scp命令来进行文件复制。</p>
<pre><code>scp是有Security的文件copy，基于ssh登录。操作起来比较方便，比如要把当前一个文件copy到远程另外一台主机上，可以如下命令。
</code></pre><p>scp /home/daisy/full.tar.gz root@172.19.2.75:/home/root</p>
<p>然后会提示你输入另外那台172.19.2.75主机的root用户的登录密码，接着就开始copy了。</p>
<pre><code>如果想反过来操作，把文件从远程主机copy到当前系统，也很简单。
</code></pre><p><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" alt="linux之cp/scp命令＋scp命令详解\(转\) - linmaogan -
独木★不成林">scp<br><a href="http://linmaogan.blog.163.com/blog/static/382639372009101062147913/root@172.19.2.75/home/root" target="_blank" rel="external">root@</a>/full.tar.gz<br>172.19.2.75:/home/root/full.tar.gz home/daisy/full.tar.gz  </p>
<p>linux 的 scp 命令 可以 在 linux 之间复制 文件 和 目录；  </p>
<p>==================  </p>
<h1 id="scp-命令"><a href="#scp-命令" class="headerlink" title="scp 命令  "></a>scp 命令  </h1><p>scp 可以在 2个 linux 主机间复制文件；  </p>
<p>命令基本格式：<br>       scp [可选参数] file_source file_target   </p>
<p>======  </p>
<h1 id="从-本地-复制到-远程"><a href="#从-本地-复制到-远程" class="headerlink" title="从 本地 复制到 远程  "></a>从 本地 复制到 远程  </h1><ul>
<li><p>复制文件：   </p>
<pre><code>* 命令格式：   
        scp local_file remote_username@remote_ip:remote_folder   
        或者   
        scp local_file remote_username@remote_ip:remote_file   
        或者   
        scp local_file remote_ip:remote_folder   
        或者   
        scp local_file remote_ip:remote_file   

        第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名；   
        第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名；   
* 例子：   
        scp /home/space/music/1.mp3 root@www.cumt.edu.cn:/home/root/others/music   
        scp /home/space/music/1.mp3 root@www.cumt.edu.cn:/home/root/others/music/001.mp3   
        scp /home/space/music/1.mp3 www.cumt.edu.cn:/home/root/others/music   
        scp /home/space/music/1.mp3 www.cumt.edu.cn:/home/root/others/music/001.mp3   
</code></pre></li>
<li><p>复制目录：   </p>
<pre><code>* 命令格式：   
        scp -r local_folder remote_username@remote_ip:remote_folder   
        或者   
        scp -r local_folder remote_ip:remote_folder   

        第1个指定了用户名，命令执行后需要再输入密码；   
        第2个没有指定用户名，命令执行后需要输入用户名和密码；   
* 例子：   
        scp -r /home/space/music/ root@www.cumt.edu.cn:/home/root/others/   
        scp -r /home/space/music/ www.cumt.edu.cn:/home/root/others/   

        上面 命令 将 本地 music 目录 复制 到 远程 others 目录下，即复制后有 远程 有 ../others/music/ 目录   
</code></pre></li>
</ul>
<p>======  </p>
<h1 id="从-远程-复制到-本地"><a href="#从-远程-复制到-本地" class="headerlink" title="从 远程 复制到 本地  "></a>从 远程 复制到 本地  </h1><p>从 远程 复制到 本地，只要将 从 本地 复制到 远程 的命令 的 后2个参数 调换顺序 即可；  </p>
<p>例如：<br>        scp root@www.cumt.edu.cn:/home/root/others/music /home/space/music/1.mp3<br>        scp -r www.cumt.edu.cn:/home/root/others/ /home/space/music/</p>
<p>最简单的应用如下 :  </p>
<p>scp 本地用户名 @IP 地址 : 文件名 1 远程用户名 @IP 地址 : 文件名 2  </p>
<p>[ 本地用户名 @IP 地址 :] 可以不输入 , 可能需要输入远程用户名所对应的密码 .  </p>
<p>可能有用的几个参数 :  </p>
<p>-v 和大多数 linux 命令中的 -v 意思一样 , 用来显示进度 . 可以用来查看连接 , 认证 , 或是配置错误 .   </p>
<p>-C 使能压缩选项 .   </p>
<p>-P 选择端口 . 注意 -p 已经被 rcp 使用 .   </p>
<p>-4 强行使用 IPV4 地址 .   </p>
<p>-6 强行使用 IPV6 地址 .</p>
<p>注意两点：<br>1.如果远程服务器防火墙有特殊限制，scp便要走特殊端口，具体用什么端口视情况而定，命令格式如下：  </p>
<p>#scp -p 4588 remote@www.abc.com:/usr/local/sin.sh /home/administrator<br>2.使用scp要注意所使用的用户是否具有可读取远程服务器相应文件的权限。</p>
<p>转自：<a href="http://www.cnblogs.com/hitwtx/archive/2011/11/16/2251254.html" target="_blank" rel="external">http://www.cnblogs.com/hitwtx/archive/2011/11/16/2251254.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[七牛云存储Python SDK使用教程 - 上传策略详解]]></title>
      <url>https://shijingjing07.github.io/2016/08/09/%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8Python%20SDK%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%20-%20%E4%B8%8A%E4%BC%A0%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>文</p>
<h1 id="七牛云存储Python-SDK使用教程-上传策略详解"><a href="#七牛云存储Python-SDK使用教程-上传策略详解" class="headerlink" title="七牛云存储Python SDK使用教程 - 上传策略详解"></a><a href="https://segmentfault.com/a/1190000002462516" target="_blank" rel="external">七牛云存储Python SDK使用教程 - 上传策略详解</a></h1><ul>
<li><a href="https://segmentfault.com/t/%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8/blogs" target="_blank" rel="external">七牛云存储</a></li>
</ul>
<ul>
<li><a href="https://segmentfault.com/t/python-sdk/blogs" target="_blank" rel="external">python-sdk</a></li>
</ul>
<ul>
<li><a href="https://segmentfault.com/t/%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8%E6%95%99%E7%A8%8B/blogs" target="_blank" rel="external">七牛云存储教程</a></li>
</ul>
<p><a href="https://segmentfault.com/u/jemygraw" target="_blank" rel="external">jemygraw</a> 2015年01月04日发布</p>
<ul>
<li>推荐 1 推荐</li>
<li>收藏 2 收藏，2.7k 浏览</li>
</ul>
<p>本教程旨在介绍如何使用七牛的Python SDK来快速地进行文件上传，下载，处理，管理等工作。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在上面的两节中了解到，客户端上传文件时，需要从业务服务器申请一个上传凭证(Upload<br>Token)，而这个上传凭证是业务服务器根据上传策略(PutPolicy)来生成的，而这个生成过程中还必须使用到AccessKey和SecretKey。</p>
<p><img src="https://segmentfault.com/img/bVkuJf" alt=""></p>
<p>我们从上面的简单示意图中可以看到：</p>
<ol>
<li>上传客户端向业务服务器申请一个上传凭证(Upload Token)</li>
<li>业务服务器返回一个上传凭证给上传客户端</li>
<li>上传客户端构建上传请求，上传文件到七牛云存储服务器</li>
<li>七牛云存储服务器返回客户端文件上传的结果。</li>
</ol>
<p>当然了，在我们前面的例子以及后面的例子中，上传客户端和业务服务器是一个，但是从业务模型来讲，第1步和第2步还是分开的(比如在网页端上传或者移动APP端上传中)。</p>
<h1 id="上传策略"><a href="#上传策略" class="headerlink" title="上传策略"></a>上传策略</h1><p>我们要研究七牛的上传策略，必须要了解它的所有的支持的参数(一共也不多)。文档:<a href="http://developer.qiniu.com/docs/v6/api/reference/security
/put-policy.html" target="_blank" rel="external">戳这里</a>。<br>很多人可能第一眼看上去，感觉参数好多啊，头就大了，其实不然，对付多的东西，最好的办法就是分组，把参数按照功能不同进行分组。比如对于上传策略我们可以分为以下几组：</p>
<p>基本参数</p>
<p>基本参数包括文件上传后存储的空间，文件的上传模式(是否支持覆盖上传)，上传凭证的过期时刻，业务服务器指定上传文件的名字等。</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明  </th>
</tr>
</thead>
<tbody>
<tr>
<td>scope</td>
<td>上传的空间<code>bucket</code>，或者是<code>bucket:key</code>(用于支持文件覆盖上传)。  </td>
</tr>
<tr>
<td>deadline</td>
<td>上传凭证的失效时刻的时间戳，一般sdk里面会用参数expires来设置，就是`deadline =</td>
</tr>
</tbody>
</table>
<p>now()+expires<code>其中单位都是</code>秒<code>。  
insertOnly |
默认为0，配合</code>scope=bucket:key<code>可以支持覆盖上传，如果为1，则表示强制上传的语义是新建，遇到文件存在则返回</code>file exists<code>错误。  
saveKey | 业务服务器可以利用这个参数来指定上传文件在七牛云存储所保存的名字(仅在上传客户端没有指定请求参数</code>key`的情况下生效)。<br>endUser | 可以用来标注文件上传端设备的信息，比如手机类型，系统类型什么的。  </p>
<p>自定义上传回复</p>
<p>默认情况下，七牛云存储返回给上传客户端的信息只包括了文件的<code>hash</code>和<code>key</code>，就像我们前面看到过的那样：</p>
<pre><code>{&quot;hash&quot;:&quot;FoaI_ZzokcGpZA48PVJPFNJvLoNc&quot;,&quot;key&quot;:&quot;FoaI_ZzokcGpZA48PVJPFNJvLoNc&quot;}
</code></pre><p>那么有没有办法，扩充这个单薄的返回信息呢？</p>
<p>答案当然是：有！</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明  </th>
</tr>
</thead>
<tbody>
<tr>
<td>returnBody</td>
<td></td>
</tr>
</tbody>
</table>
<p>可以用来自定义上传的回复内容，支持魔法变量和自定义变量(又称为扩展变量)，关于变量详见文档:<a href="http://developer.qiniu.com/docs/v6/api/overview/up/response/vars.html" target="_blank" rel="external">戳这里</a>  </p>
<p>上传完成重定向</p>
<p>上传客户端在文件上传完成之后，从七牛云存储服务器那里获取上传结果的回复。这个过程中，没有再涉及到业务服务器，但是如果我希望文件上传之后，七牛服务器能不能告诉业务服务器一点信息呢？当然是可以的，其中一种方法就是页面重定向，页面重定向当然得知道重定向的地址(<code>returnUrl</code>)了，另外重定向到新的地址携带的参数内容可以通过<code>returnBody</code>来设置。</p>
<p>在文件上传完成之后，七牛返回给上传端<code>303</code>的状态码，然后上传端可以重定向到<code>returnUrl</code>所指定的地址，比如重定向到<code>http://.../service/return_upload_service?upload_ret=eyJmbmFtZSI6InVwbG9hZF9kcmFmdC5wbmciLCJldGFnIjoiRnNOM0g4eS15NGxzcV9jZ2p0NEQ3a2E5cjVmUSIsImtleSI6IkZzTjNIOHkteTRsc3FfY2dqdDREN2thOXI1ZlEiLCJleFBhcmFtMSI6ImhlbGxvIiwiZXhQYXJhbTIiOiJxaW5pdSIsImV4UGFyYW0zIjoicWluaXUifQ==</code>这样的地址，而这里的<code>returnUrl</code>设置为<code>http://.../service/return_upload_service</code>，而重定向地址携带的参数<code>upload_ret</code>的内容则是由<code>returnBody</code>来指定的，看上去<code>upload_ret</code>好像是<code>base64</code>编码吧，对的！是<code>URL安全的Base64编码</code>(在七牛的应用中，所提到的<code>base64</code>编码一般都是<code>URL安全的Base64编码</code>)。对<code>upload_ret</code>做一下解码就能得到真正的内容。</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明  </th>
</tr>
</thead>
<tbody>
<tr>
<td>returnUrl</td>
<td>上传端重定向的地址。  </td>
</tr>
<tr>
<td>returnBody</td>
<td>上传端重定向的时候，用来组织所携带的URL参数<code>upload_ret</code>的内容。  </td>
</tr>
</tbody>
</table>
<p>上传完成回调<br>我们上面看到了一种文件上传完成之后七牛服务器和业务服务器交互的一种方式，是通过上传端的重定向来实现的。当然这种方式有适用的场景。但是大多数情况下，我们都会用另外一种方式来进行七牛服务器和业务服务器的交互，这种方式叫做回调(Callback)。回调是在文件上传到七牛之后发生的，七牛会根据上传策略里面的参数<code>callbackUrl</code>指定的地址来发送一个POST请求，请求的内容则是由上传策略里面的<code>callbackBody</code>来指定的，另外还有一个<code>callbackHost</code>可以用来指定某个回调的主机地址，比如ip地址，另外<code>callbackBody</code>的内容组织格式是由<code>callbackBodyType</code>来决定的。七牛服务器会根据<code>callbackBodyType</code>来设置发送给业务服务器的POST请求的<br><code>Content-Type</code>，目前支持<code>application/x-www-form-
urlencoded</code>和<code>application/json</code>这两种格式。</p>
<p><img src="https://segmentfault.com/img/bVkuLs" alt=""></p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明  </th>
</tr>
</thead>
<tbody>
<tr>
<td>callbackUrl</td>
<td>七牛服务器回调业务服务器的地址，必须是公网可以访问的地址，能够接受POST请求。  </td>
</tr>
<tr>
<td>callbackBody</td>
<td>定义七牛服务器回调业务服务器时，POST请求的Body内容。  </td>
</tr>
<tr>
<td>callbackBodyType</td>
<td>指定<code>callbackBody</code>的内容格式，支持<code>url</code>和<code>json</code>两种格式。  </td>
</tr>
<tr>
<td>callbackHost</td>
<td>指定具体的回调主机地址，可以设置为ip地址以节约DNS解析时间。  </td>
</tr>
</tbody>
</table>
<p>上传完触发持久化<br>我们知道七牛支持很多图片和音视频处理的接口和指令，假设我希望从PC上传一个图片或者视频，然后上传完成立马触发七牛的文件处理指令将我上传的文件处理为支持不同平台的文件，那么我就可以使用下面的三个参数。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明  </th>
</tr>
</thead>
<tbody>
<tr>
<td>persistentOps</td>
<td></td>
</tr>
</tbody>
</table>
<p>数据处理指令集，之所以叫做指令集就是支持多个对原文件的处理指令，每个指令用<code>;</code>连接起来。这里的指令比如<code>imageView2</code>，<code>avthumb</code>，<code>vframe</code>等等。<br>persistentNotifyUrl |<br>这个地址是用来接收七牛服务器数据处理结果的，其接收到的数据内容和利用接口<code>prefop</code><a href="http://developer.qiniu.com/docs/v6/api/reference/fop/pfop/prefop.html" target="_blank" rel="external">文档</a>查询到的内容是一模一样的格式。<br>persistentPipeline |<br>指定数据处理所使用的队列名称，这个队列可以在<a href="https://portal.qiniu.com/" target="_blank" rel="external">七牛的后台管理系统</a>中创建。如果不指定，表示使用公用队列，数据处理效率上可能低于指定的私有处理队列。  </p>
<p>文件上传限制<br>我们可以在上传策略里面指定文件上传的最大大小和允许的文件类型。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明  </th>
</tr>
</thead>
<tbody>
<tr>
<td>fsizeLimit</td>
<td>文件上传的最大大小，单位为字节(Byte)。  </td>
</tr>
<tr>
<td>mimeLimit</td>
<td></td>
</tr>
</tbody>
</table>
<p>文件上传的类型，可以通过允许的语义(<code>image/jpeg;image/png</code>，表示只允许jpeg和png格式图片)或者不允许的语义(<code>!application/json;text/plain</code>，表示不允许json和纯文本文件)来指定。  </p>
<h2 id="上传策略和SDK"><a href="#上传策略和SDK" class="headerlink" title="上传策略和SDK"></a>上传策略和SDK</h2><p>在最新版本的Python的SDK中(v7.0)，上传策略的参数定义在<code>auth.py</code>里面，如下：</p>
<pre><code>_policy_fields = set([
    &apos;callbackUrl&apos;,
    &apos;callbackBody&apos;,
    &apos;callbackHost&apos;,

    &apos;returnUrl&apos;,
    &apos;returnBody&apos;,

    &apos;endUser&apos;,
    &apos;saveKey&apos;,
    &apos;insertOnly&apos;,

    &apos;detectMime&apos;,
    &apos;mimeLimit&apos;,
    &apos;fsizeLimit&apos;,

    &apos;persistentOps&apos;,
    &apos;persistentNotifyUrl&apos;,
    &apos;persistentPipeline&apos;,
])
</code></pre><p>我们看一个小例子来演示，如何使用<code>policy</code>。</p>
<pre><code>#有key上传，限定上传文件的大小和mimeType
def upload_with_key_and_fsizelimit_mimelimt():
    bucket = &quot;if-pbl&quot;
    key = &quot;qiniu.jpg&quot;
    filePath = &quot;/Users/jemy/Documents/qiniu.jpg&quot;
    auth = qiniu.Auth(accessKey, secretKey)
    policy = {
        &quot;fsizeLimit&quot;: 1000,
        &quot;mimeLimit&quot;: &quot;image/png&quot;
    }
    upToken = auth.upload_token(bucket, key=key, policy=policy)
    retData, respInfo = qiniu.put_file(upToken, key, filePath, progress_handler=progress)
    parseRet(retData, respInfo)
</code></pre><p>这个例子中，我们使用了<code>policy</code>的两个参数<code>fsizeLimit</code>和<code>mimeLimit</code>，表示我们只允许上传大小不大于<code>1000字节</code>的类型为<code>png</code>的图片。</p>
<p>更多的关于<code>policy</code>的其他参数的例子我们将在后面的章节中给出。用法相似，先体会一下。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>从上面介绍的内容我们大致可以得出以下的一些结论：</p>
<ol>
<li>上传策略决定了文件存储的空间</li>
<li>上传策略可以设定生成的上传凭证的有效期</li>
<li>上传策略支持文件同名覆盖上传</li>
<li>上传策略里面可以指定文件上传后上传端的重定向操作</li>
<li>上传策略里面可以指定文件上传后七牛服务器和业务服务器的交互操作</li>
<li>上传策略里面可以指定文件上传后，七牛服务器对其进行的一组数据处理操作</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python操作redis]]></title>
      <url>https://shijingjing07.github.io/2016/08/09/Python%E6%93%8D%E4%BD%9Credis/</url>
      <content type="html"><![CDATA[<pre><code>import redis
r=redis.Redis(host=&apos;127.0.0.1&apos;,password=1,port=6379,db=0)
r.set(&apos;guo&apos;,&apos;shuai&apos;)
name=r.get(&apos;guo&apos;)
print name
count=r.keys()
print count
size=r.dbsize()
print size
r.save()
name=r.get(&apos;guo&apos;)
r.delete(&apos;guo&apos;)
count=r.keys()
print count
</code></pre><h1 id="使用Python操作Redis"><a href="#使用Python操作Redis" class="headerlink" title="使用Python操作Redis"></a>使用Python操作Redis</h1><p><a href="http://debugo.com/python-redis/" title="下午5:02" target="_blank" rel="external">2014年5月15日</a> by<br><a href="http://debugo.com/author/admin/" title="View all posts by debugo" target="_blank" rel="external">debugo</a> * <a href="http://debugo.com/python-redis/#comments" title="Comment on
使用Python操作Redis" target="_blank" rel="external">12<br>Comments</a></p>
<h2 id="1-安装pyredis"><a href="#1-安装pyredis" class="headerlink" title="1. 安装pyredis"></a>1. 安装pyredis</h2><p>首先安装pip</p>
<p>&lt;SHELL&gt;# apt-get install python-pip …… &lt;SHELL&gt;# pip install<br>–proxy=<a href="http://172.1.2.6:8080" target="_blank" rel="external">http://172.1.2.6:8080</a> redis Downloading redis-2.9.1.tar.gz (62kB):<br>62kB downloaded Running setup.py (path:/tmp/pip_build_root/redis/setup.py)<br>egg_info for package redis …… Successfully installed redis Cleaning up…</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>|</p>
<p>&lt;SHELL&gt;# apt-get install python-pip</p>
<p>……</p>
<p>&lt;SHELL&gt;# pip install –proxy=<a href="http://172.1.2.6:8080" target="_blank" rel="external">http://172.1.2.6:8080</a> redis</p>
<p>  Downloading redis-2.9.1.tar.gz (62kB): 62kB downloaded</p>
<p>  Running setup.py (path:/tmp/pip_build_root/redis/setup.py) egg_info for<br>package redis</p>
<p>  ……</p>
<p>  Successfully installed redis</p>
<p>  Cleaning up…  </p>
<p>—|—  </p>
<p>也可以使用easy_install的方式来安装：</p>
<p>easy_install redis</p>
<p>1</p>
<p>|</p>
<p>easy_install redis  </p>
<p>—|—  </p>
<p>或者直接编译安装：</p>
<p>wget <a href="https://pypi.python.org/packages/source/r/redis/redis-2.9.1.tar.gz" target="_blank" rel="external">https://pypi.python.org/packages/source/r/redis/redis-2.9.1.tar.gz</a> tar<br>xvzf redis-2.9.1.tar.gz cd redis-2.9.1 python setup.py install</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>|</p>
<p>wget <a href="https://pypi.python.org/packages/source/r/redis/redis-2.9.1.tar.gz" target="_blank" rel="external">https://pypi.python.org/packages/source/r/redis/redis-2.9.1.tar.gz</a></p>
<p>tar xvzf redis-2.9.1.tar.gz</p>
<p>cd redis-2.9.1</p>
<p>python setup.py install  </p>
<p>—|—  </p>
<h2 id="2-简单的redis操作"><a href="#2-简单的redis操作" class="headerlink" title="2 . 简单的redis操作"></a>2 . 简单的redis操作</h2><p>redis连接实例是线程安全的，可以直接将redis连接实例设置为一个全局变量，直接使用。如果需要另一个Redis实例（or<br>Redis数据库）时，就需要重新创建redis连接实例来获取一个新的连接。同理，python的redis没有实现select命令。</p>
<p>&gt;&gt;&gt; import redis &gt;&gt;&gt; r =<br>redis.Redis(host=’localhost’,port=6379,db=0) &gt;&gt;&gt; r.set(‘guo’,’shuai’)<br>True &gt;&gt;&gt; r.get(‘guo’) ‘shuai’ &gt;&gt;&gt; r[‘guo’] ‘shuai’<br>&gt;&gt;&gt; r.keys() [‘guo’] &gt;&gt;&gt; r.dbsize() #当前数据库包含多少条数据 1L<br>&gt;&gt;&gt; r.delete(‘guo’) 1 &gt;&gt;&gt; r.save() #执行”检查点”操作，将数据写回磁盘。保存时阻塞<br>True &gt;&gt;&gt; r.get(‘guo’); &gt;&gt;&gt; r.flushdb() #清空r中的所有数据 True</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>|</p>
<p>&gt;&gt;&gt; import redis</p>
<p>&gt;&gt;&gt; r = redis.Redis(host=’localhost’,port=6379,db=0)</p>
<p>&gt;&gt;&gt; r.set(‘guo’,’shuai’)</p>
<p>True</p>
<p>&gt;&gt;&gt; r.get(‘guo’)</p>
<p>‘shuai’</p>
<p>&gt;&gt;&gt; r[‘guo’]  </p>
<p>‘shuai’</p>
<p>&gt;&gt;&gt; r.keys()</p>
<p>[‘guo’]</p>
<p>&gt;&gt;&gt; r.dbsize()         #当前数据库包含多少条数据  </p>
<p>1L</p>
<p>&gt;&gt;&gt; r.delete(‘guo’)</p>
<p>1</p>
<p>&gt;&gt;&gt; r.save()               #执行”检查点”操作，将数据写回磁盘。保存时阻塞</p>
<p>True</p>
<p>&gt;&gt;&gt; r.get(‘guo’);</p>
<p>&gt;&gt;&gt; r.flushdb()        #清空r中的所有数据</p>
<p>True  </p>
<p>—|—  </p>
<h2 id="3-pipeline操作"><a href="#3-pipeline操作" class="headerlink" title="3. pipeline操作"></a>3. pipeline操作</h2><p>管道（pipeline）是redis在提供单个请求中缓冲多条服务器命令的基类的子类。它通过减少服务器-<br>客户端之间反复的TCP数据库包，从而大大提高了执行批量命令的功能。</p>
<p>&gt;&gt;&gt; p = r.pipeline() –创建一个管道 &gt;&gt;&gt; p.set(‘hello’,’redis’)<br>&gt;&gt;&gt; p.sadd(‘faz’,’baz’) &gt;&gt;&gt; p.incr(‘num’) &gt;&gt;&gt;<br>p.execute() [True, 1, 1] &gt;&gt;&gt; r.get(‘hello’) ‘redis’</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>|</p>
<p>&gt;&gt;&gt; p = r.pipeline()        --创建一个管道</p>
<p>&gt;&gt;&gt; p.set(‘hello’,’redis’)</p>
<p>&gt;&gt;&gt; p.sadd(‘faz’,’baz’)</p>
<p>&gt;&gt;&gt; p.incr(‘num’)</p>
<p>&gt;&gt;&gt; p.execute()</p>
<p>[True, 1, 1]</p>
<p>&gt;&gt;&gt; r.get(‘hello’)</p>
<p>‘redis’  </p>
<p>—|—  </p>
<p>管道的命令可以写在一起，如：</p>
<p>&gt;&gt;&gt; p.set(‘hello’,’redis’).sadd(‘faz’,’baz’).incr(‘num’).execute()</p>
<p>1</p>
<p>|</p>
<p>&gt;&gt;&gt; p.set(‘hello’,’redis’).sadd(‘faz’,’baz’).incr(‘num’).execute()  </p>
<p>—|—  </p>
<p>默认的情况下，管道里执行的命令可以保证执行的原子性，执行pipe = r.pipeline(transaction=False)可以禁用这一特性。</p>
<h2 id="4-应用场景-页面点击数"><a href="#4-应用场景-页面点击数" class="headerlink" title="4. 应用场景 - 页面点击数"></a>4. 应用场景 - 页面点击数</h2><p>《Redis<br>Cookbook》对这个经典场景进行详细描述。假定我们对一系列页面需要记录点击次数。例如论坛的每个帖子都要记录点击次数，而点击次数比回帖的次数的<br>多得多。如果使用关系数据库来存储点击，可能存在大量的行级锁争用。所以，点击数的增加使用redis的INCR命令最好不过了。<br>当redis服务器启动时，可以从关系数据库读入点击数的初始值（1237这个页面被访问了34634次）</p>
<p>&gt;&gt;&gt; r.set(“visit:1237:totals”,34634) True</p>
<p>1</p>
<p>2</p>
<p>|</p>
<p>&gt;&gt;&gt; r.set(“visit:1237:totals”,34634)</p>
<p>True  </p>
<p>—|—  </p>
<p>每当有一个页面点击，则使用INCR增加点击数即可。</p>
<p>&gt;&gt;&gt; r.incr(“visit:1237:totals”) 34635 &gt;&gt;&gt;<br>r.incr(“visit:1237:totals”) 34636</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>|</p>
<p>&gt;&gt;&gt; r.incr(“visit:1237:totals”)</p>
<p>34635</p>
<p>&gt;&gt;&gt; r.incr(“visit:1237:totals”)</p>
<p>34636  </p>
<p>—|—  </p>
<p>页面载入的时候则可直接获取这个值</p>
<p>&gt;&gt;&gt; r.get (“visit:1237:totals”) ‘34636’</p>
<p>1</p>
<p>2</p>
<p>|</p>
<p>&gt;&gt;&gt; r.get (“visit:1237:totals”)</p>
<p>‘34636’  </p>
<p>—|—  </p>
<h2 id="5-使用hash类型保存多样化对象"><a href="#5-使用hash类型保存多样化对象" class="headerlink" title="5. 使用hash类型保存多样化对象"></a>5. 使用hash类型保存多样化对象</h2><p>当有大量类型文档的对象，文档的内容都不一样时，（即”表”没有固定的列），可以使用hash来表达。</p>
<p>&gt;&gt;&gt; r.hset(‘users:jdoe’, ‘name’, “John Doe”) 1L &gt;&gt;&gt;<br>r.hset(‘users:jdoe’, ‘email’, ‘John@test.com’) 1L &gt;&gt;&gt;<br>r.hset(‘users:jdoe’, ‘phone’, ‘1555313940’) 1L &gt;&gt;&gt;<br>r.hincrby(‘users:jdoe’, ‘visits’, 1) 1L &gt;&gt;&gt; r.hgetall(‘users:jdoe’)<br>{‘phone’: ‘1555313940’, ‘name’: ‘John Doe’, ‘visits’: ‘1’, ‘email’:<br>‘John@test.com’} &gt;&gt;&gt; r.hkeys(‘users:jdoe’) [‘name’, ‘email’, ‘phone’,<br>‘visits’]</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>|</p>
<p>&gt;&gt;&gt; r.hset(‘users:jdoe’,  ‘name’, “John Doe”)</p>
<p>1L</p>
<p>&gt;&gt;&gt; r.hset(‘users:jdoe’, ‘email’, ‘John@test.com’)</p>
<p>1L</p>
<p>&gt;&gt;&gt; r.hset(‘users:jdoe’,  ‘phone’, ‘1555313940’)</p>
<p>1L</p>
<p>&gt;&gt;&gt; r.hincrby(‘users:jdoe’, ‘visits’, 1)</p>
<p>1L</p>
<p>&gt;&gt;&gt; r.hgetall(‘users:jdoe’)</p>
<p>{‘phone’: ‘1555313940’, ‘name’: ‘John Doe’, ‘visits’: ‘1’, ‘email’:<br>‘John@test.com’}</p>
<p>&gt;&gt;&gt; r.hkeys(‘users:jdoe’)</p>
<p>[‘name’, ‘email’, ‘phone’, ‘visits’]  </p>
<p>—|—  </p>
<h2 id="6-应用场景-社交圈子数据"><a href="#6-应用场景-社交圈子数据" class="headerlink" title="6. 应用场景 - 社交圈子数据"></a>6. 应用场景 - 社交圈子数据</h2><p>在社交网站中，每一个圈子(circle)都有自己的用户群。通过圈子可以找到有共同特征（比如某一体育活动、游戏、电影等爱好者）的人。当一个用户加入一个或几个圈子后，系统可以向这个用户推荐圈子中的人。<br>我们定义这样两个圈子,并加入一些圈子成员。</p>
<p>&gt;&gt;&gt; r.sadd(‘circle:game:lol’,’user:debugo’) 1 &gt;&gt;&gt;<br>r.sadd(‘circle:game:lol’,’user:leo’) 1 &gt;&gt;&gt;<br>r.sadd(‘circle:game:lol’,’user:Guo’) 1 &gt;&gt;&gt;<br>r.sadd(‘circle:soccer:InterMilan’,’user:Guo’) 1 &gt;&gt;&gt;<br>r.sadd(‘circle:soccer:InterMilan’,’user:Levis’) 1 &gt;&gt;&gt;<br>r.sadd(‘circle:soccer:InterMilan’,’user:leo’) 1</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>|</p>
<p>&gt;&gt;&gt; r.sadd(‘circle:game:lol’,’user:debugo’)</p>
<p>1</p>
<p>&gt;&gt;&gt; r.sadd(‘circle:game:lol’,’user:leo’)</p>
<p>1</p>
<p>&gt;&gt;&gt; r.sadd(‘circle:game:lol’,’user:Guo’)</p>
<p>1</p>
<p>&gt;&gt;&gt; r.sadd(‘circle:soccer:InterMilan’,’user:Guo’)</p>
<p>1</p>
<p>&gt;&gt;&gt; r.sadd(‘circle:soccer:InterMilan’,’user:Levis’)</p>
<p>1</p>
<p>&gt;&gt;&gt; r.sadd(‘circle:soccer:InterMilan’,’user:leo’)</p>
<p>1  </p>
<p>—|—  </p>
<p>#获得某一圈子的成员</p>
<p>&gt;&gt;&gt; r.smembers(‘circle:game:lol’) set([‘user:Guo’, ‘user:debugo’,<br>‘user:leo’]) redis&gt; smembers circle:jdoe:family</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>|</p>
<p>&gt;&gt;&gt; r.smembers(‘circle:game:lol’)</p>
<p>set([‘user:Guo’, ‘user:debugo’, ‘user:leo’])</p>
<p>redis&gt; smembers circle:jdoe:family  </p>
<p>—|—  </p>
<p>可以使用集合运算来得到几个圈子的共同成员：</p>
<p>&gt;&gt;&gt; r.sinter(‘circle:game:lol’, ‘circle:soccer:InterMilan’)<br>set([‘user:Guo’, ‘user:leo’]) &gt;&gt;&gt; r.sunion(‘circle:game:lol’,<br>‘circle:soccer:InterMilan’) set([‘user:Levis’, ‘user:Guo’, ‘user:debugo’,<br>‘user:leo’])</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>|</p>
<p>&gt;&gt;&gt; r.sinter(‘circle:game:lol’, ‘circle:soccer:InterMilan’)</p>
<p>set([‘user:Guo’, ‘user:leo’])</p>
<p>&gt;&gt;&gt; r.sunion(‘circle:game:lol’, ‘circle:soccer:InterMilan’)</p>
<p>set([‘user:Levis’, ‘user:Guo’, ‘user:debugo’, ‘user:leo’])  </p>
<p>—|—  </p>
<h2 id="7-应用场景-实时用户统计"><a href="#7-应用场景-实时用户统计" class="headerlink" title="7. 应用场景 - 实时用户统计"></a>7. 应用场景 - 实时用户统计</h2><p><a href="http://flask.pocoo.org/snippets/71/" target="_blank" rel="external">Counting Online Users with Redis</a>介<br>绍了这个方法。当我们需要在页面上显示当前的在线用户时，就可以使用Redis来完成了。首先获得当前时间（以Unix<br>timestamps方式）除以60，可以基于这个值创建一个key。然后添加用户到这个集合中。当超过你设定的最大的超时时间，则将这个集合设为过期；<br>而当需要查询当前在线用户的时候，则将最后N分钟的集合交集在一起即可。由于redis连接对象是线程安全的，所以可以直接使用一个全局变量来表示。</p>
<p>import time from redis import Redis from datetime import datetime<br>ONLINE_LAST_MINUTES = 5 redis = Redis() def mark_online(user_id):</p>
<p>#将一个用户标记为online now = int(time.time()) #当前的UNIX时间戳 expires = now +<br>(app.config[‘ONLINE_LAST_MINUTES’] * 60) + 10 #过期的UNIX时间戳 all_users_key =<br>‘online-users/%d’ % (now // 60) #集合名，包含分钟信息 user_key = ‘user-activity/%s’ %<br>user_id p = redis.pipeline() p.sadd(all_users_key, user_id)</p>
<p>#将用户id插入到包含分钟信息的集合中 p.set(user_key, now) #记录用户的标记时间 p.expireat(all_users_key,<br>expires) #设定集合的过期时间为UNIX的时间戳 p.expireat(user_key, expires) p.execute() def<br>get_user_last_activity(user_id): #获得用户的最后活跃时间 last_active = redis.get(‘user-<br>activity/%s’ % user_id) #如果获取不到，则返回None if last_active is None: return None<br>return datetime.utcfromtimestamp(int(last_active)) def get_online_users():</p>
<p>#获得当前online用户的列表 current = int(time.time()) // 60 minutes =<br>xrange(app.config[‘ONLINE_LAST_MINUTES’]) return redis.sunion([‘online-<br>users/%d’ % (current - x) #取ONLINE_LAST_MINUTES分钟对应集合的交集 for x in minutes])</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>|</p>
<p>import time</p>
<p>from redis import Redis</p>
<p>from datetime import datetime</p>
<p>ONLINE_LAST_MINUTES = 5</p>
<p>redis = Redis()</p>
<p>def mark_online(user_id):         #将一个用户标记为online</p>
<pre><code>now = int(time.time())        #当前的UNIX时间戳

expires = now + (app.config[&apos;ONLINE_LAST_MINUTES&apos;] * 60) + 10    #过期的UNIX时间戳

all_users_key = &apos;online-users/%d&apos; % (now // 60)        #集合名，包含分钟信息

user_key = &apos;user-activity/%s&apos; % user_id                

p = redis.pipeline()

p.sadd(all_users_key, user_id)                         #将用户id插入到包含分钟信息的集合中

p.set(user_key, now)                                   #记录用户的标记时间

p.expireat(all_users_key, expires)                     #设定集合的过期时间为UNIX的时间戳

p.expireat(user_key, expires)

p.execute()
</code></pre><p>def get_user_last_activity(user_id):        #获得用户的最后活跃时间</p>
<pre><code>last_active = redis.get(&apos;user-activity/%s&apos; % user_id)  #如果获取不到，则返回None

if last_active is None:

    return None

return datetime.utcfromtimestamp(int(last_active))
</code></pre><p>def get_online_users():                     #获得当前online用户的列表</p>
<pre><code>current = int(time.time()) // 60        

minutes = xrange(app.config[&apos;ONLINE_LAST_MINUTES&apos;])

return redis.sunion([&apos;online-users/%d&apos; % (current - x)        #取ONLINE_LAST_MINUTES分钟对应集合的交集

                     for x in minutes])  
</code></pre><p>—|—  </p>
<h2 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h2><p><a href="http://blog.csdn.net/vv_demon/article/details/7676384" target="_blank" rel="external">http://blog.csdn.net/vv_demon/article/details/7676384</a><a href="http://blog.csdn.net/vv_demon/article/details/7676384" target="_blank" rel="external">  
</a><br>tigerfish NoSQL和NewSQL数据库引航<br>《Redis Cookbook》<br>Redis-Python <a href="https://pypi.python.org/pypi/redis/2.9.1" target="_blank" rel="external">https://pypi.python.org/pypi/redis/2.9.1</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu 安装和配置redis数据库]]></title>
      <url>https://shijingjing07.github.io/2016/08/09/Ubuntu%20%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEredis%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<h1 id="Ubuntu-14-04下安装和配置redis数据库"><a href="#Ubuntu-14-04下安装和配置redis数据库" class="headerlink" title="Ubuntu 14.04下安装和配置redis数据库"></a>Ubuntu 14.04下安装和配置redis数据库</h1><p>小编现在在写一个分布式爬虫，要用到这个数据库，所以分享一下小编是如何安装和配置的，希望对大家有帮助。</p>
<h2 id="工具-原料"><a href="#工具-原料" class="headerlink" title="工具/原料"></a>工具/原料</h2><ul>
<li><p>Ubuntu 系统电脑一台</p>
</li>
<li><p>网络</p>
</li>
</ul>
<h2 id="方法-步骤"><a href="#方法-步骤" class="headerlink" title="方法/步骤"></a>方法/步骤</h2><ol>
<li></li>
</ol>
<p>以root权限登录，切换到/usr目录下.</p>
<ol>
<li></li>
</ol>
<p>接下来输入命令，apt-get install redis-server,如图：</p>
<p><a href="http://jingyan.baidu.com/album/948f592401d172d80ff5f99a.html?picindex=1" target="_blank" rel="external"><img src="http://e.hiphotos.baidu.com/exp/w=500/sign=544ce8da0ff3d7ca0cf63f76c21ebe3c/b17eca8065380cd75d4d0d09a244ad3458828187.jpg" alt="Ubuntu
14.04下安装和配置redis数据库"></a></p>
<ol>
<li></li>
</ol>
<p>安装完成后，Redis服务器会自动启动，我们检查Redis服务器程序,执行ps -aux|grep redis，如图：</p>
<p><a href="http://jingyan.baidu.com/album/948f592401d172d80ff5f99a.html?picindex=2" target="_blank" rel="external"><img src="http://f.hiphotos.baidu.com/exp/w=500/sign=f070ad07d639b6004dce0fb7d9523526/55e736d12f2eb9387eeed416d6628535e4dd6f57.jpg" alt="Ubuntu
14.04下安装和配置redis数据库"></a></p>
<ol>
<li></li>
</ol>
<p>通过启动命令检查Redis服务器状态,执行：netstat -nlt|grep 6379，如图：</p>
<p><a href="http://jingyan.baidu.com/album/948f592401d172d80ff5f99a.html?picindex=3" target="_blank" rel="external"><img src="http://e.hiphotos.baidu.com/exp/w=500/sign=f3870d3b75c6a7efb926a826cdfbafe9/a71ea8d3fd1f4134839cad9a261f95cad0c85eae.jpg" alt="Ubuntu
14.04下安装和配置redis数据库"></a></p>
<ol>
<li></li>
</ol>
<p>安装Redis服务器，会自动地一起安装Redis命令行客户端程序。在本机输入redis-cli命令就可以启动，客户端程序访问Redis服务器。执行<br>：redis-cli，如图：</p>
<p><a href="http://jingyan.baidu.com/album/948f592401d172d80ff5f99a.html?picindex=4" target="_blank" rel="external"><img src="http://c.hiphotos.baidu.com/exp/w=500/sign=dd043a167e1ed21b79c92ee59d6fddae/aec379310a55b319b154299140a98226cefc17a0.jpg" alt="Ubuntu
14.04下安装和配置redis数据库"></a></p>
<ol>
<li>6</li>
</ol>
<p>这样就安装好了，接下来就是如何使用了。。</p>
<h1 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h1><p>redis配置密码  </p>
<p><strong>1.通过配置文件进行配置</strong><br>yum方式安装的redis配置文件通常在/etc/redis.conf中，打开配置文件找到</p>
<p><strong>[plain]</strong> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="copy" target="_blank" rel="external">copy</a></p>
<pre><code>1. #requirepass foobared  
</code></pre><p>去掉行前的注释，并修改密码为所需的密码,保存文件</p>
<p><strong>[plain]</strong> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="copy" target="_blank" rel="external">copy</a></p>
<pre><code>1. requirepass myRedis  
</code></pre><p>重启redis</p>
<p><strong>[plain]</strong> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="copy" target="_blank" rel="external">copy</a></p>
<pre><code>1. sudo service redis restart  
2. #或者  
3. sudo service redis stop  
4. sudo redis-server /etc/redis.conf  
</code></pre><p>这个时候尝试登录redis，发现可以登上，但是执行具体命令是提示操作不允许</p>
<p><strong>[plain]</strong> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="copy" target="_blank" rel="external">copy</a></p>
<pre><code>1. redis-cli -h 127.0.0.1 -p 6379  
2. redis 127.0.0.1:6379&amp;gt;  
3. redis 127.0.0.1:6379&amp;gt; keys *  
4. (error) ERR operation not permitted  
5. redis 127.0.0.1:6379&amp;gt; select 1  
6. (error) ERR operation not permitted  
7. redis 127.0.0.1:6379[1]&amp;gt;   
</code></pre><p>尝试用密码登录并执行具体的命令看到可以成功执行</p>
<p><strong>[plain]</strong> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="copy" target="_blank" rel="external">copy</a></p>
<pre><code>1. redis-cli -h 127.0.0.1 -p 6379 -a myRedis  
2. redis 127.0.0.1:6379&amp;gt; keys *  
3. 1) &quot;myset&quot;  
4. 2) &quot;mysortset&quot;  
5. redis 127.0.0.1:6379&amp;gt; select 1  
6. OK  
7. redis 127.0.0.1:6379[1]&amp;gt; config get requirepass  
8. 1) &quot;requirepass&quot;  
9. 2) &quot;myRedis&quot;  
</code></pre><p>2.通过命令行进行配置</p>
<p><strong>[plain]</strong> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="copy" target="_blank" rel="external">copy</a></p>
<pre><code>1. redis 127.0.0.1:6379[1]&amp;gt; config set requirepass my_redis  
2. OK  
3. redis 127.0.0.1:6379[1]&amp;gt; config get requirepass  
4. 1) &quot;requirepass&quot;  
5. 2) &quot;my_redis&quot;  
</code></pre><p>无需重启redis<br>使用第一步中配置文件中配置的老密码登录redis，会发现原来的密码已不可用，操作被拒绝</p>
<p><strong>[plain]</strong> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="copy" target="_blank" rel="external">copy</a></p>
<pre><code>1. redis-cli -h 127.0.0.1 -p 6379 -a myRedis  
2. redis 127.0.0.1:6379&amp;gt; config get requirepass  
3. (error) ERR operation not permitted  
</code></pre><p>使用修改后的密码登录redis，可以执行相应操作</p>
<p><strong>[plain]</strong> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="copy" target="_blank" rel="external">copy</a></p>
<pre><code>1. redis-cli -h 127.0.0.1 -p 6379 -a my_redis  
2. redis 127.0.0.1:6379&amp;gt; config get requirepass  
3. 1) &quot;requirepass&quot;  
4. 2) &quot;my_redis  
</code></pre><p>尝试重启一下redis，用新配置的密码登录redis执行操作，发现新的密码失效，redis重新使用了配置文件中的密码</p>
<p><strong>[plain]</strong> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="copy" target="_blank" rel="external">copy</a></p>
<pre><code>1. sudo service redis restart  
2. Stopping redis-server:                                     [  OK  ]  
3. Starting redis-server:                                     [  OK  ]  
4. redis-cli -h 127.0.0.1 -p 6379 -a my_redis  
5. redis 127.0.0.1:6379&amp;gt; config get requirepass  
6. (error) ERR operation not permitted  
7. redis-cli -h 127.0.0.1 -p 6379 -a myRedis  
8. redis 127.0.0.1:6379&amp;gt; config get requirepass  
9. 1) &quot;requirepass&quot;  
10. 2) &quot;myRedis&quot;  
</code></pre><p>除了在登录时通过 -a 参数制定密码外，还可以登录时不指定密码，而在执行操作前进行认证。</p>
<p><strong>[plain]</strong> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="copy" target="_blank" rel="external">copy</a></p>
<pre><code>1. redis-cli -h 127.0.0.1 -p 6379  
2. redis 127.0.0.1:6379&amp;gt; config get requirepass  
3. (error) ERR operation not permitted  
4. redis 127.0.0.1:6379&amp;gt; auth myRedis  
5. OK  
6. redis 127.0.0.1:6379&amp;gt; config get requirepass  
7. 1) &quot;requirepass&quot;  
8. 2) &quot;myRedis&quot;  
</code></pre><p>3.master配置了密码，slave如何配置</p>
<p>若master配置了密码则slave也要配置相应的密码参数否则无法进行正常复制的。<br>slave中配置文件内找到如下行，移除注释，修改密码即可</p>
<p><strong>[plain]</strong> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/zyz511919766/article/details/42268219#" title="copy" target="_blank" rel="external">copy</a></p>
<pre><code>1. #masterauth  mstpassword  
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python时间处理之datetime]]></title>
      <url>https://shijingjing07.github.io/2016/08/09/python%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E4%B9%8Bdatetime/</url>
      <content type="html"><![CDATA[<p>#<br><a href="http://blog.csdn.net/wirelessqa/article/details/7973121" target="_blank" rel="external">python时间处理之datetime</a></p>
<p>标签：<br><a href="http://www.csdn.net/tag/python" target="_blank" rel="external">python</a><a href="http://www.csdn.net/tag/date" target="_blank" rel="external">date</a><a href="http://www.csdn.net/tag/import" target="_blank" rel="external">import</a><a href="http://www.csdn.net/tag/string" target="_blank" rel="external">string</a><a href="http://www.csdn.net/tag/c" target="_blank" rel="external">c</a></p>
<p>2012-09-12 23:21 20910人阅读<br><a href="http://blog.csdn.net/wirelessqa/article/details/7973121/#comments" target="_blank" rel="external">评论</a>(0) 收藏<br><a href="http://blog.csdn.net/wirelessqa/article/details/7973121/#report" title="举报" target="_blank" rel="external">举报</a></p>
<p><img src="http://static.blog.csdn.net/images/category_icon.jpg" alt=""> 分类：</p>
<p>Python系列（12）<br><img src="http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg" alt=""></p>
<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>
<p>目录<a href="http://blog.csdn.net/wirelessqa/article/details/7973121/#" title="系统根据文章中H1到H6标签自动生成文章目录" target="_blank" rel="external">(?)</a><a href="http://blog.csdn.net/wirelessqa/article/details/7973121/#" title="展开" target="_blank" rel="external">[+]</a></p>
<h1 id="运行环境-Python3-4"><a href="#运行环境-Python3-4" class="headerlink" title="运行环境:Python3.4"></a>运行环境:Python3.4</h1><p><strong>[python]</strong> <a href="http://blog.csdn.net/wirelessqa/article/details/7973121/#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/wirelessqa/article/details/7973121/#" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li><h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1></li>
<li></li>
<li></li>
<li>#datetime类  </li>
<li>#datetime是date与time的结合体，包括date与time的所有信息。  </li>
<li>#它的构造函数如下：  </li>
<li>#datetime. datetime (year, month, day[ , hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ] )  </li>
<li>#各参数的含义与date、time的构造函数中的一样，要注意参数值的范围。  </li>
<li></li>
<li></li>
<li></li>
<li></li>
<li><h1 id="1-datetime类定义的类属性与方法："><a href="#1-datetime类定义的类属性与方法：" class="headerlink" title="1. datetime类定义的类属性与方法："></a>1. datetime类定义的类属性与方法：</h1></li>
<li>#datetime.min、datetime.max：datetime所能表示的最小值与最大值；  </li>
<li>#print: datetime.max: 9999-12-31 23:59:59.999999  </li>
<li>#print: datetime.min: 0001-01-01 00:00:00  </li>
<li>from  datetime  import  *   </li>
<li>import time  </li>
<li>print   (‘datetime.max:’ +str(datetime.max ))   </li>
<li>print   (‘datetime.min:’ +str(datetime.min))    </li>
<li>#datetime.resolution：datetime最小单位；  </li>
<li>#print: datetime.resolution: 0:00:00.000001  </li>
<li>print   (‘datetime.resolution:’ + str(datetime.resolution ))  </li>
<li>#datetime.today()：返回一个表示当前本地时间的datetime对象；  </li>
<li>#print: today(): 2012-09-12 19:37:50.721000  </li>
<li>print   (‘today():’ +str(datetime.today() ))  </li>
<li>#datetime.now([tz])：返回一个表示当前本地时间的datetime对象，如果提供了参数tz，则获取tz参数所指时区的本地时间；  </li>
<li>#print: now(): 2012-09-12 19:37:50.738000  </li>
<li>print   (‘now():’+str( datetime.now() ))  </li>
<li>#datetime.utcnow()：返回一个当前utc时间的datetime对象；  </li>
<li>#print: 2012-09-12 11:37:50.739000  </li>
<li>print   (‘utcnow():’ +str(datetime.utcnow() ))   </li>
<li>#datetime.fromtimestamp(timestamp[, tz])：根据时间戮创建一个datetime对象，参数tz指定时区信息；  </li>
<li>#print: fromtimestamp(tmstmp): 2012-09-12 19:37:50.741000  </li>
<li>print   (‘fromtimestamp(tmstmp):’ +str(datetime.fromtimestamp(time.time()) ))  </li>
<li>#datetime.utcfromtimestamp(timestamp)：根据时间戮创建一个datetime对象；  </li>
<li>#print: utcfromtimestamp(tmstmp): 2012-09-12 11:37:50.742000  </li>
<li>print   (‘utcfromtimestamp(tmstmp):’ +str(datetime.utcfromtimestamp(time.time())) )  </li>
<li>#datetime.combine(date, time)：根据date和time，创建一个datetime对象；  </li>
<li>#print: datetime.combine(date,time):  2012-09-12 19:46:05  </li>
<li>d = date(2012,9,12)  </li>
<li>from  datetime  import  *   </li>
<li>t = time(19,46,5)  </li>
<li>print (‘datetime.combine(date,time): ‘+str(datetime.combine(d,t)))  </li>
<li>#datetime.strptime(date_string, format)：将格式字符串转换为datetime对象；  </li>
<li>#print: 2007-03-04 21:08:12  </li>
<li>print (datetime.strptime(“2007-03-04 21:08:12”, “%Y-%m-%d %H:%M:%S”))  </li>
<li></li>
<li></li>
<li>#2. datetime类提供的实例方法与属性  </li>
<li>dt = datetime.strptime(“2012-09-12 21:08:12”, “%Y-%m-%d %H:%M:%S”)  </li>
<li>#print: 2012 9 12 21 8 12 0 None  </li>
<li>print (dt.year)  </li>
<li>print(dt.month)  </li>
<li>print(dt.day)  </li>
<li>print(dt.hour)  </li>
<li>print(dt.minute)  </li>
<li>print(dt.second)  </li>
<li>print(dt.microsecond)  </li>
<li>print(dt.tzinfo)  </li>
<li>print (dt.date())  </li>
<li>print (dt.time())  </li>
<li>print (dt.replace(year = 2013))  </li>
<li>print (dt.timetuple())  </li>
<li>print (dt.utctimetuple())  </li>
<li>print (dt.toordinal())  </li>
<li>print (dt.weekday())  </li>
<li>print (dt.isocalendar())  </li>
<li>#print dt.isoformat([sep])  </li>
<li>#datetime. ctime ()：返回一个日期时间的C格式字符串，等效于time.ctime(time.mktime(dt.timetuple()))；  </li>
<li></li>
<li></li>
<li>#3. 格式字符串  </li>
<li><h1 id="datetime-strftime-format"><a href="#datetime-strftime-format" class="headerlink" title="datetime. strftime (format)"></a>datetime. strftime (format)</h1></li>
<li><h1 id="a-星期的简写。如-星期三为Web"><a href="#a-星期的简写。如-星期三为Web" class="headerlink" title="%a 星期的简写。如 星期三为Web"></a>%a 星期的简写。如 星期三为Web</h1></li>
<li><h1 id="A-星期的全写。如-星期三为Wednesday"><a href="#A-星期的全写。如-星期三为Wednesday" class="headerlink" title="%A 星期的全写。如 星期三为Wednesday"></a>%A 星期的全写。如 星期三为Wednesday</h1></li>
<li><h1 id="b-月份的简写。如4月份为Apr"><a href="#b-月份的简写。如4月份为Apr" class="headerlink" title="%b 月份的简写。如4月份为Apr"></a>%b 月份的简写。如4月份为Apr</h1></li>
<li><h1 id="B月份的全写。如4月份为April"><a href="#B月份的全写。如4月份为April" class="headerlink" title="%B月份的全写。如4月份为April"></a>%B月份的全写。如4月份为April</h1></li>
<li><h1 id="c-日期时间的字符串表示。（如：-04-07-10-10-43-39）"><a href="#c-日期时间的字符串表示。（如：-04-07-10-10-43-39）" class="headerlink" title="%c:  日期时间的字符串表示。（如： 04/07/10 10:43:39）"></a>%c:  日期时间的字符串表示。（如： 04/07/10 10:43:39）</h1></li>
<li><h1 id="d-日在这个月中的天数（是这个月的第几天）"><a href="#d-日在这个月中的天数（是这个月的第几天）" class="headerlink" title="%d:  日在这个月中的天数（是这个月的第几天）"></a>%d:  日在这个月中的天数（是这个月的第几天）</h1></li>
<li><h1 id="f-微秒（范围-0-999999-）"><a href="#f-微秒（范围-0-999999-）" class="headerlink" title="%f:  微秒（范围[0,999999]）"></a>%f:  微秒（范围[0,999999]）</h1></li>
<li><h1 id="H-小时（24小时制，-0-23-）"><a href="#H-小时（24小时制，-0-23-）" class="headerlink" title="%H:  小时（24小时制，[0, 23]）"></a>%H:  小时（24小时制，[0, 23]）</h1></li>
<li><h1 id="I-小时（12小时制，-0-11-）"><a href="#I-小时（12小时制，-0-11-）" class="headerlink" title="%I:  小时（12小时制，[0, 11]）"></a>%I:  小时（12小时制，[0, 11]）</h1></li>
<li><h1 id="j-日在年中的天数-001-366-（是当年的第几天）"><a href="#j-日在年中的天数-001-366-（是当年的第几天）" class="headerlink" title="%j:  日在年中的天数 [001,366]（是当年的第几天）"></a>%j:  日在年中的天数 [001,366]（是当年的第几天）</h1></li>
<li><h1 id="m-月份（-01-12-）"><a href="#m-月份（-01-12-）" class="headerlink" title="%m:  月份（[01,12]）"></a>%m:  月份（[01,12]）</h1></li>
<li><h1 id="M-分钟（-00-59-）"><a href="#M-分钟（-00-59-）" class="headerlink" title="%M:  分钟（[00,59]）"></a>%M:  分钟（[00,59]）</h1></li>
<li><h1 id="p-AM或者PM"><a href="#p-AM或者PM" class="headerlink" title="%p:  AM或者PM"></a>%p:  AM或者PM</h1></li>
<li><h1 id="S-秒（范围为-00-61-，为什么不是-00-59-，参考python手册-）"><a href="#S-秒（范围为-00-61-，为什么不是-00-59-，参考python手册-）" class="headerlink" title="%S:  秒（范围为[00,61]，为什么不是[00, 59]，参考python手册~_~）"></a>%S:  秒（范围为[00,61]，为什么不是[00, 59]，参考python手册~_~）</h1></li>
<li><h1 id="U-周在当年的周数当年的第几周），星期天作为周的第一天"><a href="#U-周在当年的周数当年的第几周），星期天作为周的第一天" class="headerlink" title="%U:  周在当年的周数当年的第几周），星期天作为周的第一天"></a>%U:  周在当年的周数当年的第几周），星期天作为周的第一天</h1></li>
<li><h1 id="w-今天在这周的天数，范围为-0-6-，6表示星期天"><a href="#w-今天在这周的天数，范围为-0-6-，6表示星期天" class="headerlink" title="%w:  今天在这周的天数，范围为[0, 6]，6表示星期天"></a>%w:  今天在这周的天数，范围为[0, 6]，6表示星期天</h1></li>
<li><h1 id="W-周在当年的周数（是当年的第几周），星期一作为周的第一天"><a href="#W-周在当年的周数（是当年的第几周），星期一作为周的第一天" class="headerlink" title="%W:  周在当年的周数（是当年的第几周），星期一作为周的第一天"></a>%W:  周在当年的周数（是当年的第几周），星期一作为周的第一天</h1></li>
<li><h1 id="x-日期字符串（如：04-07-10）"><a href="#x-日期字符串（如：04-07-10）" class="headerlink" title="%x:  日期字符串（如：04/07/10）"></a>%x:  日期字符串（如：04/07/10）</h1></li>
<li><h1 id="X-时间字符串（如：10-43-39）"><a href="#X-时间字符串（如：10-43-39）" class="headerlink" title="%X:  时间字符串（如：10:43:39）"></a>%X:  时间字符串（如：10:43:39）</h1></li>
<li><h1 id="y-2个数字表示的年份"><a href="#y-2个数字表示的年份" class="headerlink" title="%y:  2个数字表示的年份"></a>%y:  2个数字表示的年份</h1></li>
<li><h1 id="Y-4个数字表示的年份"><a href="#Y-4个数字表示的年份" class="headerlink" title="%Y:  4个数字表示的年份"></a>%Y:  4个数字表示的年份</h1></li>
<li><h1 id="z-与utc时间的间隔-（如果是本地时间，返回空字符串）"><a href="#z-与utc时间的间隔-（如果是本地时间，返回空字符串）" class="headerlink" title="%z:  与utc时间的间隔 （如果是本地时间，返回空字符串）"></a>%z:  与utc时间的间隔 （如果是本地时间，返回空字符串）</h1></li>
<li><h1 id="Z-时区名称（如果是本地时间，返回空字符串）"><a href="#Z-时区名称（如果是本地时间，返回空字符串）" class="headerlink" title="%Z:  时区名称（如果是本地时间，返回空字符串）"></a>%Z:  时区名称（如果是本地时间，返回空字符串）</h1></li>
<li><h1 id="gt"><a href="#gt" class="headerlink" title="%%:  %% =&gt; %"></a>%%:  %% =&gt; %</h1></li>
<li></li>
<li></li>
<li>dt = datetime.now()  </li>
<li>#print: (%Y-%m-%d %H:%M:%S %f):  2012-09-12 23:04:27 145000  </li>
<li>print (‘(%Y-%m-%d %H:%M:%S %f): ‘+ str(dt.strftime(‘%Y-%m-%d %H:%M:%S %f’)))  </li>
<li>#print: (%Y-%m-%d %H:%M:%S %p):  12-09-12 11:04:27 PM  </li>
<li>print (‘(%Y-%m-%d %H:%M:%S %p): ‘+str(dt.strftime(‘%y-%m-%d %I:%M:%S %p’)))  </li>
<li></li>
<li>#print: %a: Wed   </li>
<li>print (‘%%a: %s ‘ % dt.strftime(‘%a’))  </li>
<li>#print: %A: Wednesday  </li>
<li>print (‘%%A: %s ‘ % dt.strftime(‘%A’))  </li>
<li>#print: %b: Sep   </li>
<li>print (‘%%b: %s ‘ % dt.strftime(‘%b’))  </li>
<li>#print: %B: September  </li>
<li>print (‘%%B: %s ‘ % dt.strftime(‘%B’))  </li>
<li>#print: 日期时间%c: 09/12/12 23:04:27  </li>
<li>print (‘日期时间%%c: %s ‘ % dt.strftime(‘%c’))  </li>
<li>#print: 日期%x：09/12/12  </li>
<li>print (‘日期%%x：%s ‘ % dt.strftime(‘%x’))  </li>
<li>#print: 时间%X：23:04:27  </li>
<li>print (‘时间%%X：%s ‘ % dt.strftime(‘%X’))  </li>
<li>#print: 今天是这周的第3天  </li>
<li>print (‘今天是这周的第%s天 ‘ % dt.strftime(‘%w’))  </li>
<li>#print: 今天是今年的第256天   </li>
<li>print (‘今天是今年的第%s天 ‘ % dt.strftime(‘%j’))  </li>
<li>#print: 今周是今年的第37周  </li>
<li>print (‘今周是今年的第%s周 ‘ % dt.strftime(‘%U’))  </li>
</ol>
<h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><strong>[python]</strong> <a href="http://blog.csdn.net/wirelessqa/article/details/7973121/#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/wirelessqa/article/details/7973121/#" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li>atetime.max:9999-12-31 23:59:59.999999  </li>
<li>datetime.min:0001-01-01 00:00:00  </li>
<li>datetime.resolution:0:00:00.000001  </li>
<li>today():2014-05-04 15:58:18.141186  </li>
<li>now():2014-05-04 15:58:18.193146  </li>
<li>utcnow():2014-05-04 07:58:18.243958  </li>
<li>fromtimestamp(tmstmp):2014-05-04 15:58:18.291558  </li>
<li>utcfromtimestamp(tmstmp):2014-05-04 07:58:18.342550  </li>
<li>datetime.combine(date,time): 2012-09-12 19:46:05  </li>
<li>2007-03-04 21:08:12  </li>
<li>2012  </li>
<li>9  </li>
<li>12  </li>
<li>21  </li>
<li>8  </li>
<li>12  </li>
<li>0  </li>
<li>None  </li>
<li>2012-09-12  </li>
<li>21:08:12  </li>
<li>2013-09-12 21:08:12  </li>
<li>time.struct_time(tm_year=2012, tm_mon=9, tm_mday=12, tm_hour=21, tm_min=8, tm_sec=12, tm_wday=2, tm_yday=256, tm_isdst=-1)  </li>
<li>time.struct_time(tm_year=2012, tm_mon=9, tm_mday=12, tm_hour=21, tm_min=8, tm_sec=12, tm_wday=2, tm_yday=256, tm_isdst=0)  </li>
<li>734758  </li>
<li>2  </li>
<li>(2012, 37, 3)  </li>
<li>(%Y-%m-%d %H:%M:%S %f): 2014-05-04 15:58:19 326295  </li>
<li>(%Y-%m-%d %H:%M:%S %p): 14-05-04 03:58:19 PM  </li>
<li>%a: Sun   </li>
<li>%A: Sunday   </li>
<li>%b: May   </li>
<li>%B: May   </li>
<li>日期时间%c: Sun May  4 15:58:19 2014   </li>
<li>日期%x：05/04/14   </li>
<li>时间%X：15:58:19   </li>
<li>今天是这周的第0天   </li>
<li>今天是今年的第124天   </li>
<li>今周是今年的第18周   </li>
</ol>
<h1 id="运行环境-Python2-x"><a href="#运行环境-Python2-x" class="headerlink" title="运行环境:Python2.x"></a>运行环境:Python2.x</h1><p><strong>[python]</strong> <a href="http://blog.csdn.net/wirelessqa/article/details/7973121/#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/wirelessqa/article/details/7973121/#" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li><h1 id="coding-utf-8-1"><a href="#coding-utf-8-1" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1></li>
<li></li>
<li></li>
<li>#datetime类  </li>
<li>#datetime是date与time的结合体，包括date与time的所有信息。  </li>
<li>#它的构造函数如下：  </li>
<li>#datetime. datetime (year, month, day[ , hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ] )  </li>
<li>#各参数的含义与date、time的构造函数中的一样，要注意参数值的范围。  </li>
<li></li>
<li></li>
<li></li>
<li></li>
<li><h1 id="1-datetime类定义的类属性与方法：-1"><a href="#1-datetime类定义的类属性与方法：-1" class="headerlink" title="1. datetime类定义的类属性与方法："></a>1. datetime类定义的类属性与方法：</h1></li>
<li>#datetime.min、datetime.max：datetime所能表示的最小值与最大值；  </li>
<li>#print: datetime.max: 9999-12-31 23:59:59.999999  </li>
<li>#print: datetime.min: 0001-01-01 00:00:00  </li>
<li>from  datetime  import  *   </li>
<li>import time  </li>
<li>print   ‘datetime.max:’ , datetime.max    </li>
<li>print   ‘datetime.min:’ , datetime.min    </li>
<li>#datetime.resolution：datetime最小单位；  </li>
<li>#print: datetime.resolution: 0:00:00.000001  </li>
<li>print   ‘datetime.resolution:’ , datetime.resolution   </li>
<li>#datetime.today()：返回一个表示当前本地时间的datetime对象；  </li>
<li>#print: today(): 2012-09-12 19:37:50.721000  </li>
<li>print   ‘today():’ , datetime.today()   </li>
<li>#datetime.now([tz])：返回一个表示当前本地时间的datetime对象，如果提供了参数tz，则获取tz参数所指时区的本地时间；  </li>
<li>#print: now(): 2012-09-12 19:37:50.738000  </li>
<li>print   ‘now():’ , datetime.now()   </li>
<li>#datetime.utcnow()：返回一个当前utc时间的datetime对象；  </li>
<li>#print: 2012-09-12 11:37:50.739000  </li>
<li>print   ‘utcnow():’ , datetime.utcnow()    </li>
<li>#datetime.fromtimestamp(timestamp[, tz])：根据时间戮创建一个datetime对象，参数tz指定时区信息；  </li>
<li>#print: fromtimestamp(tmstmp): 2012-09-12 19:37:50.741000  </li>
<li>print   ‘fromtimestamp(tmstmp):’ , datetime.fromtimestamp(time.time())   </li>
<li>#datetime.utcfromtimestamp(timestamp)：根据时间戮创建一个datetime对象；  </li>
<li>#print: utcfromtimestamp(tmstmp): 2012-09-12 11:37:50.742000  </li>
<li>print   ‘utcfromtimestamp(tmstmp):’ , datetime.utcfromtimestamp(time.time())   </li>
<li>#datetime.combine(date, time)：根据date和time，创建一个datetime对象；  </li>
<li>#print: datetime.combine(date,time):  2012-09-12 19:46:05  </li>
<li>d = date(2012,9,12)  </li>
<li>from  datetime  import  *   </li>
<li>t = time(19,46,5)  </li>
<li>print ‘datetime.combine(date,time): ‘,datetime.combine(d,t)  </li>
<li>#datetime.strptime(date_string, format)：将格式字符串转换为datetime对象；  </li>
<li>#print: 2007-03-04 21:08:12  </li>
<li>print datetime.strptime(“2007-03-04 21:08:12”, “%Y-%m-%d %H:%M:%S”)  </li>
<li></li>
<li></li>
<li>#2. datetime类提供的实例方法与属性  </li>
<li>dt = datetime.strptime(“2012-09-12 21:08:12”, “%Y-%m-%d %H:%M:%S”)  </li>
<li>#print: 2012 9 12 21 8 12 0 None  </li>
<li>print dt.year,dt.month,dt.day,dt.hour,dt.minute,dt.second,dt.microsecond,dt.tzinfo  </li>
<li>print dt.date()  </li>
<li>print dt.time()  </li>
<li>print dt.replace(year = 2013)  </li>
<li>print dt.timetuple()  </li>
<li>print dt.utctimetuple()  </li>
<li>print dt.toordinal()  </li>
<li>print dt.weekday()  </li>
<li>print dt.isocalendar()  </li>
<li>#print dt.isoformat([sep])  </li>
<li>#datetime. ctime ()：返回一个日期时间的C格式字符串，等效于time.ctime(time.mktime(dt.timetuple()))；  </li>
<li></li>
<li></li>
<li>#3. 格式字符串  </li>
<li><h1 id="datetime-strftime-format-1"><a href="#datetime-strftime-format-1" class="headerlink" title="datetime. strftime (format)"></a>datetime. strftime (format)</h1></li>
<li><h1 id="a-星期的简写。如-星期三为Web-1"><a href="#a-星期的简写。如-星期三为Web-1" class="headerlink" title="%a 星期的简写。如 星期三为Web"></a>%a 星期的简写。如 星期三为Web</h1></li>
<li><h1 id="A-星期的全写。如-星期三为Wednesday-1"><a href="#A-星期的全写。如-星期三为Wednesday-1" class="headerlink" title="%A 星期的全写。如 星期三为Wednesday"></a>%A 星期的全写。如 星期三为Wednesday</h1></li>
<li><h1 id="b-月份的简写。如4月份为Apr-1"><a href="#b-月份的简写。如4月份为Apr-1" class="headerlink" title="%b 月份的简写。如4月份为Apr"></a>%b 月份的简写。如4月份为Apr</h1></li>
<li><h1 id="B月份的全写。如4月份为April-1"><a href="#B月份的全写。如4月份为April-1" class="headerlink" title="%B月份的全写。如4月份为April"></a>%B月份的全写。如4月份为April</h1></li>
<li><h1 id="c-日期时间的字符串表示。（如：-04-07-10-10-43-39）-1"><a href="#c-日期时间的字符串表示。（如：-04-07-10-10-43-39）-1" class="headerlink" title="%c:  日期时间的字符串表示。（如： 04/07/10 10:43:39）"></a>%c:  日期时间的字符串表示。（如： 04/07/10 10:43:39）</h1></li>
<li><h1 id="d-日在这个月中的天数（是这个月的第几天）-1"><a href="#d-日在这个月中的天数（是这个月的第几天）-1" class="headerlink" title="%d:  日在这个月中的天数（是这个月的第几天）"></a>%d:  日在这个月中的天数（是这个月的第几天）</h1></li>
<li><h1 id="f-微秒（范围-0-999999-）-1"><a href="#f-微秒（范围-0-999999-）-1" class="headerlink" title="%f:  微秒（范围[0,999999]）"></a>%f:  微秒（范围[0,999999]）</h1></li>
<li><h1 id="H-小时（24小时制，-0-23-）-1"><a href="#H-小时（24小时制，-0-23-）-1" class="headerlink" title="%H:  小时（24小时制，[0, 23]）"></a>%H:  小时（24小时制，[0, 23]）</h1></li>
<li><h1 id="I-小时（12小时制，-0-11-）-1"><a href="#I-小时（12小时制，-0-11-）-1" class="headerlink" title="%I:  小时（12小时制，[0, 11]）"></a>%I:  小时（12小时制，[0, 11]）</h1></li>
<li><h1 id="j-日在年中的天数-001-366-（是当年的第几天）-1"><a href="#j-日在年中的天数-001-366-（是当年的第几天）-1" class="headerlink" title="%j:  日在年中的天数 [001,366]（是当年的第几天）"></a>%j:  日在年中的天数 [001,366]（是当年的第几天）</h1></li>
<li><h1 id="m-月份（-01-12-）-1"><a href="#m-月份（-01-12-）-1" class="headerlink" title="%m:  月份（[01,12]）"></a>%m:  月份（[01,12]）</h1></li>
<li><h1 id="M-分钟（-00-59-）-1"><a href="#M-分钟（-00-59-）-1" class="headerlink" title="%M:  分钟（[00,59]）"></a>%M:  分钟（[00,59]）</h1></li>
<li><h1 id="p-AM或者PM-1"><a href="#p-AM或者PM-1" class="headerlink" title="%p:  AM或者PM"></a>%p:  AM或者PM</h1></li>
<li><h1 id="S-秒（范围为-00-61-，为什么不是-00-59-，参考python手册-）-1"><a href="#S-秒（范围为-00-61-，为什么不是-00-59-，参考python手册-）-1" class="headerlink" title="%S:  秒（范围为[00,61]，为什么不是[00, 59]，参考python手册~_~）"></a>%S:  秒（范围为[00,61]，为什么不是[00, 59]，参考python手册~_~）</h1></li>
<li><h1 id="U-周在当年的周数当年的第几周），星期天作为周的第一天-1"><a href="#U-周在当年的周数当年的第几周），星期天作为周的第一天-1" class="headerlink" title="%U:  周在当年的周数当年的第几周），星期天作为周的第一天"></a>%U:  周在当年的周数当年的第几周），星期天作为周的第一天</h1></li>
<li><h1 id="w-今天在这周的天数，范围为-0-6-，6表示星期天-1"><a href="#w-今天在这周的天数，范围为-0-6-，6表示星期天-1" class="headerlink" title="%w:  今天在这周的天数，范围为[0, 6]，6表示星期天"></a>%w:  今天在这周的天数，范围为[0, 6]，6表示星期天</h1></li>
<li><h1 id="W-周在当年的周数（是当年的第几周），星期一作为周的第一天-1"><a href="#W-周在当年的周数（是当年的第几周），星期一作为周的第一天-1" class="headerlink" title="%W:  周在当年的周数（是当年的第几周），星期一作为周的第一天"></a>%W:  周在当年的周数（是当年的第几周），星期一作为周的第一天</h1></li>
<li><h1 id="x-日期字符串（如：04-07-10）-1"><a href="#x-日期字符串（如：04-07-10）-1" class="headerlink" title="%x:  日期字符串（如：04/07/10）"></a>%x:  日期字符串（如：04/07/10）</h1></li>
<li><h1 id="X-时间字符串（如：10-43-39）-1"><a href="#X-时间字符串（如：10-43-39）-1" class="headerlink" title="%X:  时间字符串（如：10:43:39）"></a>%X:  时间字符串（如：10:43:39）</h1></li>
<li><h1 id="y-2个数字表示的年份-1"><a href="#y-2个数字表示的年份-1" class="headerlink" title="%y:  2个数字表示的年份"></a>%y:  2个数字表示的年份</h1></li>
<li><h1 id="Y-4个数字表示的年份-1"><a href="#Y-4个数字表示的年份-1" class="headerlink" title="%Y:  4个数字表示的年份"></a>%Y:  4个数字表示的年份</h1></li>
<li><h1 id="z-与utc时间的间隔-（如果是本地时间，返回空字符串）-1"><a href="#z-与utc时间的间隔-（如果是本地时间，返回空字符串）-1" class="headerlink" title="%z:  与utc时间的间隔 （如果是本地时间，返回空字符串）"></a>%z:  与utc时间的间隔 （如果是本地时间，返回空字符串）</h1></li>
<li><h1 id="Z-时区名称（如果是本地时间，返回空字符串）-1"><a href="#Z-时区名称（如果是本地时间，返回空字符串）-1" class="headerlink" title="%Z:  时区名称（如果是本地时间，返回空字符串）"></a>%Z:  时区名称（如果是本地时间，返回空字符串）</h1></li>
<li><h1 id="gt-1"><a href="#gt-1" class="headerlink" title="%%:  %% =&gt; %"></a>%%:  %% =&gt; %</h1></li>
<li></li>
<li></li>
<li>dt = datetime.now()  </li>
<li>#print: (%Y-%m-%d %H:%M:%S %f):  2012-09-12 23:04:27 145000  </li>
<li>print ‘(%Y-%m-%d %H:%M:%S %f): ‘, dt.strftime(‘%Y-%m-%d %H:%M:%S %f’)  </li>
<li>#print: (%Y-%m-%d %H:%M:%S %p):  12-09-12 11:04:27 PM  </li>
<li>print ‘(%Y-%m-%d %H:%M:%S %p): ‘, dt.strftime(‘%y-%m-%d %I:%M:%S %p’)  </li>
<li>#print: %a: Wed   </li>
<li>print ‘%%a: %s ‘ % dt.strftime(‘%a’)  </li>
<li>#print: %A: Wednesday  </li>
<li>print ‘%%A: %s ‘ % dt.strftime(‘%A’)  </li>
<li>#print: %b: Sep   </li>
<li>print ‘%%b: %s ‘ % dt.strftime(‘%b’)  </li>
<li>#print: %B: September  </li>
<li>print ‘%%B: %s ‘ % dt.strftime(‘%B’)  </li>
<li>#print: 日期时间%c: 09/12/12 23:04:27  </li>
<li>print ‘日期时间%%c: %s ‘ % dt.strftime(‘%c’)  </li>
<li>#print: 日期%x：09/12/12  </li>
<li>print ‘日期%%x：%s ‘ % dt.strftime(‘%x’)  </li>
<li>#print: 时间%X：23:04:27  </li>
<li>print ‘时间%%X：%s ‘ % dt.strftime(‘%X’)  </li>
<li>#print: 今天是这周的第3天  </li>
<li>print ‘今天是这周的第%s天 ‘ % dt.strftime(‘%w’)  </li>
<li>#print: 今天是今年的第256天   </li>
<li>print ‘今天是今年的第%s天 ‘ % dt.strftime(‘%j’)  </li>
<li>#print: 今周是今年的第37周  </li>
<li>print ‘今周是今年的第%s周 ‘ % dt.strftime(‘%U’)  </li>
</ol>
<p>顶</p>
<pre><code>0
</code></pre><p>踩</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PostgreSQL连接Python]]></title>
      <url>https://shijingjing07.github.io/2016/08/09/PostgreSQL%E8%BF%9E%E6%8E%A5Python/</url>
      <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>PostgreSQL可以用Python psycopg2模块集成。 sycopg2是Python编程语言的PostgreSQL数据库的适配器。<br>其程序代码少，速度快，稳定。不需要单独安装这个模块，因为它默认情况下被运往随着Python版本在2.5.x一起的。如果不把它安装在机器上，然后可<br>以使用pip命令安装它，如下所示：</p>
<pre><code>$sudo pip install psycopg2
 www.yiibai.com 
</code></pre><p>要使用psycopg2的模块，首先必须创建一个Connection对象，它表示数据库然后再可以选择创建游标对象，这将帮助执行的所有SQL语句。<br>www.yiibai.com</p>
<h2 id="Python-psycopg2-模块APIs"><a href="#Python-psycopg2-模块APIs" class="headerlink" title="Python psycopg2 模块APIs"></a>Python psycopg2 模块APIs</h2><p>以下是psycopg2的重要的的模块例程可以满足Python程序与PostgreSQL数据库的工作。如果寻找一个更复杂的应用程序，那么可以看看Python<br>psycopg2的模块的官方文档。 www.yiibai.com</p>
<table>
<thead>
<tr>
<th>S.N.</th>
<th>API &amp; 描述  </th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>**psycopg2.connect(database=”testdb”, user=”postgres”,</td>
</tr>
</tbody>
</table>
<p>password=”cohondob”, host=”127.0.0.1”, port=”5432”)**  </p>
<p>这个API打开一个连接到PostgreSQL数据库。如果成功打开数据库时，它返回一个连接对象。 www.yiibai.com  </p>
<p>2 |  <strong>connection.cursor()</strong>  </p>
<p>该程序创建一个光标将用于整个数据库使用Python编程。 yiibai.com  </p>
<p>3 |  <strong>cursor.execute(sql [, optional parameters])</strong>  </p>
<p>此例程执行SQL语句。可被参数化的SQL语句（即占位符，而不是SQL文字）。 psycopg2的模块支持占位符用％s标志 yiibai.com</p>
<p>例如：cursor.execute(“insert into people values (%s, %s)”, (who, age))</p>
<p>4 |  <strong>curosr.executemany(sql, seq_of_parameters)</strong>  </p>
<p>该程序执行SQL命令对所有参数序列或序列中的sql映射。 www.yiibai.com  </p>
<p>5 |  <strong>curosr.callproc(procname[, parameters])</strong>  </p>
<p>这个程序执行的存储数据库程序给定的名称。该程序预计为每一个参数，参数的顺序必须包含一个条目。</p>
<p>6 |  <strong>cursor.rowcount</strong>  </p>
<p>这个只读属性，它返回数据库中的行的总数已修改，插入或删除最后 execute*().</p>
<p>7 |  <strong>connection.commit()</strong>  </p>
<p>此方法提交当前事务。如果不调用这个方法，无论做了什么修改，自从上次调用commit()是不可见的，从其他的数据库连接。</p>
<p>8 |  <strong>connection.rollback()</strong>  </p>
<p>此方法会回滚任何更改数据库自上次调用commit（）方法。</p>
<p>9 |  <strong>connection.close()</strong>  </p>
<p>此方法关闭数据库连接。请注意，这并不自动调用commit（）。如果你只是关闭数据库连接而不调用commit（）方法首先，那么所有更改将会丢失！<br>www.yiibai.com  </p>
<p>10 |  <strong>cursor.fetchone()</strong>  </p>
<p>这种方法提取的查询结果集的下一行，返回一个序列，或者无当没有更多的数据是可用的。</p>
<p>11 |  <strong>cursor.fetchmany([size=cursor.arraysize])</strong>  </p>
<p>这个例程中取出下一个组的查询结果的行数，返回一个列表。当没有找到记录，返回空列表。该方法试图获取尽可能多的行所显示的大小参数。</p>
<p>12 |  <strong>cursor.fetchall()</strong>  </p>
<p>这个例程获取所有查询结果（剩余）行，返回一个列表。空行时则返回空列表。 www.yiibai.com  </p>
<h2 id="连接到数据库"><a href="#连接到数据库" class="headerlink" title="连接到数据库"></a>连接到数据库</h2><p>Python代码显示了如何连接到一个现有的数据库。如果数据库不存在，那么它就会被创建，最终将返回一个数据库对象。 yiibai.com</p>
<pre><code>#!/usr/bin/python

import psycopg2

conn = psycopg2.connect(database=&quot;testdb&quot;, user=&quot;postgres&quot;, password=&quot;pass123&quot;, host=&quot;127.0.0.1&quot;, port=&quot;5432&quot;)

print &quot;Opened database successfully&quot;  
</code></pre><p>在这里，也可以提供数据库testdb的名称，如果数据库成功打开，那么它会给下面的消息：</p>
<pre><code>Open database successfully
</code></pre><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>以下Python程序将使用以前创建的数据库中创建一个表：</p>
<pre><code>#!/usr/bin/python

import psycopg2

conn = psycopg2.connect(database=&quot;testdb&quot;, user=&quot;postgres&quot;, password=&quot;pass123&quot;, host=&quot;127.0.0.1&quot;, port=&quot;5432&quot;)
print &quot;Opened database successfully&quot;

cur = conn.cursor()
cur.execute(&apos;&apos;&apos;CREATE TABLE COMPANY
       (ID INT PRIMARY KEY     NOT NULL,
       NAME           TEXT    NOT NULL,
       AGE            INT     NOT NULL,
       ADDRESS        CHAR(50),
       SALARY         REAL);&apos;&apos;&apos;)
print &quot;Table created successfully&quot;

conn.commit()
conn.close()  
</code></pre><p>上述程序执行时，它会创建表COMPANY 在数据库test.db中，它会显示以下消息：</p>
<pre><code>Opened database successfully
Table created successfully
</code></pre><h2 id="INSERT-操作"><a href="#INSERT-操作" class="headerlink" title="INSERT 操作"></a>INSERT 操作</h2><p>Python程序显示了我们如何创建表COMPANY 在上面的例子中创建表中的记录：</p>
<pre><code>#!/usr/bin/python

import psycopg2

conn = psycopg2.connect(database=&quot;testdb&quot;, user=&quot;postgres&quot;, password=&quot;pass123&quot;, host=&quot;127.0.0.1&quot;, port=&quot;5432&quot;)
print &quot;Opened database successfully&quot;

cur = conn.cursor()

cur.execute(&quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \
      VALUES (1, &apos;Paul&apos;, 32, &apos;California&apos;, 20000.00 )&quot;);

cur.execute(&quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \
      VALUES (2, &apos;Allen&apos;, 25, &apos;Texas&apos;, 15000.00 )&quot;);

cur.execute(&quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \
      VALUES (3, &apos;Teddy&apos;, 23, &apos;Norway&apos;, 20000.00 )&quot;);

cur.execute(&quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \
      VALUES (4, &apos;Mark&apos;, 25, &apos;Rich-Mond &apos;, 65000.00 )&quot;);

conn.commit()
print &quot;Records created successfully&quot;;
conn.close() yiibai.com 
</code></pre><p>上述程序执行时，它会创建COMPANY表中的记录，并显示以下两行：</p>
<pre><code>Opened database successfully
Records created successfully
 yiibai.com 
</code></pre><h2 id="SELECT-操作"><a href="#SELECT-操作" class="headerlink" title="SELECT 操作"></a>SELECT 操作</h2><p>Python程序，显示如何获取并显示COMPANY 表在上面的例子中创建的记录：</p>
<pre><code>#!/usr/bin/python

import psycopg2

conn = psycopg2.connect(database=&quot;testdb&quot;, user=&quot;postgres&quot;, password=&quot;pass123&quot;, host=&quot;127.0.0.1&quot;, port=&quot;5432&quot;)
print &quot;Opened database successfully&quot;

cur = conn.cursor()

cur.execute(&quot;SELECT id, name, address, salary  from COMPANY&quot;)
rows = cur.fetchall()
for row in rows:
   print &quot;ID = &quot;, row[0]
   print &quot;NAME = &quot;, row[1]
   print &quot;ADDRESS = &quot;, row[2]
   print &quot;SALARY = &quot;, row[3], &quot;\n&quot;

print &quot;Operation done successfully&quot;;
conn.close()  
</code></pre><p>当上述程序执行时，它会产生以下结果：</p>
<pre><code>Opened database successfully
ID =  1
NAME =  Paul
ADDRESS =  California
SALARY =  20000.0

ID =  2
NAME =  Allen
ADDRESS =  Texas
SALARY =  15000.0

ID =  3
NAME =  Teddy
ADDRESS =  Norway
SALARY =  20000.0

ID =  4
NAME =  Mark
ADDRESS =  Rich-Mond
SALARY =  65000.0

Operation done successfully
</code></pre><h2 id="UPDATE-操作"><a href="#UPDATE-操作" class="headerlink" title="UPDATE 操作"></a>UPDATE 操作</h2><p>Python代码显示如何，我们可以使用UPDATE语句来更新记录，然后从COMPANY表获取并显示更新的记录：</p>
<pre><code>#!/usr/bin/python

import psycopg2

conn = psycopg2.connect(database=&quot;testdb&quot;, user=&quot;postgres&quot;, password=&quot;pass123&quot;, host=&quot;127.0.0.1&quot;, port=&quot;5432&quot;)
print &quot;Opened database successfully&quot;

cur = conn.cursor()

cur.execute(&quot;UPDATE COMPANY set SALARY = 25000.00 where ID=1&quot;)
conn.commit
print &quot;Total number of rows updated :&quot;, cur.rowcount

cur.execute(&quot;SELECT id, name, address, salary  from COMPANY&quot;)
rows = cur.fetchall()
for row in rows:
   print &quot;ID = &quot;, row[0]
   print &quot;NAME = &quot;, row[1]
   print &quot;ADDRESS = &quot;, row[2]
   print &quot;SALARY = &quot;, row[3], &quot;\n&quot;

print &quot;Operation done successfully&quot;;
conn.close()  
</code></pre><p>当上述程序执行时，它会产生以下结果：</p>
<pre><code>Opened database successfully
Total number of rows updated : 1
ID =  1
NAME =  Paul
ADDRESS =  California
SALARY =  25000.0

ID =  2
NAME =  Allen
ADDRESS =  Texas
SALARY =  15000.0

ID =  3
NAME =  Teddy
ADDRESS =  Norway
SALARY =  20000.0

ID =  4
NAME =  Mark
ADDRESS =  Rich-Mond
SALARY =  65000.0

Operation done successfully
</code></pre><h2 id="DELETE-操作"><a href="#DELETE-操作" class="headerlink" title="DELETE 操作"></a>DELETE 操作</h2><p>Python代码显示了如何我们可以使用DELETE语句删除记录，然后获取并显示COMPANY 表剩余的记录：</p>
<pre><code>#!/usr/bin/python

import psycopg2

conn = psycopg2.connect(database=&quot;testdb&quot;, user=&quot;postgres&quot;, password=&quot;pass123&quot;, host=&quot;127.0.0.1&quot;, port=&quot;5432&quot;)
print &quot;Opened database successfully&quot;

cur = conn.cursor()

cur.execute(&quot;DELETE from COMPANY where ID=2;&quot;)
conn.commit
print &quot;Total number of rows deleted :&quot;, cur.rowcount

cur.execute(&quot;SELECT id, name, address, salary  from COMPANY&quot;)
rows = cur.fetchall()
for row in rows:
   print &quot;ID = &quot;, row[0]
   print &quot;NAME = &quot;, row[1]
   print &quot;ADDRESS = &quot;, row[2]
   print &quot;SALARY = &quot;, row[3], &quot;\n&quot;

print &quot;Operation done successfully&quot;;
conn.close()  
</code></pre><p>当上述程序执行时，它会产生以Opened database successfully</p>
<pre><code>_Total number of rows deleted : 1
ID =  1
NAME =  Paul
ADDRESS =  California
SALARY =  20000.0

ID =  3
NAME =  Teddy
ADDRESS =  Norway
SALARY =  20000.0

ID =  4
NAME =  Mark
ADDRESS =  Rich-Mond
SALARY =  65000.0

Operation done successfully   

_转自：&lt;http://www.yiibai.com/html/postgresql/2013/080998.html&gt;_  
www.yiibai.c  

转子_
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Castle]]></title>
      <url>https://shijingjing07.github.io/2016/08/06/Castle/</url>
      <content type="html"><![CDATA[<h1 id="Castle-AOP"><a href="#Castle-AOP" class="headerlink" title="[Castle AOP"></a>[Castle AOP</h1><p>系列(一)：对类方法调用的拦截（有源码）](<a href="http://blog.csdn.net/liuweitoo/article/details/8166976" target="_blank" rel="external">http://blog.csdn.net/liuweitoo/article/details/8166976</a>)</p>
<p>标签：<br><a href="http://www.csdn.net/tag/aop" target="_blank" rel="external">aop</a><a href="http://www.csdn.net/tag/AOP" target="_blank" rel="external">AOP</a><a href="http://www.csdn.net/tag/Castle" target="_blank" rel="external">Castle</a><a href="http://www.csdn.net/tag/%e5%af%b9%e7%b1%bb%e6%96%b9%e6%b3%95%e8%b0%83%e7%94%a8%e7%9a%84%e6%8b%a6%e6%88%aa" target="_blank" rel="external">对类方法调用的拦截</a></p>
<p>2012-11-09 16:51 4207人阅读<br><a href="http://blog.csdn.net/liuweitoo/article/details/8166976#comments" target="_blank" rel="external">评论</a>(1) 收藏<br><a href="http://blog.csdn.net/liuweitoo/article/details/8166976#report" title="举报" target="_blank" rel="external">举报</a></p>
<p><img src="http://static.blog.csdn.net/images/category_icon.jpg" alt=""> 分类：</p>
<p>OO（17） <img src="http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg" alt=""></p>
<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>
<p>目录<a href="http://blog.csdn.net/liuweitoo/article/details/8166976#" title="系统根据文章中H1到H6标签自动生成文章目录" target="_blank" rel="external">(?)</a><a href="http://blog.csdn.net/liuweitoo/article/details/8166976#" title="展开" target="_blank" rel="external">[+]</a></p>
<p>Castle的相关网站：</p>
<p><a href="http://www.castleproject.org/" target="_blank" rel="external">http://www.castleproject.org/</a><br><a href="http://www.castleproject.org/projects/dynamicproxy/" target="_blank" rel="external">http://www.castleproject.org/projects/dynamicproxy/</a><br><a href="http://sourceforge.net/projects/castleproject/" target="_blank" rel="external">http://sourceforge.net/projects/castleproject/</a></p>
<h2 id="在Castle的2-5以上版本，已经将-Castle-DynamicProxy2-dll-里有内容，集成到-Castle-Core-dll-中。"><a href="#在Castle的2-5以上版本，已经将-Castle-DynamicProxy2-dll-里有内容，集成到-Castle-Core-dll-中。" class="headerlink" title="在Castle的2.5以上版本，已经将 Castle.DynamicProxy2.dll 里有内容，集成到 Castle.Core.dll 中。"></a>在Castle的2.5以上版本，已经将 Castle.DynamicProxy2.dll 里有内容，集成到 Castle.Core.dll 中。</h2><p>所以，朋友们，不需要再去哪里找Castle.DynamicProxy2.dll了。</p>
<p>当然，除非你使用低于2.5的版本。</p>
<p>本文使用的Castle.Core.dll是3.1版本。</p>
<p><strong>由于方法的拦载是动态构建类型，所以我们在拦截类方法时，可以采取用动态构造类的方式，从该类继承一个子类，重载并改写类中需要拦截的方法。</strong></p>
<p><strong>因此，我们不难理解，为什么在Castle 的 AOP中实现对类方法的拦截，都需要该类中的可被拦载的方法都是能够被子类重载的(override)。</strong></p>
<h2 id="CastleAOPTest-Lib-Person的代码"><a href="#CastleAOPTest-Lib-Person的代码" class="headerlink" title="CastleAOPTest.Lib.Person的代码"></a>CastleAOPTest.Lib.Person的代码</h2><p><strong>[csharp]</strong> <a href="http://blog.csdn.net/liuweitoo/article/details/8166976#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/liuweitoo/article/details/8166976#" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li>using System;  </li>
<li>using System.Collections.Generic;  </li>
<li>using System.Linq;  </li>
<li>using System.Text;  </li>
<li></li>
<li>namespace CastleAOPTest.Lib  </li>
<li>{  </li>
<li>public class Person  </li>
<li>{  </li>
<li>public virtual void SayHello()  </li>
<li>{  </li>
<li>Console.WriteLine(“您好！”);  </li>
<li>}  </li>
<li></li>
<li>public virtual void SayName(string pHometown)  </li>
<li>{  </li>
<li>Console.WriteLine(“我是天涯人，我来自：{0}。”, pHometown);  </li>
<li>}  </li>
<li></li>
<li>public void SayOther()  </li>
<li>{  </li>
<li>Console.WriteLine(“是的，我是中国人。”);  </li>
<li>}  </li>
<li></li>
<li>}  </li>
<li>}  </li>
</ol>
<p>这个类型没什么好说的，只是输出一些字符串而以。</p>
<p>惟一需要注意的是：前两个方法都是虚方法，而”SayOther”不是虚方法，即是说”SayOther”不可以用一般的方式重载。</p>
<h2 id="方法拦载器CastleAOPTest-Lib-AOP-SimpleInterceptor的代码："><a href="#方法拦载器CastleAOPTest-Lib-AOP-SimpleInterceptor的代码：" class="headerlink" title="方法拦载器CastleAOPTest.Lib.AOP.SimpleInterceptor的代码："></a>方法拦载器CastleAOPTest.Lib.AOP.SimpleInterceptor的代码：</h2><p><strong>[csharp]</strong> <a href="http://blog.csdn.net/liuweitoo/article/details/8166976#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/liuweitoo/article/details/8166976#" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li>using System;  </li>
<li>using System.Collections.Generic;  </li>
<li>using System.Linq;  </li>
<li>using System.Text;  </li>
<li></li>
<li>using CastleAOPTest.Lib;  </li>
<li>using Castle.DynamicProxy;  </li>
<li></li>
<li>namespace CastleAOPTest.Lib.AOP  </li>
<li>{  </li>
<li>public class SimpleInterceptor : StandardInterceptor  </li>
<li>{  </li>
<li>protected override void PreProceed(IInvocation invocation)  </li>
<li>{  </li>
<li>Console.WriteLine(“调用前的拦截器，方法名是：{0}。”, invocation.Method.Name);  </li>
<li>base.PreProceed(invocation);  </li>
<li></li>
<li>}  </li>
<li></li>
<li>protected override void PerformProceed(IInvocation invocation)  </li>
<li>{  </li>
<li>Console.WriteLine(“拦截的方法返回时调用的拦截器，方法名是：{0}。”, invocation.Method.Name);  </li>
<li>base.PerformProceed(invocation);  </li>
<li></li>
<li>}  </li>
<li></li>
<li></li>
<li>protected override void PostProceed(IInvocation invocation)  </li>
<li>{  </li>
<li>Console.WriteLine(“调用后的拦截器，方法名是：{0}。”, invocation.Method.Name);  </li>
<li>base.PostProceed(invocation);  </li>
<li></li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>Castle DynamicProxy提供了一个标准的方法拦截器，在一般的情况下，从这个标准的拦截器继承便可以完成大部分方法拦载上面的需求。</p>
<p>StandardInterceptor中提供了三个可重载的方法：</p>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p>1.PreProcced，在进入拦截的方法之前调用。</p>
<h3 id="2-PerformProceed，在拦截的方法返回时调用。"><a href="#2-PerformProceed，在拦截的方法返回时调用。" class="headerlink" title="2.PerformProceed，在拦截的方法返回时调用。"></a>2.PerformProceed，在拦截的方法返回时调用。</h3><h3 id="3-PostProcced，在拦截的方法运行完成后调用。"><a href="#3-PostProcced，在拦截的方法运行完成后调用。" class="headerlink" title="3.PostProcced，在拦截的方法运行完成后调用。"></a>3.PostProcced，在拦截的方法运行完成后调用。</h3><h2 id="如何使用这个写好的拦截器"><a href="#如何使用这个写好的拦截器" class="headerlink" title="如何使用这个写好的拦截器"></a>如何使用这个写好的拦截器</h2><p><strong>[csharp]</strong> <a href="http://blog.csdn.net/liuweitoo/article/details/8166976#" title="view plain" target="_blank" rel="external">view plain</a> <a href="http://blog.csdn.net/liuweitoo/article/details/8166976#" title="copy" target="_blank" rel="external">copy</a></p>
<ol>
<li>using System;  </li>
<li>using System.Collections.Generic;  </li>
<li>using System.Linq;  </li>
<li>using System.Text;  </li>
<li></li>
<li>using Castle.DynamicProxy;  </li>
<li>using CastleAOPTest.Lib;  </li>
<li>using CastleAOPTest.Lib.AOP;   </li>
<li></li>
<li>namespace CastleAOPTest.Run  </li>
<li>{  </li>
<li>class Program  </li>
<li>{  </li>
<li>static void Main(string[] args)  </li>
<li>{  </li>
<li>ProxyGenerator generator = new ProxyGenerator();//实例化【代理类生成器】  </li>
<li>SimpleInterceptor interceptor = new SimpleInterceptor();//实例化【拦截器】  </li>
<li></li>
<li>//使用【代理类生成器】创建Person对象，而不是使用new关键字来实例化  </li>
<li>Person person = generator.CreateClassProxy&lt;Person&gt;(interceptor);  </li>
<li></li>
<li></li>
<li>Console.WriteLine(“当前类型:{0},父类型:{1}”,person.GetType(), person.GetType().BaseType);  </li>
<li>Console.WriteLine();  </li>
<li></li>
<li></li>
<li>person.SayHello();//跟普通调用没有两样吧？  </li>
<li>Console.WriteLine();  </li>
<li></li>
<li>person.SayName(“福建”);//跟普通调用没有两样吧？  </li>
<li>Console.WriteLine();  </li>
<li></li>
<li>person.SayOther();//它不是虚方法，无法拦截。待会检测输出情况就知道了。     </li>
<li></li>
<li></li>
<li></li>
<li>Console.ReadLine();     </li>
<li></li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>ProxyGenerator其实是一个动态的类型构造器，它依据Person类型，并加入相应的拦载器构造出了一个新的类型，我们来查看一下运行输出：</p>
<p><img src="http://img.my.csdn.net/uploads/201211/09/1352451202_8669.jpg" alt=""></p>
<p>根据输出的第一行，我们可以知道，ProxyGenerator构造了一个新的类型，这个类型继承自Person。</p>
<p>由于这个类型的SayOther方法不可以被子类重载，所以这个方法无法被拦截。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[timestamp 与 rowversion]]></title>
      <url>https://shijingjing07.github.io/2016/07/30/timestamp%20%E4%B8%8E%20rowversion/</url>
      <content type="html"><![CDATA[<p>联机丛书：</p>
<p>timestamp</p>
<p>timestamp 这种数据类型表现自动生成的二进制数，确保这些数在数据库中是唯一的。timestamp 一般用作给表行加版本戳的机制。存储大小为 8<br>字节。</p>
<p>注释</p>
<p>Transact-SQL timestamp 数据类型与在 SQL-92 标准中定义的 timestamp 数据类型不同。SQL-92 timestamp<br>数据类型等价于 Transact-SQL datetime 数据类型。</p>
<p>Microsoft® SQL Server™ 将来的版本可能会修改 Transact-SQL timestamp<br>数据类型的行为，使它与在标准中定义的行为一致。到那时，当前的 timestamp 数据类型将用 rowversion 数据类型替换。</p>
<p>Microsoft® SQL Server™ 2000 引入了 timestamp 数据类型的 rowversion 同义词。在 DDL 语句中尽可能使用<br>rowversion 而不使用 timestamp。rowversion 受数据类型同义词行为的制约。有关更多信息，请参见数据类型同义词。</p>
<p>在 CREATE TABLE 或 ALTER TABLE 语句中，不必为 timestamp 数据类型提供列名：</p>
<p>CREATE TABLE ExampleTable (PriKey int PRIMARY KEY, timestamp)</p>
<p>如果没有提供列名，SQL Server 将生成 timestamp 的列名。rowversion 数据类型同义词不具有这样的行为。指定 rowversion<br>时必须提供列名。</p>
<p>一个表只能有一个 timestamp 列。每次插入或更新包含 timestamp 列的行时，timestamp 列中的值均会更新。这一属性使<br>timestamp 列不适合作为键使用，尤其是不能作为主键使用。对行的任何更新都会更改 timestamp<br>值，从而更改键值。如果该列属于主键，那么旧的键值将无效，进而引用该旧值的外键也将不再有效。如果该表在动态游标中引用，则所有更新均会更改游标中行的位置。如果该列属于索引键，则对数据行的所有更新还将导致索引更新。</p>
<p>不可为空的 timestamp 列在语义上等价于 binary(8) 列。可为空的 timestamp 列在语义上等价于 varbinary(8) 列。</p>
<pre><code>IF OBJECT_ID(&apos;test_timestamp&apos;) IS NOT NULL  
BEGIN  
    DROP TABLE test_timestamp  
END  
GO  
CREATE TABLE test_timestamp  
(  
    id INT PRIMARY KEY IDENTITY(1,1),  
    tname NVARCHAR(20),  
    [rowversion] TIMESTAMP    
)  
GO  
INSERT INTO test_timestamp (tname)  
SELECT &apos;t1&apos; UNION  
SELECT &apos;t2&apos; UNION  
SELECT &apos;t3&apos; UNION  
SELECT &apos;t4&apos;  

SELECT * FROM test_timestamp tt  

UPDATE test_timestamp  
SET tname = &apos;t1_update&apos;  
WHERE id=1  
--1. 仅仅获取已更新的行  
--   但之前的最大的那个 rowversion 要另外记录  
SELECT * FROM test_timestamp tt WHERE tt.rowversion&gt;0x00000000000007DC  

--2. 在两人同时修改同一条数据时，避免 先取出/后保存 覆盖前面的记录  
DECLARE @rowversion TIMESTAMP  
SELECT @rowversion = rowversion FROM test_timestamp tt WHERE tt.id=1;  
--过了 5 秒后再修改, 在这 5　秒之内如果有其它update语句修改过此行则此修改无效了.  
waitfor delay &apos;00:00:05&apos;  
update test_timestamp set tname=&apos;t1_u01&apos; where id=1 AND rowversion=@rowversion  

SELECT * FROM test_timestamp tt WHERE tt.id=1  
</code></pre><p>转自：<a href="http://blog.csdn.net/yenange/article/details/14450691" target="_blank" rel="external">http://blog.csdn.net/yenange/article/details/14450691</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Font Awesome字体图标]]></title>
      <url>https://shijingjing07.github.io/2016/07/19/Font%20Awesome%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87/</url>
      <content type="html"><![CDATA[<p><strong>1.什么是字体图标</strong><br>字体图标是一个包含许多图标的字体库。<br>可以理解为一种特殊的字体，只不过里面包含的都是图标。</p>
<p><strong>2.Font Awesome图标字体库</strong><br>Font Awesome是目前最受欢迎最全面的图标字体库。<br>主要特点如下：<br>1)是一种字体，包含605个图标(截止4.5.0版本)<br>2)纯CSS控制，能够轻松定义图标的颜色、大小、阴影及任何CSS能够实现的效果。<br>3)无限缩放，矢量图标在任何尺寸下都一模一样<br>4)免费使用，包括商业和非商业项目<br>5)兼容多浏览器版本</p>
<p>下图是Font Awesome图标字体库种的部分图标，完整图标可访问官网查看：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160719143444841-1251219123.png" alt=""></p>
<p><strong>3.Font Awesome使用示例</strong><br>1)首先将整个字体库文件夹font-awesome放到工程项目中<br>2)在html页面的头部把font-awesome.min.css引进来</p>
<pre><code>&lt;link ref=&quot;stylesheet&quot; href=&quot;font-awesome/css/font-awesome.min.css&quot;&gt;
</code></pre><p>3)可在页面的任何地方使用&lt;i&gt;标签来使用Font Awesome字体图标。<br>方法为fa前缀+图标名字<br>如使用微信图标：</p>
<pre><code>&lt;i class=&quot;fa fa-weixin&quot;&gt;&lt;/i&gt;
</code></pre><p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160719143502341-754968919.png" alt=""></p>
<p><strong>4.font-awesome/css/font-awesome.css文件</strong><br>文件的开头是这么一段语句：</p>
<pre><code>@font-face {
font-family: &apos;FontAwesome&apos;;
src: url(&apos;../fonts/fontawesome-webfont.eot?v=4.6.3&apos;);
src: url(&apos;../fonts/fontawesome-webfont.eot?#iefix&amp;v=4.6.3&apos;) format(&apos;embedded-opentype&apos;), url(&apos;../fonts/fontawesome-webfont.woff2?v=4.6.3&apos;) format(&apos;woff2&apos;), url(&apos;../fonts/fontawesome-webfont.woff?v=4.6.3&apos;) format(&apos;woff&apos;), url(&apos;../fonts/fontawesome-webfont.ttf?v=4.6.3&apos;) format(&apos;truetype&apos;), url(&apos;../fonts/fontawesome-webfont.svg?v=4.6.3#fontawesomeregular&apos;) format(&apos;svg&apos;);
font-weight: normal;
font-style: normal;
}
</code></pre><p>@font-face是CSS3中的一个模块，作用是把自定义的字体嵌入到你的网页。<br>该功能兼容多浏览器版本。</p>
<p>@font-face的语法如下：</p>
<pre><code>@font-face {
      font-family: &lt;YourWebFontName&gt;;
      src: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*;
      [font-weight: &lt;weight&gt;];
      [font-style: &lt;style&gt;];
    }
</code></pre><p>font-family：自定义字体的名称，将被引入到相应元素的font-family<br>src: source:自定义字体的存放路径;format：自定义字体的格式，是为了兼容不同浏览器的识别。<br>font-weight：字体是否为粗体<br>font-style：字体是否为斜体</p>
<p><strong>5.Font Awesome使用详解</strong><br>1)放大图标尺寸<br>使用fa-lg, fa-2x, fa-3x, fa-4x, fa-5x 样式可以让图标相对于内容，尺寸增大33%，变成2倍，3倍，4倍，5倍。</p>
<pre><code>&lt;i class=&quot;fa fa-weixin fa-lg&quot;&gt;&lt;/i&gt;微信&amp;nbsp;&amp;nbsp;
&lt;i class=&quot;fa fa-weixin fa-2x&quot;&gt;&lt;/i&gt;微信&amp;nbsp;&amp;nbsp;
&lt;i class=&quot;fa fa-weixin fa-3x&quot;&gt;&lt;/i&gt;微信&amp;nbsp;&amp;nbsp;
&lt;i class=&quot;fa fa-weixin fa-4x&quot;&gt;&lt;/i&gt;微信&amp;nbsp;&amp;nbsp;
&lt;i class=&quot;fa fa-weixin fa-5x&quot;&gt;&lt;/i&gt;微信&amp;nbsp;&amp;nbsp;
</code></pre><p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160719143547732-1635169775.png" alt=""></p>
<p>2)固定宽度图标<br>使用 fa-fw 可以固定图标宽度</p>
<pre><code>&lt;i class=&quot;fa fa-weixin fa-fw&quot;&gt;&lt;/i&gt;
</code></pre><p>3)列表图标<br>使用fa-ul和fa-li可以方便地替换list列表默认图标<br>如下所示：</p>
<pre><code>&lt;ul class=&quot;fa-ul&quot;&gt;
&lt;li&gt;&lt;i class=&quot;fa-li fa fa-weixin&quot;&gt;&lt;/i&gt;微信&lt;/li&gt;
&lt;li&gt;&lt;i class=&quot;fa-li fa fa-weixin&quot;&gt;&lt;/i&gt;微信&lt;/li&gt;
&lt;li&gt;&lt;i class=&quot;fa-li fa fa-weixin&quot;&gt;&lt;/i&gt;微信&lt;/li&gt;
&lt;li&gt;&lt;i class=&quot;fa-li fa fa-weixin&quot;&gt;&lt;/i&gt;微信&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160719143610263-117370486.png" alt=""></p>
<p>4)有边框且漂浮的图标<br>使用fa-border与fa-pull-right或fa-pull-left组合使用，<br>可以方便地实现引用或文章图标。<br>如下所示：</p>
<pre><code>&lt;i class=&quot;fa fa-weixin fa-3x pull-left fa-border&quot;&gt;&lt;/i&gt;
微信是一款很火的社交软件，腾讯公司的产品，基于内容分享。
</code></pre><p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160719143627513-429802996.png" alt=""></p>
<p>5)图标旋转动画<br>使用fa-spin可以让图标匀速旋转，使用fa-pulse可以让图标只按8个角度旋转。<br>如下所示：</p>
<pre><code>&lt;i class=&quot;fa fa-weixin fa-spin&quot;&gt;&lt;/i&gt;&amp;nbsp;
&lt;i class=&quot;fa fa-weixin fa-pulse&quot;&gt;&lt;/i&gt;
</code></pre><p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160719143644935-1284561854.png" alt=""></p>
<p>6)旋转，翻转图标<br>使用fa-rotate-<em>和fa-flip-</em>可以分别实现图标的旋转和翻转<br>如下所示：</p>
<pre><code>&lt;i class=&quot;fa fa-weixin fa-rotate-90&quot;&gt;&lt;/i&gt;&amp;nbsp;
&lt;i class=&quot;fa fa-weixin fa-rotate-180&quot;&gt;&lt;/i&gt;&amp;nbsp;
&lt;i class=&quot;fa fa-weixin fa-rotate-270&quot;&gt;&lt;/i&gt;&amp;nbsp;
&lt;i class=&quot;fa fa-weixin fa-flip-horizontal&quot;&gt;&lt;/i&gt;
&lt;i class=&quot;fa fa-weixin fa-flip-vertical&quot;&gt;&lt;/i&gt;
</code></pre><p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160719143700622-1496640132.png" alt=""></p>
<p>7)叠加图标<br>要叠加多个图标，使用fa-stack设置容器。fa-stack-1x表示正常大小，<br>fa-stack-2x表示更大的图标，fa-inverse表示让图标反色。<br>如下所示：</p>
<pre><code>&lt;span class=&quot;fa-stack fa-1g&quot;&gt;
&lt;i class=&quot;fa fa-square-o fa-stack-2x&quot;&gt;&lt;/i&gt;
&lt;i class=&quot;fa fa-weixin fa-stack-1x&quot;&gt;&lt;/i&gt;
&lt;/span&gt;
</code></pre><p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160719143716529-181575294.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux进程间通信-信号]]></title>
      <url>https://shijingjing07.github.io/2016/07/15/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E4%BF%A1%E5%8F%B7/</url>
      <content type="html"><![CDATA[<p>1.什么是信号<br>信号是Linux系统响应某些条件而产生的一个事件，接收到该信号的进程会执行相应的操作。</p>
<p>2.信号的产生<br>1)由硬件产生，如从键盘输入Ctrl+C可以终止当前进程<br>2)由其他进程发送，如可在shell进程下，使用命令 kill -信号标号 PID，向指定进程发送信号。<br>3)异常，进程异常时会发送信号</p>
<p>3.信号的处理<br>信号是由操作系统来处理的，说明信号的处理在内核态。<br>信号不一定会立即被处理，此时会储存在信号的信号表中。<br>处理过程示意图：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160715103955623-338884053.png" alt=""></p>
<p>由上图中可看出信号有三种处理方式：<br>1)忽略<br>2)默认处理方式：操作系统设定的默认处理方式<br>3)自定义信号处理方式：可自定义信号处理函数</p>
<p>4.自定义信号处理方式<br>1)signal函数<br>原型：<br>void (<em>signal(int sig, void (</em>func)(int)))(int);<br>sig:信号值<br>func:信号处理函数指针，参数为信号值<br>代码示例如下：</p>
<pre><code>#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
void ouch(int sig)
{
    printf(&quot;\nOUCH! - I got signal %d\n&quot;, sig);
    //恢复终端中断信号SIGINT的默认行为
    (void) signal(SIGINT, SIG_DFL);
}
int main()
{
    //改变终端中断信号SIGINT的默认行为，使之执行ouch函数
    //而不是终止程序的执行
    (void) signal(SIGINT, ouch);
    while(1)
    {
        printf(&quot;Hello World!\n&quot;);
        sleep(1);
    }
    return 0;
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160715104046451-1452925081.png" alt=""></p>
<p>2)sigaction函数<br>原型：<br>int sigaction(int sig,const struct sigaction <em>act,struct sigaction </em>oact);<br>sig:信号值<br>act:指定信号的动作<br>oact:保存原信号的动作</p>
<p>sigaction结构体的定义如下：<br>void (*)(int) sa_handler;处理函数指针，相当于signal函数的func参数。<br>sigset_t sa_mask;处理过程中，屏蔽对sa_mask信号集的处理，sa_mask可以消除信号间的竞态。<br>int sa_flags;信号处理修改器：处理函数执行完后，信号处理方式修改。如SA_RESETHAND，将信号处理方式重置为SIG_DFL<br>代码示例如下：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
void ouch(int sig)
{
    printf(&quot;\nOUCH! - I got signal %d\n&quot;, sig);
}
int main()
{
    struct sigaction act;
    act.sa_handler = ouch;
    //创建空的信号屏蔽字，即不屏蔽任何信息
    sigemptyset(&amp;act.sa_mask);
    //使sigaction函数重置为默认行为
    act.sa_flags = SA_RESETHAND;
    sigaction(SIGINT, &amp;act, 0);
    while(1)
    {
        printf(&quot;Hello World!\n&quot;);
        sleep(1);
    }
    return 0;
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160715104126107-306829576.png" alt=""></p>
<p>4.信号的发送<br>1)kill函数<br>int kill(pid_t pid,int signo);<br>pid:进程ID<br>signo:信号值</p>
<p>2)raise函数:只能向当前进程发信号<br>int raise(int signo);<br>signo:信号值</p>
<p>3)abort函数:发送SIGABRT信号，可以让进程异常终止<br>void abort(void);</p>
<p>4)alarm函数：发送SIGALRM闹钟信号<br>unsigned int alarm(unsigned int seconds);</p>
<p>5.信号的阻塞<br>阻塞是阻止进程收到该信号，此时信号处于未决状态，放入进程的未决信号表中，<br>当解除对该信号的阻塞时，未决信号会被进程接收。</p>
<p>1)阻塞信号<br>原型：<br>int sigprocmask(int how,const sigset_t <em>set,sigset_t </em>oset);<br>how:设置block阻塞表的方式<br>a.SIG_BLOCK:将信号集添加到block表中<br>b.SIG_UNBLOCK:将信号集从block表中删除<br>c.SIG_SETMASK：将信号集设置为block表<br>set:要设置的集合<br>oset:设置前保存之前block表信息</p>
<p>2)获取未决信号<br>前面已经讲过，阻塞的信号处于未决的状态，会放入进程的未决信号表。<br>原型：<br>int sigpending(sigset_t *set);<br>set:out型参数，会将获得的当前进程的pending未决表中的信号集传入。</p>
<p>代码示例如下：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/signal.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
void func(int num)
{
  printf(&quot;catch signal number is %d&quot;,num);
}
void printfpendingsignal(sigset_t *set)
{
  int i;
  for(i=1;i&lt;32;++i)
  {
    if(sigismember(set,i))
    {
      printf(&quot;1&quot;);
    }
    else
    {
      printf(&quot;0&quot;);
    }
  }
  printf(&quot;\n&quot;);
}
int main()
{ 
  sigset_t s,p,o;
  signal(SIGINT,func);
  sigemptyset(&amp;s);
  sigemptyset(&amp;p);
  sigemptyset(&amp;o);
  sigaddset(&amp;s,SIGINT);
  sigprocmask(SIG_SETMASK,&amp;s,&amp;o);
  int count=0;
  while(1)
  {
    sigpending(&amp;p);
    printfpendingsignal(&amp;p);
    sleep(1);
    if(count++==10)
    {
      printf(&quot;recover!\n&quot;);
      sigprocmask(SIG_SETMASK,&amp;o,NULL);
    }
  }
  return 0;
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160715104211076-1829126528.png" alt=""></p>
<p>6.信号处理函数的安全问题<br>如果信号处理过程中被中断，再次调用，然后返回到第一次调用时，要保证操作的正确性。<br>这就要求信号处理函数必须是可重入的。<br>可重入函数表如下：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160715104227389-1017398124.png" alt=""></p>
<p>7.一些常见的信号</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160715104254889-1228036479.png" alt=""></p>
<p>如果进程接收到上面的这些信号，又没有安排捕获它，进程就会终止。</p>
<p>其他的一些信号如下：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160715104314889-1220362811.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux体系结构(二)： Linux系统层次]]></title>
      <url>https://shijingjing07.github.io/2016/07/13/Linux%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(%E4%BA%8C)%EF%BC%9A%20Linux%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1/</url>
      <content type="html"><![CDATA[<p>前一节内容大概介绍了一下Linux的历史由来，各大Linux发行厂商都是基于GNU项目下的所有开源软件，来构建各自己的Linux发行版本，一个完整的Linux发行版本大概可以分为以下四个层次结构:</p>
<p>Base System =&gt; X Protocol =&gt; Windows Manager =&gt; Application</p>
<p><strong>1. Base System</strong><br>所谓Base System，也就是一个最小的基本系统，需要包含一些系统必备的开源组件，比如：kernel, filesystem, glibc,<br>bash等。</p>
<p>这个最小系统最终能达到的层次就是能够启动我们的命令行字符控制终端，也就是一个bash环境，这样一个最小系统可以精简、控制在几十M的大小以内。</p>
<p><strong>2. X Protocol</strong><br>当我们构建完了最小的基本系统以后，这样一个系统只支持命令行字符终端模式，而无法支持图形化界面，如果想要使我们的Linux系统能够支持图形化界面，必须要有X<br>Protocol的支持，基于这样的一个X协议，就可以在最小系统的层次上，构建Linux的窗口管理器。</p>
<p>X<br>Protocol仅仅只是一个协议，对于这样一个协议，具体是由什么来实现的呢？在Linux早期的时候，是通过XFree86来实现X协议，经过多年的发展，XFree86已经更替为今天的X.Org项目。</p>
<p>不管是XFree86, 还是现在的X.Org，在实现X协议的时候，都是基于C/S架构，也就是X Server 和 X Client 的交互模式。关于X<br>Server 和 X Client<br>之间的关系，在接下来的一节中将详细介绍。在这里大家只需明确：如果我们需要支持图形化界面，就需要有X相关的组件来作为一个沟通的桥梁。</p>
<p>当然，X 并不是唯一的桥梁，有像Wayland这样的新生替代品也已经面世，只是目前尚不成熟，也许在未来的某一天，Wayland将会全面代替现在的 X。</p>
<p><strong>3. Windows Manager</strong><br>有了X层的支持以后，广大开源软件开发者或开发组织，就可以基于这样的一个接口，来开发上层的图形化窗口管理器，即Windows Manager,<br>比如我们熟知的KDE，Gnome， Xfce， Openbox等，这些图形化的桌面环境也就是对上面提到的X Client的一个具体实现，来和 X<br>Server进行交互通信。</p>
<p>在一下章节中，将具体讲解X Server, X Client， Xlib， QT， GTK， KDE， Gnome之间的关系。</p>
<p><strong>4. Application</strong><br>Application也就是指我们的上层图形化应用程序，比如 Liberoffice办公套件，Firefox，Thunderbird，Pidgin等。</p>
<p>Linux系统中的大多数图形化应用程序都是基于QT或GTK+这两个开发套件来开发的，当然也有像Java， Python等编写的应用程序。</p>
<p>综上，Linux发行厂商组合上面所描述的四个层次的GNU项目组件，最终提供给用户一个完整的Linux操作系统，下面还是以一张结构图来展示这一节所阐述的Linux层次：</p>
<p><a href="http://blog.chinaunix.net/attachment/201203/31/26838492_1333183782GtzC.png" target="_blank" rel="external"><img src="http://blog.chinaunix.net/attachment/201203/31/26838492_1333183782GtzC.png" alt=""></a></p>
<p>转自：<a href="http://blog.chinaunix.net/uid-26838492-id-3156661.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-26838492-id-3156661.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux体系结构(五)： 文件系统]]></title>
      <url>https://shijingjing07.github.io/2016/07/13/Linux%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(%E4%BA%94)%EF%BC%9A%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>上一节主要对Linux系统中的内核空间与用户空间做了简单的分析，在这一节里，将从内核空间和用户空间对Linux文件系统进行一定的剖析。</p>
<p>谈及文件系统，很多Linux用户都会有一个比较模糊和神秘的概念，如果对文件系统的来龙去脉有一定的了解，相信大家就能走出迷雾，Linux文件系统的整体结构模型大概可以划分为以下层次：<br>Hard Disk =&gt; Disk Driver =&gt; Filesystem(ext3,ext4,btrfs …) =&gt; User<br>Operation</p>
<p>上面结构模型很简单，有一块物理硬盘，首先这块硬盘需要有硬盘驱动的支持，然后才能在这块硬盘上创建不同的文件系统，然后用户才能使用这块硬盘。但有下面两个问题需要思考：</p>
<p>(1). 不同的物理硬盘，需要不同的驱动支持，而不同的驱动，所提供的IO操作接口是不一样的，那么，有没有一个统一的IO操作接口呢？</p>
<p>(2). 不同的文件系统，如ext3, ext4,<br>btrfs等所提供的API也是不一样的，那么，有没有一个统一的东西来对这些不同的文件系统进行一个抽象，以提供一个统一的API接口呢？</p>
<p>于是，上面的结构层次还可以细分为：</p>
<p><a href="http://blog.chinaunix.net/attachment/201204/7/26838492_1333808001bBLv.png" target="_blank" rel="external"><img src="http://blog.chinaunix.net/attachment/201204/7/26838492_1333808001bBLv.png" alt=""></a></p>
<p>上面的结构中，从硬盘驱动，文件系统，虚拟文件系统，以及系统调用，都属于内核空间，换言之，这些不同层次的实现，都是由内核来做的；而所谓用户空间的操作，也就是一些对磁盘的读写访问操作。</p>
<p><strong>1. 硬盘驱动</strong><br>常见的硬盘类型有PATA,<br>SATA和AHCI等，在Linux系统中，对不同硬盘所提供的驱动模块一般都存放在内核目录树drivers/ata中，而对于一般通用的硬盘驱动，也许会直接被编译到内核中，而不会以模块的方式出现，可以通过查看/boot<br>/config-xxx.xxx文件来确认：  </p>
<p>CONFIG_SATA_AHCI=y  </p>
<hr>
<p><strong>2. General Block Device Layer</strong><br>这一层的作用，正是解答了上面提出的第一个问题，不同的硬盘驱动，会提供不同的IO接口，内核认为这种杂乱的接口，不利于管理，需要把这些接口抽象一下，形成一个统一的对外接口，这样，不管你是什么硬盘，什么驱动，对外而言，它们所提供的IO接口没什么区别，都一视同仁的被看作块设备来处理。</p>
<p>所以，如果在一层做的任何修改，将会直接影响到所有文件系统，不管是ext3,ext4还是其它文件系统，只要在这一层次做了某种修改，对它们都会产生影响。</p>
<p><strong>3. 文件系统</strong><br>文件系统这一层相信大家都再熟悉不过了，目前大多Linux发行版本默认使用的文件系统一般是ext4，另外，新一代的btrfs也呼之欲出，不管什么样的文件系统，都是由一系列的mkfs.xxx命令来创建，如：  </p>
<p>mkfs.ext4 /dev/sda</p>
<p>mkfs.btrfs /dev/sdb  </p>
<hr>
<p>内核所支持的文件系统类型，可以通过内核目录树 fs 目录中的内容来查看。  </p>
<p><strong>4. 虚拟文件系统(VFS)</strong><br>Virtual File<br>System这一层，正是用来解决上面提出的第二个问题，试想，当我们通过mkfs.xxx系列命令创建了很多不同的文件系统，但这些文件系统都有各自的API接口，而用户想要的是，不管你是什么API，他们只关心mount/umount，或open/close等操作。  </p>
<p>所以，VFS就把这些不同的文件系统做一个抽象，提供统一的API访问接口，这样，用户空间就不用关心不同文件系统中不一样的API了。VFS所提供的这些统一的API，再经过System<br>Call包装一下，用户空间就可以经过SCI的系统调用来操作不同的文件系统。  </p>
<p>VFS所提供的常用API有：<br>mount(), umount() …<br>open(),close() …<br>mkdir() …</p>
<p>转自：<a href="http://blog.chinaunix.net/uid-26838492-id-3156661.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-26838492-id-3156661.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 用户态和内核态]]></title>
      <url>https://shijingjing07.github.io/2016/07/13/Linux%20%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/</url>
      <content type="html"><![CDATA[<p><strong>1.特权级</strong><br>特权级用来管理和控制程序执行。<br>如Intel x86架构的CPU，有0~3四个特权级，0级最高，3级最低。<br>硬件在执行每条指令时都会检查指令具有的特权级。<br>硬件提供了特权级使用机制，对操作系统来说，负责确定指令的特权级。<br>如Linux中，只使用了0和3级特权级，工作在0级特权级的指令具有CPU提供的最高权力，<br>而三级特权级指令只具有CPU提供的最基本权力。</p>
<p><strong>2.用户态和内核态的区别</strong><br>当程序运行在3级特权级时，称为运行在用户态，普通的用户进程一般运行在用户态。<br>当程序运行在0级特权级时，称为运行在内核态。</p>
<p>用户态和内核态最主要的差别在于特权级的不同。运行在用户态的程序不能直接访问操作系统内核。</p>
<p>我们通过以下示例来分析用户态和内核态：</p>
<pre><code>void testfork(){
    if(0==fork()){
        printf(&quot;create new process success&quot;);
    }
}
</code></pre><p>当程序调用fork()时，最终会调用sys_fork()函数来创建一个子进程。<br>testfork()函数中不能直接调用sys_fork(),因为前者是用户态程序，而sys_fork()工作在内核态。此时，进程会在操作系统的帮助下，由用户态切换到内核态。</p>
<p><strong>3.用户态和内核态切换的三种方式</strong><br>1)系统调用<br>用户态进程主动要求切换到内核态。<br>用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。<br>如上例的sys_fork()<br>2)异常<br>当CPU在执行运行在用户态下的程序时，发生某些异常后，会触发当前运行进程切换到异常的内核相关程序中，也就转到了内核态，如缺页异常。<br>3)外围设备的中断<br>当外围设备完成用户请求的操作后，会向CPU发送相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前知心的指令时用户态下的程序，那么这个转换也就是由用户态到内核态的切换。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作。</p>
<p><strong>4.用户态和内核态切换的原理</strong><br>用户态和内核态的切换，是系统调用了中断机制，执行了一个中断响应的过程。<br>步骤主要包括：<br>1)从当前进程的描述符中提取其内核栈的ss0及esp0信息。<br>2)使用sso和esp0执行的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个过程完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行程序的下一条指令。<br>3)将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，执行中断处理程序，这时就转到了内核态的程序执行了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[指针函数和函数指针的区别]]></title>
      <url>https://shijingjing07.github.io/2016/07/07/%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p><strong>1.指针函数</strong><br>指针函数是一个函数，函数的返回值是一个指针。<br>格式如下：</p>
<pre><code>类型标识符 *函数名(参数表)
如 double *myfunc(double x,double y);
</code></pre><p>myfunc即为一个指针函数。</p>
<p>代码示例如下：<br>pfunc.c</p>
<pre><code>#include&lt;stdio.h&gt;
double *myfunc(double x,double y);
int main()
{
    double *p = myfunc(2.5,4.3);
    printf(&quot;%f\n&quot;,*p);
    return 0;
}
double *myfunc(double x,double y)
{
    double result = x+y;
    return &amp;result;
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160708001412327-1346732365.png" alt=""></p>
<p><strong>2.函数指针</strong><br>函数指针是一个指针，它指向函数地址<br>格式如下：</p>
<pre><code>类型标识符 (*指针名)(参数表)
如 double (*myfuncp)(double x,double y);
</code></pre><p>myfuncp是一个指针，*myfuncp为指针指向的函数的地址。</p>
<p>我们有以下函数<br>double myfunc(double x,double y);<br>则可将函数的地址赋给指针<br>myfuncp = &amp;myfunc或myfuncp=myfunc(取地址运算符不是必需的)</p>
<p>代码示例如下：<br>funcp.c</p>
<pre><code>#include&lt;stdio.h&gt;
double (*myfuncp)(double x,double y);
double myfunc(double x,double y);
int main()
{
    myfuncp = &amp;myfunc;
    double result = (*myfunc)(2.5,4.3);
    printf(&quot;%f\n&quot;,result);
    return 0;
}
double myfunc(double x,double y)
{
    return x+y;
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160708001457811-2041478665.png" alt=""></p>
<p><strong>3.指针的指针</strong><br>表示指针指向的值，是一个指针类型。<br>如 int i=5;<br>int <em>p = &amp;i;<br>int *</em>pp = &amp;p;<br>其中pp即为一个指向指针的指针。<br>可以用以下示意图来标识。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160708001516452-748101375.png" alt=""></p>
<p>再看下面的图</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160708001549155-1269840008.png" alt=""></p>
<p>若<em>pp=p2;会发生什么？</em>pp即p=p2,那么p将指向p2所指的地方，即p指向j。<br>如下图所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160708001616311-903524457.png" alt=""></p>
<p><strong>4.指针的指针的作用</strong><br>1)调用函数修改局部指针变量<br>2)处理指针数组</p>
<p>代码示例如下：<br>从一个int类型数组中，找出第一个负数。<br>pptest2.c</p>
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    int vals[]={7,6,5,-4,3,2,1,0};
    int *p=vals;
    getnegative(&amp;p);
    printf(&quot;%d\n&quot;,*p);
    return 0;
}
void getnegative(int **pp)
{
    while(**pp!=0)
    {
        if(**pp&lt;0)
            break;
        else
            (*pp)++;
    }
}
</code></pre><p>输出结果:</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160708001715546-1319494951.png" alt=""></p>
<p>我们可以用指针数组来代替多维数组，<br>代码示例如下：<br>arrayp.c</p>
<pre><code>#include&lt;stdio.h&gt;
int main()
{
        char* names[]={&quot;Bill&quot;,&quot;Sam&quot;,&quot;Jim&quot;,&quot;Paul&quot;,&quot;Jack&quot;,&quot;0&quot;};
        char **namesp = names;
        while(*namesp!=&quot;0&quot;)
        {
                printf(&quot;%s &quot;,*namesp++);
        }
        return 0;
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160708001801046-2004231501.png" alt=""></p>
<p>其中*namesp++表示先取得指针指向的内容，然后使指针自增。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux启动新进程的三种方法]]></title>
      <url>https://shijingjing07.github.io/2016/07/06/Linux%E5%90%AF%E5%8A%A8%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>程序中，我们有时需要启动一个新的进程，来完成其他的工作。<br>下面介绍了三种实现方法，以及这三种方法之间的区别。</p>
<p><strong>1.system函数-调用shell进程，开启新进程</strong><br>system函数，是通过启动shell进程，然后执行shell命令进程。<br>原型：</p>
<pre><code>int system(const char *string);
</code></pre><p>string:shell命令字符串<br>返回值：成功返回命令退出码，无法启动shell，返回127错误码，其他错误，返回-1。</p>
<p>代码示例如下：<br>process_system.c</p>
<pre><code>#include&lt;stdlib.h&gt;                                                              
#include&lt;stdio.h&gt;
int main()
{
        printf(&quot;Running ps with system\n&quot;);
        int code = system(&quot;ps au&quot;);//新进程结束后，system函数才返回
        //int code = system(&quot;ps au&quot;);//system函数立即返回
        printf(&quot;%d\n&quot;,code);
        printf(&quot;ps Done\n&quot;);
        exit(0);
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160706182806983-198256886.png" alt=""></p>
<p>system函数，在启动新进程时，必须先启动shell进程，因此使用system函数的效率不高。</p>
<p><strong>2.exec系列函数-替换进程映像</strong><br>exec系列函数调用时，启动新进程，替换掉当前进程。即程序不会再返回到原进程，<br>除非exec调用失败。<br>exec启动的新进程继承了原进程的许多特性，如在原进程中打开的文件描述符在新进程中仍保持打开。<br>需要注意的是，在原进程中打开的文件流在新进程中将关闭。原因在于，我们在前面讲过<a href="http://www.cnblogs.com/shijingjing07/p/5620646.html" target="_blank" rel="external">进程间通信</a>的方式，进程之间需要管道才能通信。</p>
<p>原型：</p>
<pre><code>int execl(const char *path,const char *arg0,...,(char*)0);
int execlp(const char *file,const char *arg0,...,(char*)0);
int execle(const char *path,const char *arg0,...,(char*)0,char *const envp[]);

int execv(cosnt char *path,char *const argv[]);
int execvp(cosnt char *file,char *const argv[]);
int execve(cosnt char *path,char *const argv[],char *const envp[]);
</code></pre><p>path/file：进程命令路径/进程命令名<br>argc:命令参数列表<br>envp:新进程的环境变量<br>代码示例如下：<br>process_exec.c</p>
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    printf(&quot;Running ps with execlp\n&quot;);
    execlp(&quot;ps&quot;,&quot;ps&quot;,&quot;au&quot;,(char*)0);
    printf(&quot;ps done&quot;);
    exit(0);
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160706182941139-216208758.png" alt=""></p>
<p>可以看出，调用execlp函数后，原进程被新进程替换，原进程中printf(“ps done”);没有被执行到。</p>
<p><strong>3.fork函数-复制进程映像</strong><br>1)fork函数的使用<br>fork和exec的替换不同，调用fork函数，可复制一个和父进程一模一样的子进程。<br>执行的代码也完全相同，但子进程有自己的数据空间，环境和文件描述符。<br>原型：</p>
<pre><code>pid_t fork();
</code></pre><p>父进程执行时，返回子进程的PID<br>子进程执行时，返回0</p>
<p>代码示例如下：<br>process_fork.c</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;sys/types.h&gt;
int main()
{
    pid_t pid = fork();
    switch(pid)
    {
        case -1:
            perror(&quot;fork failed&quot;);
            exit(1);
            break;
        case 0:
            printf(&quot;\n&quot;);
            execlp(&quot;ps&quot;,&quot;ps&quot;,&quot;au&quot;,0);
            break;
        default:
            printf(&quot;parent,ps done\n&quot;);
            break;
    }
    exit(0);
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160706183035311-1079184377.png" alt=""></p>
<p>调用fork函数后，新建了一个子进程，拷贝父进程的代码，数据等到子进程的内存空间。父进程和子进程执行互不影响。使用fork函数的返回值，来区分执行的是父进程，还是子进程。</p>
<p>2)僵尸进程<br>子进程退出后，内核会将子进程置为僵尸状态。此时，子进程只保留了最小的一些内核数据结构，如退出码，以便父进程查询子进程的退出状态。这时，子进程就是一个僵尸进程。</p>
<p>在父进程中调用wait或waitpid函数，查询子进程的退出状态，可以避免僵尸进程。<br>原型：</p>
<pre><code>pid_t wait(int *stat_loc);
pid_t waitpid(pid_t pid,int *stat_loc,int options);
</code></pre><p>stat_loc:若不是空指针，则子进程的状态码会被写入该指针指向的位置。<br>pid:等待的子进程的进程号pid<br>options:标记阻塞或非阻塞模式<br>返回值：成功返回子进程的pid，若子进程没有结束或意外终止，返回0</p>
<p>wait：阻塞模式(使用了信号量)，父进程调用wait时，会暂停执行，等待子进程的结束。<br>wait调用返回后，子进程会彻底销毁。</p>
<p>waitpid:与wait不同的是，<br>a.可以表示四种不同的子进程类型<br>     pid==-1 等待任何一个子进程，此时waitpid的作用与wait相同<br>　　pid &gt;0 等待进程ID与pid值相同的子进程<br>　　pid==0 等待与调用者进程组ID相同的任意子进程<br>　　pid&lt;-1 等待进程组ID与pid绝对值相等的任意子进程<br>b.当options的值为WNOHANG时，为非阻塞模式，即waitpid会立即返回<br>此时，可以循环查询子进程的状态，若子进程未结束，waitpid返回，做其他工作。<br>这样提高了程序的效率。</p>
<p>wait函数使用示例如下：<br>process_fork3.c</p>
<pre><code>#include&lt;wait.h&gt;
#include&lt;stdio.h&gt;
#include&lt;sys/types.h&gt;
int main()
{
    pid_t pid = fork();
    int stat = 0;
    switch(pid)
    {
        case -1:
            perror(&quot;fork failed&quot;);
            exit(1);
            break;
        case 0:
            printf(&quot;\n&quot;);
            exit(0);
            break;
        default:
            pid = wait(&amp;stat);
            printf(&quot;Child has finished:PID=%d\n&quot;,pid);
            printf(&quot;parent,ps done\n&quot;);
            break;
    }
    exit(0);
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160706183153561-1567285869.png" alt=""></p>
<p>waitpid函数使用示例如下：<br>process_fork2.c</p>
<pre><code>#include&lt;wait.h&gt;
#include&lt;stdio.h&gt;
#include&lt;sys/types.h&gt;
int main()
{
    pid_t pid = fork();
    int stat = 0;
    switch(pid)
    {
        case -1:
            perror(&quot;fork failed&quot;);
            exit(1);
            break;
        case 0:
            printf(&quot;\n&quot;);
            execlp(&quot;ps&quot;,&quot;ps&quot;,&quot;au&quot;,0);
            break;
        default:
            do
            {
                pid = waitpid(pid,&amp;stat,WNOHANG);
                if(pid==0)
                {
                    printf(&quot;parent do something else.\n&quot;);
                    sleep(1);
                }
            }while(pid==0);
            printf(&quot;Child has finished:PID=%d\n&quot;,pid);
            printf(&quot;parent,ps done\n&quot;);
            break;
    }
    exit(0);
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160706183236639-933066854.png" alt=""></p>
<p><strong>4.启动新进程三种方法的比较</strong><br>1)system函数最简单，启动shell进程，并在shell进程中执行新的进程。<br>效率不高，system函数必须等待子进程返回才能接着执行。</p>
<p>2)exec系列函数用新进程替换掉原进程，但不会返回到原进程，除非调用失败。<br>该函数继承了许多原进程的特性，效率也较高。</p>
<p>3)fork函数，复制一个子进程，和父进程一模一样，但是拥有自己的内存空间。父子进程执行互不影响。需要注意僵尸子进程的问题。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux文件操作]]></title>
      <url>https://shijingjing07.github.io/2016/07/01/Linux%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>Linux中一切都是文件。如普通文件，目录，设备，管道等。<br>操作这些文件有两种方式，调用系统函数和使用标准I/O库。</p>
<p><strong>一、调用系统函数</strong><br>1.文件描述符：数值类型，表示打开的文件标识<br>程序运行时，会首先打开3个文件描述符，0(标准输入文件),1(标准输出文件),2(标准错误文件)</p>
<p>2.系统调用常用函数<br>1)open函数：打开文件<br>原型为：</p>
<pre><code>int open(const char *path,int oflags)
int open(const char *path,int oflags,mode_t mode)
</code></pre><p>path:完整的文件路径<br>oflags:文件访问模式(只读，只写，可读写)<br>mode:设定文件访问权限</p>
<p>返回值：返回与文件关联的文件描述符，失败返回-1<br>注意这个描述符是唯一的，不与其他进程共享，文件对应的文件描述符并不是固定的。</p>
<p>2)write函数：写入文件<br>原型为：</p>
<pre><code>size_t write(int fildes,const void *buf,size_t nbytes);
</code></pre><p>将buf缓冲区的前nbyts个字节，写入文件描述符files关联的文件中。<br>返回值：实际写入的字节数，失败返回-1</p>
<p>3)read函数：读取文件<br>原型为：</p>
<pre><code>size_t read(int fildes,void *buf,szie_t nbytes);
</code></pre><p>读取文件描述符fildes关联的文件中前nbytes个字节，到buf缓冲区<br>返回值：实际读取的字节数，失败返回-1</p>
<p>4)close函数:关闭文件<br>原型为：</p>
<pre><code>int close(int fildes);
</code></pre><p>返回值：成功返回0,失败返回-1</p>
<p><strong>3.调用系统函数示例</strong><br>从一个文件中复制数据到另一个文件，代码如下：<br>copy.c</p>
<pre><code>#include&lt;fcntl.h&gt;
#include&lt;stdlib.h&gt;
int main()
{
    char c=&apos;\0&apos;;
    int in=-1,out=-1;
    in=open(&quot;myfile.txt&quot;,O_RDONLY);
    //以只写方式创建文件，若文件不存在则新建一个文件
    //文件所有者具有读和写权限
    out=open(&quot;myfile2.txt&quot;,O_WRONLY|O_CREAT,S_IRUSR|S_IWUSR);
    while(read(in,&amp;c,1)==1)
        write(out,&amp;c,1);
    close(in);
    close(out);
    return 0;
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160702005858156-1718842993.png" alt=""></p>
<p><strong>4.标准I/O库</strong><br>在标准I/O中，使用的是文件流，对应着底层的文件描述符。<br>文件流是一个指向FILE结构的指针。</p>
<p>I/O库的函数包含在头文件stdio.h中。</p>
<p>1)fopen函数：打开文件<br>原型为：</p>
<pre><code>FILE* fopen(const char *filename,const char *mode);
</code></pre><p>与底层open函数类似<br>返回值：成功返回非空指针，失败返回NULL</p>
<p>2)fread函数：读取文件<br>原型为：</p>
<pre><code>size_t fread(void *ptr,size_t size,size_t nitems,FILE *stream);
</code></pre><p>与底层read函数类似<br>从stream读取nitems个长度为size的数据到ptr指向的缓冲区<br>返回值：成功读取的字节数，失败返回-1</p>
<p>3)fwrite函数：写入文件<br>原型为：</p>
<pre><code>size_t fwrite(const void *ptr,size_t size,size_t nitems,FILE *stream);
</code></pre><p>与底层write函数类似<br>从ptr指向的缓存区读取nitems个长度为size的数据，并把它们写到stream对应的文件中。<br>返回值：成功写入的字节数，失败返回-1</p>
<p>4)fclose函数：关闭文件<br>原型为:</p>
<pre><code>int fclose(FILE *stream);
</code></pre><p>返回值：成功返回0,失败返回-1</p>
<p><strong>5.标准I/O使用示例</strong><br>与前例一样，从一个文件中复制数据到另一个文件，只是使用I/O库函数来实现，<br>代码如下：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int main()
{
    int c=0;
    FILE *pfin = NULL;
    FILE *pfout = NULL;
    pfin = fopen(&quot;myfile.txt&quot;,&quot;r&quot;);
    pfout = fopen(&quot;myfile2.txt&quot;,&quot;w&quot;);
    while(fread(&amp;c,sizeof(char),1,pfin))
        fwrite(&amp;c,sizeof(char),1,pfout);
    fclose(pfin);
    fclose(pfout);
    return 0;
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160702010045749-2057295766.png" alt=""></p>
<p>程序中的读和写数据可以用库中的其他函数来代替，如fget,fputc等。</p>
<p><strong>6.文件描述符和文件流</strong><br>一般不要混合使用底层输入输出与高层文件流操作。<br>调用fileno函数，可以获得文件流使用的底层文件描述符<br>原型为：int fileno(FILE <em>stream);<br>调用fdopen函数，可以在一个已经打开的文件描述符上创建一个新的文件流<br>原型为：FILE</em> fdopen(int fildes,const char* mode);</p>
<p>Linux下编程时，一般使用系统调用，而不使用I/O库。<br>有些操作必须使用系统调用，如创建文件读写锁等。</p>
<p><strong>7.系统调用性能优化</strong><br>我们使用time命令测试系统调用和I/O库两种方法的运行时间，<br>结果如下所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160702010118046-665220137.png" alt=""></p>
<p>可以看出，系统调用的效率要明显低于I/O库，这是为什么呢？<br>因为系统调用时，Linux必须从运行用户代码切换到内核代码，然后再返回用户代码。<br>而I/O库函数会自动在数据满足数据块长度时，才调用底层系统函数。</p>
<p>系统调用代码优化如下，每次一次性读取和写入N个字节，减少系统调用次数。</p>
<p>copyopt.c</p>
<pre><code>#include&lt;fcntl.h&gt;
#include&lt;stdlib.h&gt;
int main()
{
    char buffer[1024];
    int in=-1,out=-1;
    int nread=0;
    in=open(&quot;myfile.txt&quot;,O_RDONLY);
    //以只写方式创建文件，若文件不存在则新建一个文件
    //文件所有者具有读和写权限
    out=open(&quot;myfile2.txt&quot;,O_WRONLY|O_CREAT,S_IRUSR|S_IWUSR);
    while(nread=read(in,buffer,sizeof(buffer))&gt;0)
        write(out,buffer,nread);
    close(in);
    close(out);
    return 0;
}
</code></pre><p>使用time测试输出如下：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160702010202156-1711515887.png" alt=""></p>
<p>可以看出，性能得到了提高，甚至超过了使用I/O的性能。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 数据流重定向]]></title>
      <url>https://shijingjing07.github.io/2016/07/01/Linux%20%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      <content type="html"><![CDATA[<p><strong>1.三种数据流重定向</strong><br>1)标准输入(stdin):代码为0，使用0&lt;或0&lt;&lt;，其中代码0可以省略<br>2)标准输出(stdout):代码为1，使用1&gt;或1&gt;&gt;，其中代码1可以省略<br>3)标准错误输出(stderr):代码为2，使用2&gt;或2&gt;&gt;</p>
<p><strong>2.标准输出(stdout)重定向</strong><br>我们知道Linux中，cat命令可以将文件内容输出到屏幕。<br>如下所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160701133103874-1115755871.png" alt=""></p>
<p>我们可以使用&gt;将输出重定向到其他文件，如下所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160701133130781-834052391.png" alt=""></p>
<p>可以看到，使用&gt;后，文件内容并没有输出到屏幕，而是输出到了mytxt文件。</p>
<p>&gt;&gt;与&gt;的区别是，&gt;&gt;会把输出添加到文件的末尾，&gt;会清空文件，然后将输出写入该文件。</p>
<p><strong>3.标准输入(stdin)重定向</strong><br>cat&gt;mytxt，表示需要从键盘输入数据到文件。如下所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160701133201390-1495529579.png" alt=""></p>
<p>使用&lt;可以将其他文件内容输入到该文件，如下所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160701133637109-1643770272.png" alt=""></p>
<p>使用&lt;&lt;，表示定义输入结束符，<br>从键盘输入时，输入Ctrl+D，可结束进程。<br>还可以使用&lt;&lt;自定义结束符，如下所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160701133651609-1775141750.png" alt=""></p>
<p><strong>4.标准错误输出(stderr)重定向</strong><br>与标准输出(stdout)重定向使用相同。<br>表示重定向的是错误信息。<br>一般用来将错误信息和正确信息分开。</p>
<p><strong>5.标准输出和标准错误输出写入同一个文件</strong><br>使用&amp;&gt;可将stdout和stderr输出到同一个文件，如下所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160701133712921-1572346818.png" alt=""></p>
<p><strong>6.屏蔽所有输出的方法</strong><br>有时我们希望将所有的错误信息或正确信息屏蔽掉，<br>此时，可将输出重定向到设备/dev/null。如下所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201607/300946-20160701133726171-631294718.png" alt=""></p>
<p>将正确信息吃掉，此时屏幕输出的只有错误信息了。</p>
<p><strong>7.为什么要用数据流重定向</strong><br>1)需要将屏幕信息保存下来的时候<br>2)不希望其他程序干扰到当前程序的屏幕输出<br>3)执行时一些已知的错误，我们可以用”2&gt;/dev/null”丢掉<br>4)正确信息和错误信息需要分开输出</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux硬链接和软链接]]></title>
      <url>https://shijingjing07.github.io/2016/06/30/Linux%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5/</url>
      <content type="html"><![CDATA[<p><strong>1.硬链接：文件别名</strong><br>通过前面讲的<a href="http://www.cnblogs.com/shijingjing07/p/5630747.html" target="_blank" rel="external">Linux<br>ext2文件系统</a>，我们知道在目录文件的block中，存放着目录下文件的文件名和对应的inode。<br>可以将多个文件名对应到同一个inode，<br>新建一条文件名链接到某inode号，这就是硬链接。</p>
<p>可以看出，硬链接只是新建了一个文件名，关联到一个已存在的文件。<br>此时，目录下的block多写了一个文件名/inode的数据<br>所以，硬链接没有增加inode和block的耗用。</p>
<p><strong>2.软链接：类似windows中的快捷方式</strong><br>软链接的实质是，创建了一个独立的文件，而读取这个文件时，会指向它链接的那个文件的文件名。类似于重定向的功能。</p>
<p>软链接新建了文件，所以是要耗用inode和block的。</p>
<p><strong>3.硬链接和软链接的比较</strong></p>
<p>1)硬链接比较安全，多个文件名对应一个inode时，若删除文件，只要还有其他的文件名对应着这个inode文件，文件就不会删除，<br>此时，只是将文件的连接数减1,当连接数为0时，文件真正删除。</p>
<p>硬链接不会耗用inode和block</p>
<p>硬链接不能链接到目录。</p>
<p>2)软链接<br>软链接比较灵活，可以链接到文件和目录。<br>但是会耗用inode和block，不过这点空间不算什么。<br>若目标文件删除，则读取链接文件会失败。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux ext2文件系统]]></title>
      <url>https://shijingjing07.github.io/2016/06/30/Linux%20ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>Linux最传统的磁盘文件系统(filesystem)使用的是ext2</p>
<p><strong>1.ext2文件系统结构</strong><br>ext2文件系统划分为多个块组，每个块组拥有独立的inode/block，一个文件系统只有一个Superblock。<br>如下图所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160630173517390-2010416358.png" alt=""></p>
<p>1)Boot Sector:启动扇区。<br>启动扇区可以安装引导装载程序，这样可以将不同的引导装载程序安装到不同的文件系统，<br>不用覆盖整块硬盘唯一的MBR，才能制作出多重引导的环境。</p>
<p>2)Data Block:存放文件内容。<br>ext2系统中block的大小有1KB,2KB,4KB三种，block大小由文件系统总容量决定，如下图所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160630173538968-986757518.png" alt=""></p>
<p>每个block只能放一个文件的数据，若文件大小超过block，则占用多个；<br>若小于block，block剩余的空间也不能被其他文件使用。</p>
<p>3)Inode Table:存放文件属性和权限等。<br>inode存放的文件数据至少有：<br>文件的访问权限(rwx)<br>文件的所有者与组(ower/group)<br>文件的大小<br>文件创建和状态改变时间<br>最近一次读的时间<br>最近修改的时间<br>文件类型标识<br>文件指向的block号</p>
<p>inode的大小固定为128B<br>我们重点看一下最后一项，”文件指向的block号”<br>inode是通过12个直接指针，1个间接指针，1个双间接指针，1个三间接指针来指向block的。<br>如下所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160630173604874-1386854855.png" alt=""></p>
<p>12个直接指针:直接取得block号码<br>如果文件太大,就会使用间接指针，双间接指针，三间接指针来记录编号</p>
<p>4)Superblock:存放文件系统的基本信息。<br>一个文件系统只有一个Superblock，存放的信息有：<br>inode,block的总量<br>未使用和已使用的inode,block数量<br>inode,block的大小<br>文件系统挂载时间，最近写入数据时间，最近检查磁盘时间<br>validbit值，文件系统已挂载，则validbit为0，否则为1</p>
<p>5)File system Description(文件系统描述):每个块组的开始结束号码</p>
<p>6)block bitmap(block对照表)：标识block是否使用<br>便于系统快速找到空间来处置文件</p>
<p>7)inode bitmap(inode对照表):标识inode是否使用<br>与block bitmap相似。</p>
<p><strong>2.文件系统树型结构之间的关系</strong><br>1)目录<br>新建一个目录时，ext2会分配一个inode和至少一块block给该目录。<br>inode记录目录权限和属性，以及分配的block号。<br>block记录目录下的文件名和文件名占用的inode号。</p>
<p>2)文件<br>新建一个文件时，ext2会分配一个inode和对应文件大小的N个block块给该文件。<br>inode和文件名会同时被记录在目录的block中，以便通过目录访问到该文件。<br>block存放文件内容。</p>
<p>3)文件查找<br>查找文件时，会先找到文件所在目录，目录的inode对应的block中，<br>存放着文件的名称和inode，找到文件名对应的inode,<br>然后找到文件inode对应的block，找到文件内容。</p>
<p><strong>3.ext3文件系统</strong><br>ext3是ext2的升级，加入了日志文件系统。</p>
<p><strong>4.挂载文件系统</strong><br>文件系统要挂载到目录树，才能使用。<br>文件系统与目录树结合的操作，称为挂载。<br>挂载点是目录，该目录为进入该文件系统的入口。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux文件特殊权限]]></title>
      <url>https://shijingjing07.github.io/2016/06/30/Linux%E6%96%87%E4%BB%B6%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90/</url>
      <content type="html"><![CDATA[<p>除了我们前面介绍的rwx权限外，Linux中还有另外三种特殊权限：SUID,SGID,SBIT<br><strong>一、SUID,SGID,SBIT介绍</strong><br>1.SUID:s出现在文件所有者的x权限上。<br>1)SUID只能用于二进制可执行文件，对目录无效<br>2)执行者若具有该文件的x权限，则将具有文件所有者的权限<br>3)权限只在文件执行时有效，执行完毕不再拥有所有者权限</p>
<p>2.SGID：s出现在文件所属群组的x权限上。<br>SGID和SUID不同，可以用于目录<br>1)使用者若有此目录的x,w权限，则可进入和修改此目录<br>2)使用者在此目录下的群组将变成该目录的群组，新建的文件，群组是此目录的群组。</p>
<p>SGID对于文件来说<br>1)SGID只对二进制可执行文件有效<br>2)执行者若具有该文件的x权限，则将具有文件所属群组的权限<br>3)权限只在文件执行时有效，执行完毕不再拥有所属群组权限</p>
<p>3.SBIT:t出现在文件其他用户的x权限上。<br>1)和SUID,SGID不同的是，只能用于目录<br>2)使用者在该目录下，仅自己与root才有权力删除新建的目录或文件</p>
<p><strong>二、为什么要使用特殊权限</strong><br>举个例子，比如 /usr/bin/passwd 这个二进制文件。<br>它的权限是 -rwsr-xr-x ，我不是所有者，我具有”x”权限，我执行它时，获得了它的所有者（即root）的权限，<br>所以在该二进制程序执行时，我可以用它来读到我平时是没有权限访问的 /etc/shadow 文件（-r——–），从而能更改我自己的密码</p>
<p><strong>三、修改SUID,SGID,SBIT权限</strong><br>1.符号类型修改权限<br>chmod u+s test –为test文件加上suid权限<br>chmod g+s test –为test文件加上sgid权限<br>chmod o+t test –为test文件加上sbit权限</p>
<p>2.数字类型修改权限<br>我们知道普通文件的rwx权限修改<br>对于特殊权限，需要在最前面增加一位，SUID:4,SGID:2,SBIT:1<br>chmod 4777 test –test拥有SUID权限，rwsrwxrwx<br>chmod 2777 test –test拥有SGID权限，rwxrwsrwx<br>chmod 1777 test –test拥有SBIT权限，rwxrwxrwt</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux文件普通权限]]></title>
      <url>https://shijingjing07.github.io/2016/06/29/Linux%E6%96%87%E4%BB%B6%E6%99%AE%E9%80%9A%E6%9D%83%E9%99%90/</url>
      <content type="html"><![CDATA[<p><strong>1.文件所有者，所属用户组，其他用户</strong><br>1)文件所有者:创建文件的用户<br>2)所属用户组：文件属于哪个用户组<br>3)其他用户：不是文件所有者，不属于文件所属用户组的用户，称为其他用户</p>
<p><strong>2.Linux文件权限</strong><br>我们切换到root用户，新建一个myfile的文件夹,<br>然后使用ls -al|grep myfile命令查看文件属性，如下图所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160629180109249-70843389.png" alt=""></p>
<p>文件类型 所有者权限 用户组权限 其他用户权限 连接数 所有者 用户组 文件容量(B) 修改日期       文件名<br>d           rwx          r-x           r-x                 2    root    root<br>4096         6/29 9:00    myfile</p>
<p>权限中三位分别代表r(读)，w(写)，x(执行)文件内容的权限，若为-，表示没有相应的权限。</p>
<p>对于文件夹来说，内容为文件夹中的文件名列表。<br>r:可读取文件名列表<br>w:可新建，删除，重命名文件名<br>x:有进入文件夹的权限<br>若要执行文件夹的w权限，必须要先有进入文件夹的权限，所以要使用w权限，必须要有x权限。</p>
<p>对于文件来说，内容为文件内容本身<br>r:可读取文件内容<br>w:可修改文件内容<br>x:可执行文件</p>
<p>可见，文件本身的权限只和文件内容有关系，文件的新增，删除，重命名，则需要文件所在的目录的w权限。</p>
<p><strong>3.修改文件权限</strong><br>1)chmod:修改文件权限<br>使用权限对应的数值来修改权限，<br>r:4,w:2,x:1<br>rwx的值为4+2+1=7<br>r-x的值为4+0+1=5<br>rw-的值为4+2+0=6</p>
<p>chmod rwx的值 文件名<br>即可将文件修改成相应的权限，如我们修改myfile的其他用户权限为rwx,修改命令为：chmod 757 myfile</p>
<p>2)chgrp:修改文件所属用户组<br>chgrp ubuntu myfile<br>即可将myfile的用户组从root改为ubuntu</p>
<p>3)chown:修改文件所有者<br>chown ubuntu myfile修改文件所有者<br>或chown ubuntu:ubuntu myfile 同时修改文件所有者和文件所属用户组</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux Shell编程]]></title>
      <url>https://shijingjing07.github.io/2016/06/29/Linux%20Shell%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p><strong>一、什么是Shell</strong><br>在Linux中，系统会为每个用户运行一个shell(外壳)程序。<br>shell程序是一个命令行解释器，交互式地解释和执行用户输入的命令。<br>shell还是一种解释性的程序设计语言，定义了变量和函数，数组，程序控制结构等很多高级语言支持的特性。</p>
<p><strong>二、shell编程用在什么地方</strong><br>shell一般用于批量命令执行，用来管理，监控系统等。</p>
<p><strong>三、shell语法详解</strong><br>1.程序示例，输出”hello world”<br>firstshell</p>
<pre><code>#!/bin/bash
echo &quot;hello world&quot;
</code></pre><p>改变文件的访问权限，使其具有可执行属性<br>chmod +x firstshell</p>
<p>输出结果:</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160629150427843-1821626791.png" alt=""></p>
<p>程序的第一行必须是 #!/bin/bash<br>指定系统用#!后的命令/bin/bash来运行此文件。</p>
<p>2.变量<br>varname=值<br>需要注意的是：<br>1)”=”前后不能有空格<br>2)变量默认都是字符串格式的<br>3)使用变量，必须加上”$”符号，否则取到的是变量名本身<br>4)若变量名和其他字符串混淆在一起时，需要加上{}来区分变量名<br>如下例所示：<br>myshell</p>
<pre><code>#!/bin/bash
var1=1
var2=2
var3=$var1+$var2 #变量默认是字符串，所以输出为1+2
var4 =4 #等号前后有空格，报错
echo $var1
echo $var2
echo $var3
echo $var4
echo &quot;var1 is the ${var1}st&quot;
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160629150522421-237667676.png" alt=""></p>
<p>那么，我们如何将var1,var2作为数值类型来相加呢？<br>方法一：使用C风格表示式，((表示式))<br>((var3=$var1+$var2))<br>或((var3=var1+var2))</p>
<p>方法二：使用shell中的let命令<br>let ‘var3=var1+var2’ #注意不能加’$’符号，否则报错</p>
<p>方法三：调用expr外部程序，效率较低，尽量少用<br>var3=$(expr $var1 + $var2) #expr函数需要三个参数,$var1,+,$var2</p>
<p>3.流程控制<br>1)if语句<br>结构如下：</p>
<pre><code>if
then
elif
then
else
fi
</code></pre><p>或者(then写在if的后面，但是要加分号;)</p>
<pre><code>if ...;then
elif...;then
else
fi
</code></pre><p>示例如下：<br>myshell</p>
<pre><code>#!/bin/bash
var1=1
var2=2
if ((var1==var2))
then
    echo &quot;var1=var2&quot;
elif ((var1&gt;var2))
then
    echo &quot;var1&gt;var2&quot;
else
    echo &quot;var1&lt;var2&quot;
fi
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160629150644781-2023272747.png" alt=""></p>
<p>bash中有一些常用的条件判断表达式，使用方法：[ 条件判断表达式 ]<br>-f “filename”:判断是否是文件<br>-x “/bin/ls”:判断/bin/ls是否存在并有可执行权限<br>-n “$var”:判断$var变量是否有值<br>“$a”==”$b”:判断$a和$b是否相等</p>
<p>2)&amp;&amp;和||操作符<br>&amp;&amp;：逻辑与操作符<br>||: 逻辑或操作符</p>
<p>3)case语句<br>case表达式用来匹配给定的字符串，和C中的switch…case匹配的是数字不同。</p>
<pre><code>case ... in
...) 
    do something;;
...)
    do something;;
esac
</code></pre><p>下例中，我们写了一个程序，用来解压bzip2,gzip,zip类型的压缩文件。<br>代码如下：</p>
<pre><code>#!/bin/bash
ftype=$(file $1)
echo &quot;$ftype&quot;
case &quot;$ftype&quot; in
&quot;$1: Zip archive&quot;*)
    unzip &quot;$1&quot;;;
&quot;$1: gzip compressed&quot;*)
    gunzip &quot;$1&quot;;;
&quot;$1: bzip2 compressed&quot;*)
    bunzip2 &quot;$1&quot;;;
*)
    echo &quot;File $1 can not be unconpressed&quot;;;
esac
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160629150734281-2075603643.png" alt=""></p>
<p>其中$1表示输入的第一个参数</p>
<p>4)select循环语句<br>select循环适合交互式的场合，格式如下：</p>
<pre><code>select var in ...;do
...
done
</code></pre><p>示例代码如下：</p>
<pre><code>#!/bin/bash
echo &quot;what is your favourite OS?&quot;
select var in &quot;RedHat&quot; &quot;Ubuntu&quot; &quot;Free BSD&quot; &quot;Other&quot;;do
    echo &quot;hello $var&quot;
    break;
done
echo &quot;you have selected $var&quot;
</code></pre><p>输出结果:</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160629150821046-256989018.png" alt=""></p>
<p>5)while/for循环<br>while循环</p>
<pre><code>while...;do
    ...
done
</code></pre><p>for循环</p>
<pre><code>for var in ...;do
    ...
done
</code></pre><p>示例代码如下：</p>
<pre><code>#!/bin/bash
for var in A B C;do
    echo &quot;var is $var&quot;
done
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160629150919374-53766546.png" alt=""></p>
<p>4.shell里的一些特殊符号<br>1)*:表示通配符<br>双引号可以防止通配符但允许变量扩展<br>单引号(或转义字符\)的限制更严格，可防止任何变量扩展；<br>示例代码如下：</p>
<pre><code>#!/bin/bash
echo *.c
echo &quot;*.c&quot;
echo &apos;*.c&apos;
echo \*.c

echo $SHELL
echo &quot;$SHELL&quot;
echo &apos;$SHELL&apos;
echo \$SHELL
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160629150948984-14562658.png" alt=""></p>
<p>2)命令行参数<br>$1:命令行的第一个参数<br>$#:命令行参数的个数<br>$@:命令行的所有参数<br>$*:所有命令行参数作为一个参数<br>shift n:去掉前面的n个参数</p>
<p>示例如下：</p>
<pre><code>#!/bin/bash
help()
{
cat &lt;&lt; HELP
   本例程序用来获取命令行参数
   使用了命令：myshell -l hello -f -- -somefile1 somefile2
HELP
   exit 0
}
while [ -n &quot;$1&quot; ]; do
case &quot;$1&quot; in
   -h) help;shift 1;; 
   -f) opt_f=1;shift 1;; 
   -l) opt_l=$2;shift 2;; 
   --) shift;break;; 
   -*) echo &quot;error: no such option $1. -h for help&quot;;exit 1;;
   *) break;;
esac
done
echo &quot;opt_f is $opt_f&quot;
echo &quot;opt_l is $opt_l&quot;
echo &quot;first arg is $1&quot;
echo &quot;2nd arg is $2&quot;
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160629151036718-2078581139.png" alt=""></p>
<p>3)输出段落<br>echo一次只能输出一行<br>如果是一段文字，该如何输出呢？<br>我们可以使用cat &lt;&lt;，后接一个字符串，段落的末尾再加上这个字符串来输出段落。</p>
<pre><code>cat &lt;&lt; HELP
...
...
HELP
</code></pre><p>下例中，程序用来替换文件名，<br>有三个输入参数，第一个参数是待替换字符<br>第二个参数是替换字符<br>第三个参数是文件名。</p>
<pre><code>#!/bin/bash
if [ $# -lt 3 ];then
cat &lt;&lt; HELP
本例中，程序用来替换文件名，
有三个输入参数，第一个参数是待替换字符
第二个参数是替换字符
第三个参数是文件名。
HELP
   exit 0
fi
OLD=&quot;$1&quot;
NEW=&quot;$2&quot;
# The shift command removes one argument from the list of
# command line arguments.
shift
shift
# $@ contains now all the files:
for file in &quot;$@&quot;; do
   if [ -f &quot;$file&quot; ]; then
      newfile=`echo &quot;$file&quot; | sed &quot;s/${OLD}/${NEW}/g&quot;`
      if [ -f &quot;$newfile&quot; ]; then
　　　　   echo &quot;ERROR: $newfile exists already&quot;
      else
         echo &quot;renaming $file to $newfile ...&quot;
         mv &quot;$file&quot; &quot;$newfile&quot;
      fi
   fi
done
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160629151122468-1904498454.png" alt=""></p>
<p>5.函数<br>格式如下：</p>
<pre><code>函数名(){
    #函数中$1,$2对应接收到的第一第二个参数
}
</code></pre><p>示例代码如下:</p>
<pre><code>#!/bin/bash
add()
{

    echo $(($1+$2))
}
var1=1
var2=2
add $var1 $var2
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160629151200921-881466817.png" alt=""></p>
<p><strong>四、脚本调试</strong><br>最简单的方式是使用echo输出值。</p>
<p><strong>五、Shell编程示例</strong><br>我们有一个日志文件，保存了系统的操作记录。过了一段时间后，这个文件可能会变得很大。<br>我们采取的做法是重命名该文件，然后生成一个新的文件供再次使用。<br>重命名的规则是，当前文件log.txt重名为log1.txt，在此之前，如果已经有log1.txt时，将log。txt命名为log2.txt，依次类推。<br>代码如下：</p>
<pre><code>#!/bin/bash
help()
{
   cat &lt;&lt; HELP
重命名该文件，然后生成一个新的文件供再次使用。
重命名的规则是，当前文件log.txt重名为log1.txt，在此之前，如果已经有log1.txt时，将log。txt命名为log2.txt，依次类推。
HELP
   exit 0
}

if [[ $1 == &apos;-h&apos; || $1 == &apos;&apos; ]]; then
  help
fi

filename=$1

# 我们先找到最大的数字再说。
max=0
while [ -f &quot;$filename.$((++max))&quot; ]; do
  : # 什么都不用做，我们已经顺手用 ++max 自增了 max 了。
done

# 然后从最大的一路重命名下来。
for ((i=max; i&gt;0; i--)); do
  # 数字加个 1，好给前一个让位子。
  if [ -f $filename.$i ];then 
      mv &quot;$filename.$i&quot; &quot;$filename.$((i+1))&quot;
  fi
done

# 最后我们点名要重命名的：
if [ -f &quot;$filename&quot; ]; then
   mv &quot;$filename&quot; &quot;$filename.1&quot;
fi

# 重新创建一下。
: &gt; &quot;$filename&quot;
</code></pre><p>运行程序，./myshell log.txt</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160629151250546-138117983.png" alt=""><br>我们会发现log.txt的日志文件的名称会加1，同时当前的log.txt文件会变成log.txt.1,<br>生成一个全新的log.txt文件，供程序再次使用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux进程间通信-命名管道]]></title>
      <url>https://shijingjing07.github.io/2016/06/27/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93/</url>
      <content type="html"><![CDATA[<p>前面我们讲了进程间通信的一种方式，<a href="http://www.cnblogs.com/shijingjing07/p/5620646.html" target="_blank" rel="external">匿名管道</a>。<br>我们知道，匿名管道只能用于父子关系的进程之间。那么没有这种关系的进程之间该如何进行数据传递呢？</p>
<p><strong>1.什么是命名管道</strong></p>
<p>匿名管道是在缓存中开辟的输出和输入文件流的空间，只能用于父子关系的进程之间。因为父子进程的输入和输出文件描述符是一致的。<br>命名管道是一种实际存在的FIFO文件，称作”管道文件”，用于不同进程之间，命名管道进程间打开同一个FIFO文件，进行数据传递。<br>我们可以像普通文件一样操作FIFO文件。<br>不同进程，引用同一个FIFO文件，进行数据传递。</p>
<p><strong>2.创建命名管道</strong><br>mkfifo函数：创建一个命名管道</p>
<pre><code>int mkfifo(const char *filename,mode_t mode);
</code></pre><p>filename:指定FIFO文件的名称<br>mode:指定文件的读写权限</p>
<p><strong>3.访问命名管道</strong><br>打开FIFO文件有四种方式：</p>
<pre><code>open(const char *filename,O_RDONLY);
open(const char *filename,O_RDONLY|O_NONBLOCK);
open(const char *filename,O_WRONLY);
open(const char *filename,O_WRONLY|O_NONBLOCK);
</code></pre><p>需要注意的是，不能以O_RDWR模式打开FIFO文件，<br>因为这样一个进程写入的数据会被该进程读取，FIFO一般只用做单向的数据传递。</p>
<p>open函数的第二个参数，表示是读管道，还是写管道。<br>O_NONBLOCK表示FIFO管道的读写是非阻塞的，默认的话，是阻塞的。<br>那么何为阻塞呢？<br>一个进程写模式打开管道的时候，必须有另一个进程以读模式打开；<br>或读模式的时候，必须有另一个进程写写模式打开，否则该进程open函数阻塞，直到满足以上关系。</p>
<p>非阻塞，意味着open函数会立即返回，若没有其他进程以只读方式打开，open返回-1，并且FIFO也不会被打开。</p>
<p><strong>4.FIFO管道使用示例</strong><br>下例有两个程序，fifowrite.c和fiforead.c分别写管道和读管道。<br>fifowrite.c中将一个文本文件data.txt,写到管道。<br>fiforead.c中从管道读取数据，并写到dataformfifo.txt文件中。<br>程序使用了默认的阻塞模式。<br>示例代码如下：</p>
<p>fifowrite.c</p>
<pre><code>#include&lt;sys/types.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#include&lt;fcntl.h&gt;
#include&lt;limits.h&gt;
int main()
{
    const char *fifo_name = &quot;/tmp/my_fifo&quot;;
    int pipe_fd = -1;
    int data_fd = -1;
    int res = 0;
    const int open_mode = O_WRONLY;
    char buffer[PIPE_BUF+1];
    if(access(fifo_name,F_OK)==-1)
    {
        res = mkfifo(fifo_name,0777);
        if(res!=0)
        {
            fprintf(stderr,&quot;could not create fifo\n&quot;);
            exit(EXIT_FAILURE);
        }
    }
    printf(&quot;process %d opening fifo O_WRONLY\n&quot;,getpid());
    pipe_fd = open(fifo_name,open_mode);
    data_fd = open(&quot;data.txt&quot;,O_RDONLY);
    printf(&quot;process %d result %d\n&quot;,getpid(),pipe_fd);
    if(pipe_fd!=-1)
    {
        int bytes_read = 0;
        bytes_read = read(data_fd,buffer,PIPE_BUF);
        while(bytes_read&gt;0)
        {
            res = write(pipe_fd,buffer,bytes_read);
            if(res==-1)
            {
                fprintf(stderr,&quot;write error\n&quot;);
                exit(EXIT_FAILURE);
            }
            bytes_read = read(data_fd,buffer,PIPE_BUF);
            buffer[bytes_read]=&apos;\0&apos;;
        }
        close(pipe_fd);
        close(data_fd);
    }
    else{
        exit(EXIT_FAILURE);
    }
    printf(&quot;process %d finished.\n&quot;,getpid());
    exit(EXIT_SUCCESS);
}
</code></pre><p>fiforead.c</p>
<pre><code>#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;fcntl.h&gt;
#include&lt;limits.h&gt;
int main()
{
    const char *fifo_name = &quot;/tmp/my_fifo&quot;;
    int pipe_fd = -1;
    int data_fd = -1;
    int res = 0;
    int open_mode = O_RDONLY;
    char buffer[PIPE_BUF+1];
    int bytes_read = 0;
    int bytes_write = 0;
    memset(buffer,&apos;\0&apos;,sizeof(buffer));

    printf(&quot;process %d opening FIFO O_RDONLY\n&quot;,getpid());
    pipe_fd = open(fifo_name,open_mode);
    data_fd = open(&quot;dataformfifo.txt&quot;,O_WRONLY|O_CREAT,0644);
    printf(&quot;process %d result %d\n&quot;,getpid(),pipe_fd);
    if(pipe_fd!=-1)
    {
        do{
            res = read(pipe_fd,buffer,PIPE_BUF);
            bytes_write = write(data_fd,buffer,res);
            bytes_read +=res;
        }while(res&gt;0);
        close(pipe_fd);
        close(data_fd);
    }
    else{
        exit(EXIT_FAILURE);
    }
    printf(&quot;process %d finished,%d bytes read\n&quot;,getpid(),bytes_read);
    exit(EXIT_SUCCESS);
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160627185210171-680796629.png" alt=""></p>
<p>我们在shell中输入命令 ls -l /tmp/my_fifo查看FIFO管道文件的属性</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160627185221718-1197546836.png" alt=""></p>
<p>可以看到，FIFO文件生成了，第一个字符’p’，表示该文件是一个管道文件。</p>
<p><strong>5.多个进程同时写管道</strong><br>当多个进程同时写管道时，读管道取得的数据是杂乱的。<br>此时，我们可以控制每个进程，当要写入的数据超过某个大小时，才写管道，另外要以阻塞的方式打开FIFO。确保写操作的原子性。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux进程间通信-匿名管道]]></title>
      <url>https://shijingjing07.github.io/2016/06/27/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93/</url>
      <content type="html"><![CDATA[<p>前面我们讲了进程间通信的一种方式，<a href="http://www.cnblogs.com/shijingjing07/p/5619308.html" target="_blank" rel="external">共享内存</a>。下面看一看另一种机制，匿名管道。<br><strong>1.什么是管道</strong><br>管道是一个进程的数据流到另一个进程的通道，即一个进程的数据输出作为另一个进程的数据输入，管道起到了桥梁的作用。<br>比如，在shell中输入命令:ls -l|grep string，ls和grep是两个进程，”|”符号表示管道，意思是执行ls<br>-l进程，并将输出结果result_1，作为grep<br>string进程的输入result_0，grep进程将result_0中存在字符串string的信息打印到屏幕。</p>
<p><strong>2.管道的使用</strong><br>1)popen函数：启用一个新进程，并可以向它传递数据，或者通过它接受数据。</p>
<pre><code>FILE *popen(const char *command,conse char *open_mode);
</code></pre><p>command:运行的程序名和参数<br>open_mode:有两个值”r(只读)”,”w(只写)”<br>　　　　　　“r”:可以获取新进程的输出<br>　　　　　　“w”:可以向新进程发送数据<br>返回值：返回输入输出文件流指针</p>
<p>2)pclose函数：关闭输入输出文件流指针<br>若调用该函数时，新进程仍然在运行，则pclose将等待，直至新进程结束。<br>返回值：返回新进程的退出码。</p>
<p><strong>3.popen函数使用示例</strong><br>下例循环读取read_fp输出文件流的内容，写入write_fp的输入文件流，直到输出流内容读完。</p>
<pre><code>#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
{
    FILE *read_fp = NULL;
    FILE *write_fp = NULL;
    char buffer[BUFSIZ+1];
    int chars_read = 0;

    //初始化缓冲区
    memset(buffer,&apos;\0&apos;,sizeof(buffer));
    read_fp = popen(&quot;ls -l&quot;,&quot;r&quot;);
    write_fp = popen(&quot;grep rwxrwxr-x&quot;,&quot;w&quot;);
    if(read_fp &amp;&amp; write_fp)
    {

        chars_read = fread(buffer,sizeof(char),BUFSIZ,read_fp);
        while(chars_read)
        {
            buffer[chars_read]=&apos;\0&apos;;
            //把数据写入grep进程
            fwrite(buffer,sizeof(char),chars_read,write_fp);
            chars_read = fread(buffer,sizeof(char),BUFSIZ,read_fp);
        }
        //关闭文件流
        pclose(read_fp);
        pclose(write_fp);
        exit(EXIT_SUCCESS);
    }
    printf(&quot;%d\n&quot;,2);
    exit(EXIT_FAILURE);
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160627163409968-520447755.png" alt=""></p>
<p><strong>3、popen的原理及优缺点</strong><br>当调用popen运行一个新进程时，它首先启动shell，然后将command参数传递给它。<br>优点：可以使用shell来分析命令字符串，启动非常复杂的shell命令。<br>缺点：不仅要启动一个新进程，还要启动一个shell，效率会比较低。</p>
<p><strong>4.pipe函数的使用</strong></p>
<pre><code>int pipe(int file_description[2]);
</code></pre><p>file_description[2]:表示管道的输出输入端，输出端数据经过管道流到输入端，函数执行完后， 会将这个数组赋值。<br>　　　　　　　　　　file_description[1]表示管道输出端文件描述符<br>　　　　　　　　　　file_description[0]表示管道输入端文件描述符<br>返回值：0成功，-1失败</p>
<p>与popen不同的是，pipe函数是一个底层调用，不会启动shell。<br>popen是使用文件流(FILE)工作的，pipe使用的是文件描述符，相应的数据要用底层的read和write来读取和发送。</p>
<p><strong>5.pipe函数使用示例</strong><br>下例中，我们在父进程中创建一个管道，然后调用fork创建一个子进程。<br>此时，父进程的file_description[1]输出端，对应着子进程file_description[0]的输入端。<br>数据通过管道由父进程传到子进程。示例如下：</p>
<pre><code>#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
{
    int data_processed = 0;
    const char data[]=&quot;Hello pipe!&quot;;
    char buffer[BUFSIZ+1];
    pid_t pid;
    memset(buffer,&apos;\0&apos;,sizeof(buffer));
    int filedes[2];
    if(pipe(filedes)==0)
    {
        //创建管道成功
        //fork子进程
        pid=fork();
        if(pid==-1)
        {
            fprintf(stderr,&quot;Fork failure&quot;);
            exit(EXIT_FAILURE);
        }
        if(pid==0)
        {
            data_processed = read(filedes[0],buffer,BUFSIZ);
            printf(&quot;read %d bytes:%s\n&quot;,data_processed,buffer);
            exit(EXIT_SUCCESS);
        }
        else
        {
            data_processed = write(filedes[1],data,strlen(data));
            printf(&quot;wrote %d bytes:%s\n&quot;,data_processed,data);
            exit(EXIT_SUCCESS);
        }
    }
    exit(EXIT_FAILURE);
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160627163702187-1041429383.png" alt=""></p>
<p><strong>6.管道用作标准输入和输出</strong><br>我们知道标准的输入描述符为0，输出描述符为1，<br>为了使用已经定义好的标准程序，如od命令，从标准输入读入数据。<br>需要将管道的输入端描述符置为0,此时，我们需要用到一个辅助函数dup</p>
<p>dup函数：创建一个描述符，复制原有描述符参数的结构到新建的描述符。</p>
<pre><code>int dup(int file_descriptor);
</code></pre><p>新的描述符规则是，使用最小的可用值。</p>
<p>要想使管道的输入描述符为标准输入描述符，我们可以先关闭文件描述符0，然后调用dup，<br>此时新建的描述符即为最小可用值0，标准输入描述符。</p>
<pre><code>close(0);
dup(file_description[0]);
</code></pre><p>上例使用标准输入描述符改造后的示例如下：</p>
<pre><code>#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
{
    int data_processed = 0;
    const char data[]=&quot;Hello pipe!&quot;;
    int filedes[2];
    pid_t pid;
    if(pipe(filedes)==0)
    {
        pid = fork();
        if(pid==-1)
        {
            fprintf(&quot;stderr&quot;,&quot;fork failure!\n&quot;);
            exit(EXIT_FAILURE);
        }
        if(pid==0)
        {
            close(0);
            dup(filedes[0]);
            close(filedes[0]);
            close(filedes[1]);
            execlp(&quot;od&quot;,&quot;od&quot;,&quot;-c&quot;,0);
            exit(EXIT_FAILURE);
        }
        else
        {
            close(filedes[0]);
            data_processed = write(filedes[1],data,strlen(data));
            close(filedes[1]);
            printf(&quot;wrote %d bytes:%s\n&quot;,data_processed,data);
        }
    }
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160627163629468-1977430404.png" alt=""></p>
<p><strong>7.匿名管道需要注意的问题</strong><br>1)当管道没有关闭时，若没有数据可读，read调用会阻塞<br>2)当管道关闭时，read调用会返回0<br>3)匿名管道通信，进程间必须是父子关系。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux共享内存]]></title>
      <url>https://shijingjing07.github.io/2016/06/27/Linux%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</url>
      <content type="html"><![CDATA[<p><strong>1.什么是共享内存</strong><br>在前面讲<a href="http://www.cnblogs.com/shijingjing07/p/5611579.html" target="_blank" rel="external">虚拟内存机制</a>时，有讲到Linux的内存映射机制：<br>初始化虚拟内存区域时，会把虚拟内存和磁盘文件对象对应起来。<br>由于内存映射机制，一个磁盘文件对象可被多个进程共享访问，也可被多个进程私有访问。<br>当共享访问时，一个进程的对该对象的修改会显示到其他进程。<br>当私有访问时，修改时会产生保护故障，内核会拷贝这个私有对象，修改的是这个新对象，其他进程指向的是原来的对象。<br>所以，共享内存是指不同进程访问同一个逻辑内存。</p>
<p><strong>2.共享内存的使用</strong><br>Linux提供了一组共享内存API，声明在头文件sys/shm.h中。<br>1)shmget函数：新建共享内存<br>int shmget(key_t key,size_t size,int shmflg);<br>key:共享内存键值，可以理解为共享内存的唯一性标记。<br>size：共享内存大小<br>shmflag：创建进程和其他进程的读写权限标识。<br>返回值：相应的共享内存标识符，失败返回-1</p>
<p>2)shmat函数：连接共享内存到当前进程的地址空间<br>void <em>shmat(int shm_id,const void </em>shm_addr,int shmflg);<br>shm_id：共享内存标识符<br>shm_addr：指定共享内存连接到当前进程的地址，通常为0，表示由系统来选择。<br>shmflg：通常为0<br>返回值：指向共享内存第一个字节的指针，失败返回-1</p>
<p>3)shmdt函数：当前进程分离共享内存<br>int shmdt(const void *shmaddr);</p>
<p>4)shmctl函数<br>和信号量的semctl函数类似，控制共享内存<br>int shmctl(int shm_id,int command,struct shmid_ds *buf);<br>shm_id：共享内存标识符<br>command: 有三个值<br>　　　　　　IPC_STAT:获取共享内存的状态，把共享内存的shmid_ds结构复制到buf中。<br>　　　　　　IPC_SET:设置共享内存的状态，把buf复制到共享内存的shmid_ds结构。<br>　　　　　　IPC_RMID:删除共享内存<br>buf：共享内存管理结构体。具体结构可参考定义。</p>
<p><strong>3.共享内存需要注意的问题</strong><br>共享内存没有同步机制，当多个进程同时向共享内存读写数据时，我们需要使用互斥锁，读写锁，信号量，条件变量等来确保数据的一致性。</p>
<p><strong>4.共享内存使用示例</strong></p>
<p>我们编写了两个程序shmread.c,shmwrite.c分别对共享内存读和写。<br>需要做到可写，然后可读，然后可写，然后可读，循环下去，直到写入的是”end”，结束写读进程。<br>我们使用了前面讲的<a href="http://www.cnblogs.com/shijingjing07/p/5615084.html" target="_blank" rel="external">信号量</a>来处理读写同步的问题。<br>示例代码如下：</p>
<p>shm_data.h</p>
<pre><code>#pragma once                                                                    
#define TEXT_SZ 2048
struct shared_use_st
{
        char text[TEXT_SZ];
};
</code></pre><p>shmread.c</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;sys/shm.h&gt;
#include&lt;sys/sem.h&gt;
#include&quot;shmdata.h&quot;
union semun  
{  
    int val;  
    struct semid_ds *buf;  
    unsigned short *arry;  
}; 
int sem_id;
int set_semvalue()  
{  
    //用于初始化信号量，在使用信号量前必须这样做  
    union semun sem_union;  

    sem_union.val = 1;  
    if(semctl(sem_id, 0, SETVAL, sem_union) == -1)  
        return 0;  
    return 1;  
}  

void del_semvalue()  
{  
    //删除信号量  
    union semun sem_union;  

    if(semctl(sem_id, 0, IPC_RMID, sem_union) == -1)  
        fprintf(stderr, &quot;Failed to delete semaphore\n&quot;);  
}  
int semaphore_p()
{
    struct sembuf sem_b;  
    sem_b.sem_num = 0;  
    sem_b.sem_op = -1;//P()  
    sem_b.sem_flg = SEM_UNDO;  
    if(semop(sem_id, &amp;sem_b, 1) == -1)  
    {  
        fprintf(stderr, &quot;semaphore_p failed\n&quot;);  
        return 0;  
    }  
    return 1;   
}
int semaphore_v()
{
    struct sembuf sem_b;  
    sem_b.sem_num = 0;  
    sem_b.sem_op = 1;//V()  
    sem_b.sem_flg = SEM_UNDO;  
    if(semop(sem_id, &amp;sem_b, 1) == -1)  
    {  
        fprintf(stderr, &quot;semaphore_v failed\n&quot;);  
        return 0;  
    }  
    return 1;  
}
int main()
{
    void *shm=NULL;
    struct shared_use_st *shared;
    int shmid;//共享内存标识符
    //创建共享内存
    shmid = shmget((key_t)1234,sizeof(struct shared_use_st),0666|IPC_CREAT);
    if(shmid==-1)
    {
        fprintf(stderr,&quot;shmget failed\n&quot;);
        exit(EXIT_FAILURE);
    }
    //将共享内存连接到当前进程的地址空间
    shm = shmat(shmid,0,0);
    if(shm==(void*)-1)
    {
        fprintf(stderr,&quot;shmat failed\n&quot;);
        exit(EXIT_FAILURE);
    }
    printf(&quot;memory attached at %x\n&quot;,(int)shm);
    //设置共享内存
    shared = (struct shared_use_st*)shm;

    //新建信号量
    sem_id = semget((key_t)1234,1,0666|IPC_CREAT);

    //信号量初始化
    if(!set_semvalue())
    {
        fprintf(stderr,&quot;init failed.\n&quot;);
        exit(EXIT_FAILURE);
    }

    while(1)
    {
        if(!semaphore_p())
            exit(EXIT_FAILURE);
        fflush(stdout);
        printf(&quot;you wrote:%s&quot;,shared-&gt;text);
        if(!semaphore_v())
            exit(EXIT_FAILURE);
        if(strncmp(shared-&gt;text,&quot;end&quot;,3)==0)
            break;
        sleep(1);
    }

     //删除信号量
    del_semvalue();

    //把共享内存从当前进程中分离
    if(shmdt(shm)==-1)
    {
        fprintf(stderr,&quot;shmdt failed\n&quot;);
        exit(EXIT_FAILURE);
    }
    //删除共享内存
    if(shmctl(shmid,IPC_RMID,0)==-1)
    {
        fprintf(stderr,&quot;shmctl(IPC_RMID) failed&quot;);
        exit(EXIT_FAILURE);
    }
    exit(EXIT_SUCCESS);
}
</code></pre><p>shmwrite.c</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;sys/shm.h&gt;
#include&lt;sys/sem.h&gt;
#include&lt;string.h&gt;
#include&quot;shmdata.h&quot;
int sem_id;
int semaphore_p()
{
    //对信号量做减1操作，即等待P（sv）  
    struct sembuf sem_b;  
    sem_b.sem_num = 0;  
    sem_b.sem_op = -1;//P()  
    sem_b.sem_flg = SEM_UNDO;  
    if(semop(sem_id, &amp;sem_b, 1) == -1)  
    {  
        fprintf(stderr, &quot;semaphore_p failed\n&quot;);  
        return 0;  
    }  
    return 1;  
}  
int semaphore_v()  
{  
    //这是一个释放操作，它使信号量变为可用，即发送信号V（sv）  
    struct sembuf sem_b;  
    sem_b.sem_num = 0;  
    sem_b.sem_op = 1;//V()  
    sem_b.sem_flg = SEM_UNDO;  
    if(semop(sem_id, &amp;sem_b, 1) == -1)  
    {  
        fprintf(stderr, &quot;semaphore_v failed\n&quot;);  
        return 0;  
    }  
    return 1;  
}  
int main()
{
    sem_id = semget((key_t)1234,1,0666|IPC_CREAT);

    void *shm = NULL;
    struct shared_use_st *shared = NULL;
    char buffer[200];
    int shmid;

    //创建共享内存
    shmid = shmget((key_t)1234,sizeof(struct shared_use_st),0666|IPC_CREAT);
    if(shm==-1)
    {
        fprintf(stderr,&quot;shmget failed\n&quot;);
        exit(EXIT_FAILURE);
    }
    //将共享内存连接到当前进程的地址空间
    shm = shmat(shmid,(void*)0,0);
    if(shm == (void*)-1)
    {
        fprintf(stderr,&quot;shmat failed\n&quot;);
        exit(EXIT_FAILURE);
    }
    printf(&quot;memory attached at %x\n&quot;,(int)shm);
    //设置共享内存
    shared = (struct shared_use_st*)shm;
    while(1)
    {
        if(!semaphore_p())
            exit(EXIT_FAILURE);
        //向共享内存中写入数据
        fflush(stdout);
        printf(&quot;Enter some text...\n&quot;);
        fgets(buffer,200,stdin);
        strncpy(shared-&gt;text,buffer,TEXT_SZ);
        if(!semaphore_v())
            exit(EXIT_FAILURE);
        if(strncmp(shared-&gt;text,&quot;end&quot;,3)==0)
            break;
        sleep(1);
    }
    //把共享内存从当前进程中分离
    if(shmdt(shm)==-1)
    {
        fprintf(stderr,&quot;shmdt failed\n&quot;);
        exit(EXIT_FAILURE);
    }
    sleep(2);
    exit(EXIT_SUCCESS);
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160627095232531-98650326.png" alt=""></p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160627095248421-314034952.png" alt=""></p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160627095259265-723118106.png" alt=""></p>
<p><strong>5.共享内存的优缺点</strong><br>1)进程间通信方便，快速。<br>2)没有提供同步机制，我们需要使用互斥锁，读写锁，信号量，条件变量等来确保数据的一致性。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux信号量详解]]></title>
      <url>https://shijingjing07.github.io/2016/06/24/Linux%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><strong>1.什么是信号量</strong><br>信号量是一种特殊的变量，访问具有原子性。<br>只允许对它进行两个操作：<br>1)等待信号量<br>当信号量值为0时，程序等待；当信号量值大于0时，信号量减1，程序继续运行。<br>2)发送信号量<br>将信号量值加1。</p>
<p>我们使用信号量，来解决进程或线程间共享资源引发的同步问题。</p>
<p><strong>2.Linux中信号量的使用</strong><br>Linux提供了一组信号量API，声明在头文件sys/sem.h中。<br>1)semget函数：新建信号量</p>
<pre><code>int semget(key_t key,int num_sems,int sem_flags);
</code></pre><p>key:信号量键值，可以理解为信号量的唯一性标记。<br>num_sems:信号量的数目，一般为1<br>sem_flags:有两个值，IPC_CREATE和IPC_EXCL，<br>IPC_CREATE表示若信号量已存在，返回该信号量标识符。<br>IPC_EXCL表示若信号量已存在，返回错误。  </p>
<p>返回值：相应的信号量标识符，失败返回-1</p>
<p>2)semop函数：修改信号量的值</p>
<pre><code>int semop(int sem_id,struct sembuf *sem_opa,size_t num_sem_ops);
</code></pre><p>sem_id:信号量标识符<br>sem_opa:结构如下</p>
<pre><code>struct sembuf{  
    short sem_num;//除非使用一组信号量，否则它为0  
    short sem_op;//信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即P（等待）操作，  
                    //一个是+1，即V（发送信号）操作。  
    short sem_flg;//通常为SEM_UNDO,使操作系统跟踪信号，  
                    //并在进程没有释放该信号量而终止时，操作系统释放信号量  
}; 
</code></pre><p>3)semctl函数：用于信号量的初始化和删除</p>
<pre><code>int semctl(int sem_id,int sem_num,int command,[union semun sem_union]);
</code></pre><p>command:有两个值SETVAL,IPC_RMID，分别表示初始化和删除信号量。<br>sem_union:可选参数，结构如下：</p>
<pre><code>union semun{  
    int val; 
    struct semid_ds *buf;  
    unsigned short *arry;  
}; 
</code></pre><p>一般用到的是val,表示要传给信号量的初始值。</p>
<p><strong>3.Linux信号量使用示例</strong><br>下例中，我们写了一个程序，程序中有一个char类型的字符,char message=’x’<br>然后同时运行这个程序的两个实例。<br>第一个实例，带一个参数，将参数的第一个字符赋给message，比如为’0’<br>第二个实例，使用默认message值’x’<br>我们的目的是，使用信号量，循环执行这两个实例，<br>我们可以看到执行结果应该是’x0x0x0x0x0x0’</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;sys/sem.h&gt;
union semun
{
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};
int sem_id;
int set_semvalue()
{
    union semun sem_union;    
    sem_union.val = 1;
    if(semctl(sem_id,0,SETVAL,sem_union)==-1)
        return 0;
    return 1;
}
int semaphore_p()
{
    struct sembuf sem_b;
    sem_b.sem_num = 0;
    sem_b.sem_op = -1;
    sem_b.sem_flg = SEM_UNDO;
    if(semop(sem_id,&amp;sem_b,1)==-1)
    {
        fprintf(stderr,&quot;semaphore_p failed\n&quot;);
        return 0;
    }
    return 1;
}
int semaphore_v()
{
    struct sembuf sem_b;
    sem_b.sem_num = 0;
    sem_b.sem_op = 1;
    sem_b.sem_flg = SEM_UNDO;
    if(semop(sem_id,&amp;sem_b,1)==-1)
    {
        fprintf(stderr,&quot;semaphore_v failed\n&quot;);
        return 0;
    }
    return 1;
}
void del_semvalue()
{
    //删除信号量
    union semun sem_union;
    if(semctl(sem_id,0,IPC_RMID,sem_union)==-1)
        fprintf(stderr,&quot;Failed to delete semaphore\n&quot;);
}
int main(int argc,char *argv[])
{
    char message = &apos;x&apos;;
    //创建信号量
     sem_id = semget((key_t)1234,1,0666|IPC_CREAT);
    if(argc&gt;1)
    {
        //初始化信号量
        if(!set_semvalue())
        {
            fprintf(stderr,&quot;init failed\n&quot;);
            exit(EXIT_FAILURE);
        }
        //参数的第一个字符赋给message
        message = argv[1][0];
    }
    int i=0;
    for(i=0;i&lt;5;i++)
    {
        //等待信号量
        if(!semaphore_p())
            exit(EXIT_FAILURE);
        printf(&quot;%c&quot;,message);
        fflush(stdout);
        sleep(1);
        //发送信号量
        if(!semaphore_v())
            exit(EXIT_FAILURE);
        sleep(1);
    }
    printf(&quot;\n%d-finished\n&quot;,getpid());
    if(argc&gt;1)
    {
        //退出前删除信号量
        del_semvalue();
    }
    exit(EXIT_SUCCESS);
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160624181814063-1372067931.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[虚拟内存机制]]></title>
      <url>https://shijingjing07.github.io/2016/06/23/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p><strong>1.为什么要有虚拟内存</strong><br>在早期的计算机中，是没有虚拟内存的概念的。我们要运行一个程序，会把程序全部装入内存，然后运行。<br>当运行多个程序时，经常会出现以下问题：<br>1)进程地址空间不隔离，没有权限保护。<br>由于程序都是直接访问物理内存，所以一个进程可以修改其他进程的内存数据，<br>甚至修改内核地址空间中的数据。<br>2)内存使用效率低<br>当内存空间不足时，要将其他程序暂时拷贝到硬盘，然后将新的程序装入内存运行。<br>由于大量的数据装入装出，内存使用效率会十分低下。<br>3)程序运行的地址不确定<br>因为内存地址是随机分配的，所以程序运行的地址也是不确定的。</p>
<p><strong>2.虚拟地址和物理地址</strong><br>对于32位系统，寻址指针为4字节，对应的虚拟地址空间为0-2^32，即0-4G。<br>对于64位系统，寻址指针为8字节，对应的虚拟地址空间为0-2^64，即0-16G。<br>要注意的是，这个地址空间是虚拟的，并非实际存在的。<br>Linux内核把虚拟地址空间分为两部分：用户进程空间，内核进程空间。<br>如下入所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160623171752625-325593160.png" alt=""></p>
<p>在缓存原理中，换入/换出的数据以块为最小单位。在内存管理时，页是地址空间的最小单位。<br>虚拟地址空间划分为多个固定大小的虚拟页(VP),物理地址空间(DRAM内存)划分为多个固定大小的物理页(PP),<br>虚拟页和物理页的大小是一样的，通常为4KB。</p>
<p>虚拟页和物理页存在着以下关系：<br>虚拟页和磁盘文件映射，然后缓存到物理页。<br>根据是否映射，是否缓存，可以将虚拟页的状态分为以下三种：<br>1)未映射的页<br>即虚拟页没有映射到磁盘文件<br>2)未缓存的页<br>虚拟页映射到了磁盘文件，但是没有缓存到物理页，也就是内存上。<br>3)缓存的页<br>虚拟页映射到了磁盘文件，并且缓存到物理页<br>如下图所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160623171815625-1644110249.png" alt=""></p>
<p><strong>3.虚拟地址的工作原理</strong><br>对于进程来说，使用的都是虚拟地址。每个进程维护一个单独的页表。何为页表？<br>页表是一种数组结构，存放着各虚拟页的状态，是否映射，是否缓存。</p>
<p>1)数组的索引号，表示虚拟页号<br>2)数组的值<br>若为null，表示未映射的页<br>若非null，第一位表示有效位，为1，表明缓存的页；为0，表明未缓存的页。<br>其余位表示缓存到的物理页号。</p>
<p>页表结构图如下：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160623173846485-1317297798.png" alt=""></p>
<p>进程执行时，当需要访问虚拟地址中存放的值时，步骤如下：<br>1)CPU会先找到虚拟地址所在的虚拟页(VP3)，根据页表，找出页表中第3条的值。<br>判断有效位，为1，DRMA缓存命中，获根据物理页号，找到物理页中的内容，返回。<br>2)若有效位为0，产生缺页异常，调用内核缺页异常处理程序。<br>它会选择一个物理页(如PP4)，作为牺牲页，将该页的内容刷新到磁盘文件。然后，把VP3映射的磁盘文件，缓存到该物理页。<br>页表中的第3条，有效位变1，同时，物理页号表号变为PP4。<br>3)缺页异常处理完毕后，返回中断前的指令，重新执行，此时缓存命中，执行1)<br>4)将找到的内容映射到高速缓存，CPU从高速缓存中获取该值，结束。</p>
<p><strong>4.使用虚拟地址需要注意的问题</strong><br>1)磁盘和主存传送页的活动叫做页面调度。页面调度会引起磁盘流量，如果程序的局部性不好，会频繁进行页面调度，叫做”缓存颠簸”。<br>操作系统会在内存中分配一块交换区作为缓冲区，来加速页面的调度。<br>2)一级页表占用的空间是比较大的，根据按需调度的原则，一般使用的是多级页表，即一级页表指向二级页表，这样大大压缩了页表的大小。</p>
<p><strong>5.地址翻译</strong><br>地址翻译指的是DRAM缓存命中时，由虚拟地址找到物理地址的过程。<br>该过程是完全由硬件来完成的。<br>1)CPU有一个专门的页表基地址寄存器(PTBR)指向当前页表的基地址，快速定位到该进程的页表。<br>2)根据虚拟页号，找到虚拟地址在页表的值。<br>3)根据值中的物理页号，找到物理地址。</p>
<p><strong>6.Linux中的虚拟内存机制</strong></p>
<p>Linux把虚拟内存划分成区域area的集合，一个area包括连续的多个页。<br>area的数据结构如下所示：<br>1)内核为每个进程维护了一个单独的任务结果task_struct<br>2)task_struct的mm指针，指向了mm_struct，该结构描述虚拟内存的运行状态。<br>3)mm_struct的pgd指针指向进程的一级页表的基地址。<br>mmap指针，指向vm_area_struct链表。<br>4)vm_area_struct描述area的结构，vm_start表示area的开始位置，vm_end表示area的结束位置，vm_prot表示area内的页的读写权限，vm_flags表示area内的页面是进程私有还是共享，vm_next指向下一个area节点。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160623171927344-1692955841.png" alt=""></p>
<p>在Linux中，当发生缺页异常时，步骤如下：<br>1)缺页异常程序，检查虚拟地址在哪个area内。<br>2)访问的虚拟页若没有读写权限，则触发一个保护异常，终止进程。<br>3)选择牺牲页，刷新到磁盘，从磁盘加载缺失的内容到物理页，更新页表。</p>
<p><strong>7.Linux虚拟内存需要注意的问题</strong><br>内存映射机制:初始化虚拟内存区域时，会把虚拟内存和磁盘文件对象对应起来。</p>
<p>由于内存映射机制，一个磁盘文件对象可被多个进程共享访问，也可被多个进程私有访问。<br>当共享访问时，一个进程的对该对象的修改会显示到其他进程。<br>当私有访问时，修改时会产生保护故障，内核会拷贝这个私有对象，修改的是这个新对象，其他进程指向的是原来的对象。</p>
<p>fork函数是说明内存映射机制很好的例子：<br>fork函数会创建带有独立虚拟地址空间的新进程，内核会把当前进程的虚拟内存中数据结构复制一份给新进程。虚拟内存area包括共享区域和私有区域，新建的进程对私有区域做修改时，会触发写时拷贝，为新进程维护私有的虚拟地址空间。</p>
<p><strong>8.虚拟地址作用总结</strong><br>1)虚拟内存管理可以控制物理内存的访问权限<br>访问的虚拟页若没有读写权限，则触发一个保护异常，终止进程。<br>2)虚拟内存让每个进程有独立的地址空间<br>对于私有区域来说，当不同进程对该区域做修改时，会触发写时拷贝，为新进程维护私有的虚拟地址空间。<br>3)VA到PA的映射会给分配和释放内存带来方便。<br>物理内存不连续的地址，可映射到连续的虚拟内存地址。<br>4)内存效率高<br>使用了页面调度，不会造成大量的数据装入装出。</p>
<p>参考资料: 《深入理解计算机系统》</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux静态库和共享库]]></title>
      <url>https://shijingjing07.github.io/2016/06/22/Linux%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%85%B1%E4%BA%AB%E5%BA%93/</url>
      <content type="html"><![CDATA[<p><strong>1.什么是静态库</strong><br>静态库类似windows中的静态lib</p>
<p>关于windows中的静态lib，可参考<br><a href="http://www.cnblogs.com/shijingjing07/p/5606930.html" target="_blank" rel="external">Windows动态链接库DLL</a></p>
<p>特点：包含函数代码声明和实现，链接后所有代码都嵌入到宿主程序中。<br>只在编译时使用，执行时不再需要该静态库。</p>
<p><strong>2.静态库编写</strong><br>示例如下：<br>addvec.c</p>
<pre><code>void addvec(int* x, int* y, int*z, int n)  
{  
     int i=0;  
     for(; i&lt; n;++i)  
          z[i] = x[i] + y[i];  
}  
</code></pre><p>multvec.c</p>
<pre><code>void multvec(int*x, int* y, int*  z, int n)  
{  
     int i = 0;  
     for(; i &lt; n; ++i)  
          z[i] = x[i] * y[i];  
}
</code></pre><p>使用AR工具创建静态库文件：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160622175529406-1385482834.png" alt=""></p>
<p><strong>3.静态库使用</strong><br>示例如下：<br>test2.c</p>
<pre><code>#include &lt;stdio.h&gt;    
int x[2] = {1, 2};  
int y[2] = {3, 4};  
int z[2]={0};   
int main()  
{  
    addvec(x, y, z, 2);  
    printf(&quot;z = [%d %d]\n&quot;, z[0], z[1]);  
    return 0;  
}
</code></pre><p>编译-链接-运行程序</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160622175600813-1259104162.png" alt=""></p>
<p>1)-static参数，表明是静态链接，编译出的是完整的可执行目标文件。<br>2)当链接器进行链接时，会判断main函数里调用了addvec.o中的addvec函数，<br>没有调用multvec.o中的任何函数，所以，链接器只会拷贝addvec.o到可执行文件。</p>
<p><strong>4.什么是共享库</strong><br>共享库类似windows中的动态链接库dll</p>
<p>特点：包含函数代码声明和实现。<br>只在运行时使用，由动态链接器链接和加载。  </p>
<p>根据链接和加载共享库的时机可分为以下两类：<br>1)自身加载型共享库。<br>2)运行时加载型共享库</p>
<p><strong>5.自身加载型共享库。</strong><br>类似windows中的隐式链接<br>链接时，将共享库的声明信息链接到可执行文件，<br>应用程序加载时，动态链接库解析声明信息，加载共享库的实现到存储器，重定位应用程序中声明信息到实际地址。</p>
<p><strong>6.自身加载型共享库使用示例</strong><br>使用-shared参数，指示编译器创建一个共享库。<br>如下所示，我们创建了一个共享库，并通过自身加载型来使用该共享库。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160622175642485-1797416922.png" alt=""></p>
<p>1)-fPIC参数，指示编译器生成代码无关的代码<br>2)在链接时，没有拷贝共享库libvec.so的实现，只拷贝了一些重定位和符号表信息<br>3)程序加载时，动态链接器会解析共享库libvec.so中代码和数据的引用，重定位完成链接任务。<br>重定位libvec.so的文本和数据到存储器段<br>重定位p2中引用的libvec.so到以上存储器段<br>最后链接器将控制传递给程序，此时，共享库的位置就固定了。</p>
<p><strong>7.运行时加载型共享库</strong><br>类似windows中的显式链接<br>无需编译时链接，可在运行过程中加载和卸载共享库。</p>
<p><strong>8.运行时加载型共享库使用示例</strong><br>Linux提供了一组运行过程中加载和卸载共享库的API，如下所示：  </p>
<p>#include&lt;dlfcn.h&gt;</p>
<pre><code>/* 加载和链接共享库 filename 
    filename：共享库的名字 
    flag有：RTLD_LAZY, RTLD_NOW,二者均可以和RTLD_GLOBAL表示取或 
*/  
void *dlopen(const char *filename, int flag); // 若成功则返回执行句柄的指针，否则返回NULL  

/*根据共享库操作句柄与符号，返回符号对应的地址 
    handle:共享库操作句柄 
    symbol：需要引用的符号名字 
*/  
void *dlsym(void *handle, char *symbol); // 若成功则返回执行符号的指针（即地址），若出错则返回NULL  

/* 如果没有程序正在使用这个共享库，卸载该共享库 */  
int dlclose(void *handle); // 若卸载成功，则返回0，否则返回-1  

/* 捕捉最近发生的错误 */  
const char *dlerror(void); // 若前面对dlopen，dlsym或dlclose调用失败，则返回错误消息，否则返回NULL  
</code></pre><p>根据以上API，我们可以方便地加载和卸载共享库，如下所示：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;dlfcn.h&gt;  

int x[2] = {1, 2};  
int y[2] = {3, 4};  
int z[2] ={0};  

int main()  
{  
    void *handle;  
    void (*addvec)(int *, int *, int *,int);  
    char *error;  

    handle = dlopen(&quot;./libvector.so&quot;, RTLD_LAZY);  
    if(!handle){  
        fprintf(stderr, &quot;%s\n&quot;, dlerror());  
        exit(1);  
    }  

    addvec = dlsym(handle, &quot;addvec&quot;);  
    if((error = dlerror()) != NULL){  
        fprintf(stderr, &quot;%s\n&quot;, dlerror());  
        exit(1);  
    }  

    addvec(x, y, z, 2);  
    printf(&quot;z = [%d %d]\n&quot;, z[0], z[1]);  

    if(dlclose(handle) &lt; 0){  
        fprintf(stderr, &quot;%s\n&quot;, dlerror());  
        exit(1);  
    }  

    return 0;  
}  
</code></pre><p>运行程序：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160622175741203-318389061.png" alt=""></p>
<p>其中，-ldl参数，表示程序运行时需要用到共享库</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Windows动态链接库DLL]]></title>
      <url>https://shijingjing07.github.io/2016/06/22/Windows%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93DLL/</url>
      <content type="html"><![CDATA[<p><strong>1.什么是DLL</strong><br>DLL，即动态链接库，是包含若干个函数的库文件，可供其他程序运行时调用。</p>
<p><strong>2.DLL的优缺点</strong><br>优点：代码重用，可供多个程序同时调用</p>
<p>缺点：易发生版本冲突<br>当新版本的动态链接库不兼容旧版本时，其他使用该DLL的程序可能无法正常工作。<br>针对这一问题，我们需要在程序中加上一个manifest文件，指明该程序所使用的DLL版本号。<br>此时，程序将根据manifest加载指定版本的DLL，否则按默认版本加载。</p>
<p><strong>3.关于LIB和DLL</strong><br>LIB，是静态链接库，分为静态lib和动态lib。<br>静态lib:包含函数代码声明和实现，编译后所有代码都嵌入到宿主程序中。不需要再另行调用DLL。<br>动态lib:相当于一个.h头文件，它是对实现部分（.DLL）的导出部分的声明。编译后宿主程序也只包括声明部分。运行时需调用相应的DLL文件。</p>
<p><strong>4.DLL编写</strong><br>1)在vs中，选择”文件”-》”新建”-》”项目”，选择”Visual C++”-》”win32项目”，来创建DLL类库。<br>如下图所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160621180959975-426197335.png" alt=""></p>
<p>2)添加头文件(.h)和源文件(.cpp)<br>mydll.h</p>
<pre><code>extern &quot;C&quot; _declspec(dllexport) int add(int a, int b); 
</code></pre><p>extern关键字：函数可以在本模块或其他模块中使用；<br>“C”：表明函数必须按C语言方式进行编译，因为C++支持函数的重载，编译时会对函数名进行更改（按照函数名+参数类型），<br>       所以需要声明”C”，以便链接时能正确找到相应的函数。<br>_declspec(dllexport)关键字：该函数可以从DLL中导出，程序引入DLL时，只有声明了该关键字的函数，才能导入使用</p>
<p>mydll.cpp</p>
<pre><code>#include &quot;mydll.h&quot; 
int add(int a, int b) //该DLL需要导出的函数功能：加法 
{ 
     return a + b; 
}
</code></pre><p>编译后，我们可以在生成目录中找到相应的DLL文件和LIB文件。</p>
<p>_mydll.dll，<em>mydll.lib</em><br>_</p>
<p><strong>5.DLL调用</strong><br>调用DLL有两种方式。<br>1)显式链接（只使用DLL）</p>
<p>特点：不需要使用相应的lib文件，可随时加载和卸载DLL，方便灵活。</p>
<pre><code>void main(void)
{
    typedef int(*padd)(int a,int b);
    HINSTANCE hDLL;
    padd add;
    HDLL=LoadLibrary(&quot;MyDll.dll&quot;);//加载动态链接库MyDll.dll文件；
    add=(padd)GetProcAddress(hDLL,&quot;add&quot;);
    int result=add(5,8);
    Printf(&quot;计算的结果为%d\n&quot;，result);
    FreeLibrary(hDLL);//卸载MyDll.dll文件；
} 
</code></pre><p>上例通过LoadLibray()将DLL加载到当前的应用程序，并返回当前DLL文件的句柄。<br>然后通过GetProcAddress()函数获取导入到应用程序中的函数指针，<br>函数调用完毕后，使用FreeLibrary()卸载DLL文件。</p>
<p>2)隐式链接（使用LIB,DLL）<em>  
</em></p>
<p>特点：程序开始执行时将DLL文件加载到应用程序中，程序结束后，释放DLL。</p>
<pre><code>#pragma comment(lib，&quot;MyDll.lib&quot;)
extern &quot;C&quot;_declspec(dllimport) int add(int a,int b);
void main()
{
    int a;
    a=add(8,10)
    printf(&quot;计算的结果为%d\n&quot;，a);
}
</code></pre><p>#pragma comment是预处理指令，使得链接器在链接库的时候去找”MyDll.lib”这个库。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux grep命令]]></title>
      <url>https://shijingjing07.github.io/2016/06/17/linux%20grep%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p><strong>1.作用</strong></p>
<p>Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular<br>Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。</p>
<p><strong>2.格式</strong><br>grep [options]</p>
<p><strong>3.主要参数</strong><br>[options]主要参数：<br>－c：只输出匹配行的计数。<br>－I：不区分大 小写(只适用于单字符)。<br>－h：查询多文件时不显示文件名。<br>－l：查询多文件时只输出包含匹配字符的文件名。<br>－n：显示匹配行及 行号。<br>－s：不显示不存在或无匹配文本的错误信息。<br>－v：显示不包含匹配文本的所有行。<br>pattern正则表达式主要参数：<br>\： 忽略正则表达式中特殊字符的原有含义。<br>^：匹配正则表达式的开始行。<br>$: 匹配正则表达式的结束行。<br>\&lt;：从匹配正则表达 式的行开始。<br>\&gt;：到匹配正则表达式的行结束。<br>[ ]：单个字符，如[A]即A符合要求 。<br>[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。<br>。：所有的单个字符。  </p>
<ul>
<li>：有字符，长度可以为0。</li>
</ul>
<p><strong>4.grep命令使用简单实例</strong><br>$ grep ‘test’ d<em><br>显示所有以d开头的文件中包含 test的行。<br>$ grep ‘test’ aa bb cc<br>显示在aa，bb，cc文件中匹配test的行。<br>$ grep ‘[a-z]\{5\}’ aa<br>显示所有包含每个字符串至少有5个连续小写字符的字符串的行。<br>$ grep ‘w\(es\)t.</em>\1′ aa<br>如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符(.<em>)，这些字符后面紧跟着<br>另外一个es(\1)，找到就显示该行。如果用egrep或grep -E，就不用”\”号进行转义，直接写成’w(es)t.</em>\1′就可以了。</p>
<p><strong>5.grep命令使用复杂实例</strong><br>假设您正在’/usr/src/Linux/Doc’目录下搜索带字符 串’magic’的文件：<br>$ grep magic /usr/src/Linux/Doc/<em><br>sysrq.txt:</em> How do I enable the magic SysRQ key?<br>sysrq.txt:<em> How do I use the magic SysRQ key?<br>其中文件’sysrp.txt’包含该字符串，讨论的是 SysRQ 的功能。<br>默认情况下，’grep’只搜索当前目录。如果 此目录下有许多子目录，’grep’会以如下形式列出：<br>grep: sound: Is a directory<br>这可能会使’grep’ 的输出难于阅读。这里有两种解决的办法：<br>明确要求搜索子目录：grep -r<br>或忽略子目录：grep -d skip<br>如果有很多 输出时，您可以通过管道将其转到’less’上阅读：<br>$ grep magic /usr/src/Linux/Documentation/</em> | less<br>这样，您就可以更方便地阅读。</p>
<p>有一点要注意，您必需提供一个文件过滤方式(搜索全部文件的话用 *)。如果您忘了，’grep’会一直等着，直到该程序被中断。如果您遇到了这样的情况，按<br>&lt;CTRL c&gt; ，然后再试。</p>
<p>下面还有一些有意思的命令行参数：<br>grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写，<br>grep -l pattern files ：只列出匹配的文件名，<br>grep -L pattern files ：列出不匹配的文件名，<br>grep -w pattern files ：只匹配整个单词，而不是字符串的一部分(如匹配’magic’，而不是’magical’)，<br>grep -C number pattern files ：匹配的上下文分别显示[number]行，<br>grep pattern1 | pattern2 files ：显示匹配 pattern1 或 pattern2 的行，<br>grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行。</p>
<p>grep -n pattern files  即可显示行号信息</p>
<p>grep -c pattern files  即可查找总行数</p>
<p>这里还有些用于搜索的特殊符号：<br>\&lt; 和 \&gt; 分别标注单词的开始与结尾。<br>例如：<br>grep man <em> 会匹配 ‘Batman’、’manic’、’man’等，<br>grep ‘\&lt;man’ </em> 匹配’manic’和’man’，但不是’Batman’，<br>grep ‘\&lt;man\&gt;’ 只匹配’man’，而不是’Batman’或’manic’等其他的字符串。<br>‘^’：指匹配的字符串在行首，<br>‘$’：指匹配的字符串在行 尾，</p>
<h2 id="Grep-命令-用法大全"><a href="#Grep-命令-用法大全" class="headerlink" title="Grep 命令 用法大全"></a>Grep 命令 用法大全</h2><p>1、 参数：<br>-I ：忽略大小写<br>-c ：打印匹配的行数<br>-l ：从多个文件中查找包含匹配项<br>-v ：查找不包含匹配项的行<br>-n：打印包含匹配项的行和行标   </p>
<p>2、RE（正则表达式）<br>\ 忽略正则表达式中特殊字符的原有含义<br>^ 匹配正则表达式的开始行<br>$ 匹配正则表达式的结束行<br>\&lt; 从匹配正则表达式的行开始<br>\&gt; 到匹配正则表达式的行结束<br>[ ] 单个字符；如[A] 即A符合要求<br>[ - ] 范围 ；如[A-Z]即A，B，C一直到Z都符合要求<br>. 所有的单个字符  </p>
<ul>
<li>所有字符，长度可以为0   </li>
</ul>
<p>3、举例  </p>
<h1 id="ps-ef-grep-in-telnetd"><a href="#ps-ef-grep-in-telnetd" class="headerlink" title="ps -ef | grep in.telnetd"></a>ps -ef | grep in.telnetd</h1><p>root 19955 181 0 13:43:53 ? 0:00 in.telnetd  </p>
<h1 id="more-size-txt-size文件的内容"><a href="#more-size-txt-size文件的内容" class="headerlink" title="more size.txt size文件的内容"></a>more size.txt size文件的内容</h1><p>b124230<br>b034325<br>a081016<br>m7187998<br>m7282064<br>a022021<br>a061048<br>m9324822<br>b103303<br>a013386<br>b044525<br>m8987131<br>B081016<br>M45678<br>B103303<br>BADc2345  </p>
<h1 id="more-size-txt-grep-‘-a-b-’-范围-；如-A-Z-即A，B，C一直到Z都符合要求"><a href="#more-size-txt-grep-‘-a-b-’-范围-；如-A-Z-即A，B，C一直到Z都符合要求" class="headerlink" title="more size.txt | grep ‘[a-b]’ 范围 ；如[A-Z]即A，B，C一直到Z都符合要求"></a>more size.txt | grep ‘[a-b]’ 范围 ；如[A-Z]即A，B，C一直到Z都符合要求</h1><p>b124230<br>b034325<br>a081016<br>a022021<br>a061048<br>b103303<br>a013386<br>b044525  </p>
<h1 id="more-size-txt-grep-‘-a-b-’"><a href="#more-size-txt-grep-‘-a-b-’" class="headerlink" title="more size.txt | grep ‘[a-b]’*"></a>more size.txt | grep ‘[a-b]’*</h1><p>b124230<br>b034325<br>a081016<br>m7187998<br>m7282064<br>a022021<br>a061048<br>m9324822<br>b103303<br>a013386<br>b044525<br>m8987131<br>B081016<br>M45678<br>B103303<br>BADc2345  </p>
<h1 id="more-size-txt-grep-‘-b’-单个字符；如-A-即A符合要求"><a href="#more-size-txt-grep-‘-b’-单个字符；如-A-即A符合要求" class="headerlink" title="more size.txt | grep ‘**b’ 单个字符；如[A] 即A符合要求"></a>more size.txt | grep ‘**b’ 单个字符；如[A] 即A符合要求</h1><p>b124230<br>b034325<br>b103303<br>b044525  </p>
<h1 id="more-size-txt-grep-‘-bB-’"><a href="#more-size-txt-grep-‘-bB-’" class="headerlink" title="more size.txt | grep ‘[bB]’"></a>more size.txt | grep ‘[bB]’</h1><p>b124230<br>b034325<br>b103303<br>b044525<br>B081016<br>B103303<br>BADc2345  </p>
<h1 id="grep-‘root’-etc-group"><a href="#grep-‘root’-etc-group" class="headerlink" title="grep ‘root’ /etc/group"></a>grep ‘root’ /etc/group</h1><p>root::0:root<br>bin::2:root,bin,daemon<br>sys::3:root,bin,sys,adm<br>adm::4:root,adm,daemon<br>uucp::5:root,uucp<br>mail::6:root<br>tty::7:root,tty,adm<br>lp::8:root,lp,adm<br>nuucp::9:root,nuucp<br>daemon::12:root,daemon  </p>
<h1 id="grep-‘-root’-etc-group-匹配正则表达式的开始行"><a href="#grep-‘-root’-etc-group-匹配正则表达式的开始行" class="headerlink" title="grep ‘^root’ /etc/group 匹配正则表达式的开始行"></a>grep ‘^root’ /etc/group 匹配正则表达式的开始行</h1><p>root::0:root  </p>
<h1 id="grep-‘uucp’-etc-group"><a href="#grep-‘uucp’-etc-group" class="headerlink" title="grep ‘uucp’ /etc/group"></a>grep ‘uucp’ /etc/group</h1><p>uucp::5:root,uucp<br>nuucp::9:root,nuucp  </p>
<h1 id="grep-‘-lt-uucp’-etc-group"><a href="#grep-‘-lt-uucp’-etc-group" class="headerlink" title="grep ‘\&lt;uucp’ /etc/group"></a>grep ‘\&lt;uucp’ /etc/group</h1><p>uucp::5:root,uucp  </p>
<h1 id="grep-‘root-’-etc-group-匹配正则表达式的结束行"><a href="#grep-‘root-’-etc-group-匹配正则表达式的结束行" class="headerlink" title="grep ‘root$’ /etc/group 匹配正则表达式的结束行"></a>grep ‘root$’ /etc/group 匹配正则表达式的结束行</h1><p>root::0:root<br>mail::6:root  </p>
<h1 id="more-size-txt-grep-i-‘b1-3’-i-：忽略大小写"><a href="#more-size-txt-grep-i-‘b1-3’-i-：忽略大小写" class="headerlink" title="more size.txt | grep -i ‘b1..*3’ -i ：忽略大小写"></a>more size.txt | grep -i ‘b1..*3’ -i ：忽略大小写</h1><p>b124230<br>b103303<br>B103303  </p>
<h1 id="more-size-txt-grep-iv-‘b1-3’-v-：查找不包含匹配项的行"><a href="#more-size-txt-grep-iv-‘b1-3’-v-：查找不包含匹配项的行" class="headerlink" title="more size.txt | grep -iv ‘b1..*3’ -v ：查找不包含匹配项的行"></a>more size.txt | grep -iv ‘b1..*3’ -v ：查找不包含匹配项的行</h1><p>b034325<br>a081016<br>m7187998<br>m7282064<br>a022021<br>a061048<br>m9324822<br>a013386<br>b044525<br>m8987131<br>B081016<br>M45678<br>BADc2345  </p>
<h1 id="more-size-txt-grep-in-‘b1-3’"><a href="#more-size-txt-grep-in-‘b1-3’" class="headerlink" title="more size.txt | grep -in ‘b1..*3’"></a>more size.txt | grep -in ‘b1..*3’</h1><p>1:b124230<br>9:b103303<br>15:B103303  </p>
<h1 id="grep-‘-’-etc-init-d-nfs-server-wc-l"><a href="#grep-‘-’-etc-init-d-nfs-server-wc-l" class="headerlink" title="grep ‘$’ /etc/init.d/nfs.server | wc -l"></a>grep ‘$’ /etc/init.d/nfs.server | wc -l</h1><p>128  </p>
<h1 id="grep-‘-’-etc-init-d-nfs-server-wc-l-忽略正则表达式中特殊字符的原有含义"><a href="#grep-‘-’-etc-init-d-nfs-server-wc-l-忽略正则表达式中特殊字符的原有含义" class="headerlink" title="grep ‘\$’ /etc/init.d/nfs.server | wc -l 忽略正则表达式中特殊字符的原有含义"></a>grep ‘\$’ /etc/init.d/nfs.server | wc -l 忽略正则表达式中特殊字符的原有含义</h1><p>15  </p>
<h1 id="grep-‘-’-etc-init-d-nfs-server"><a href="#grep-‘-’-etc-init-d-nfs-server" class="headerlink" title="grep ‘\$’ /etc/init.d/nfs.server"></a>grep ‘\$’ /etc/init.d/nfs.server</h1><p>case “$1” in<br>&gt;/tmp/sharetab.$$<br>[ “x$fstype” != xnfs ] &amp;&amp;<br>echo “$path\t$res\t$fstype\t$opts\t$desc”<br>&gt;&gt;/tmp/sharetab.$$<br>/usr/bin/touch -r /etc/dfs/sharetab /tmp/sharetab.$$<br>/usr/bin/mv -f /tmp/sharetab.$$ /etc/dfs/sharetab<br>if [ -f /etc/dfs/dfstab ] &amp;&amp; /usr/bin/egrep -v ‘^[ ]*(#|$)’<br>if [ $startnfsd -eq 0 -a -f /etc/rmmount.conf ] &amp;&amp;<br>if [ $startnfsd -ne 0 ]; then<br>elif [ ! -n “$_INIT_RUN_LEVEL” ]; then<br>while [ $wtime -gt 0 ]; do<br>wtime=<code>expr $wtime - 1</code><br>if [ $wtime -eq 0 ]; then<br>echo “Usage: $0 { start | stop }”  </p>
<h1 id="more-size-txt"><a href="#more-size-txt" class="headerlink" title="more size.txt"></a>more size.txt</h1><p>the test file<br>their are files<br>The end  </p>
<h1 id="grep-‘the’-size-txt"><a href="#grep-‘the’-size-txt" class="headerlink" title="grep ‘the’ size.txt"></a>grep ‘the’ size.txt</h1><p>the test file<br>their are files  </p>
<h1 id="grep-‘-lt-the’-size-txt"><a href="#grep-‘-lt-the’-size-txt" class="headerlink" title="grep ‘\&lt;the’ size.txt"></a>grep ‘\&lt;the’ size.txt</h1><p>the test file<br>their are files  </p>
<h1 id="grep-‘the-gt-’-size-txt"><a href="#grep-‘the-gt-’-size-txt" class="headerlink" title="grep ‘the\&gt;’ size.txt"></a>grep ‘the\&gt;’ size.txt</h1><p>the test file  </p>
<h1 id="grep-‘-lt-the-gt-’-size-txt"><a href="#grep-‘-lt-the-gt-’-size-txt" class="headerlink" title="grep ‘\&lt;the\&gt;’ size.txt"></a>grep ‘\&lt;the\&gt;’ size.txt</h1><p>the test file  </p>
<h1 id="grep-‘-lt-Tt-he-gt-’-size-txt"><a href="#grep-‘-lt-Tt-he-gt-’-size-txt" class="headerlink" title="grep ‘\&lt;[Tt]he\&gt;’ size.txt"></a>grep ‘\&lt;[Tt]he\&gt;’ size.txt</h1><p>the test file  </p>
<p>==================================================================  </p>
<p>1,简介<br>使用正则表达式的一个多用途文本搜索工具.这个php?name=%C3%FC%C1%EE” onclick=”tagshow(event)”<br>class=”t_tag”&gt;命令本来是ed行编辑器中的一个php?name=%C3%FC%C1%EE”<br>onclick=”tagshow(event)” class=”t_tag”&gt;命令/过滤器:<br>        g/re/p – global - regular expression - print.<br>基本格式<br>grep pattern [file…]<br>(1)grep 搜索字符串 [filename]<br>(2)grep 正则表达式 [filename]<br>在文件中搜索所有 pattern 出现的位置, pattern 既可以是要搜索的字符串,也可以是一个正则表达式.<br>注意：在输入要搜索的字符串时最好使用双引号/而在模式匹配使用正则表达式时，注意使用单引号  </p>
<p>2,grep的选项<br>    -c 只输出匹配行的计数<br>    -i 不区分大小写（用于单字符）<br>    -n 显示匹配的行号<br>    -v 不显示不包含匹配文本的所以有行<br>    -s 不显示错误信息<br>    -E 使用扩展正则表达式<br>    更多的选项请查看：man grep  </p>
<p>3,常用grep实例  </p>
<p>(1)多个文件查询<br>    grep “sort” *.doc       #见文件名的匹配  </p>
<p>(2)行匹配:输出匹配行的计数<br>    grep -c “48” data.doc   #输出文档中含有48字符的行数  </p>
<p>(3)显示匹配行和行数<br>    grep -n “48” data.doc       #显示所有匹配48的行和行号  </p>
<p>(4)显示非匹配的行<br>    grep -vn “48” data.doc      #输出所有不包含48的行  </p>
<p>(4)显示非匹配的行<br>    grep -vn “48” data.doc      #输出所有不包含48的行  </p>
<p>(5)大小写敏感<br>    grep -i “ab” data.doc       #输出所有含有ab或Ab的字符串的行  </p>
<p>4, 正则表达式的应用  </p>
<p>(1)正则表达式的应用 (注意：最好把正则表达式用单引号括起来)<br>    grep ‘[239].’ data.doc      #输出所有含有以2,3或9开头的，并且是两个数字的行  </p>
<p>(2)不匹配测试<br>    grep ‘^[^48]’ data.doc      #不匹配行首是48的行  </p>
<p>(3)使用扩展模式匹配<br>    grep -E ‘219|216’ data.doc  </p>
<p>(4) …<br>    这需要在实践中不断应用和总结，熟练掌握正则表达式。  </p>
<p>5, 使用类名<br>可以使用国际模式匹配的类名：<br>[[:upper:]]   [A-Z]<br>[[:lower:]]   [a-z]<br>[[:digit:]]   [0-9]<br>[[:alnum:]]   [0-9a-zA-Z]<br>[[:space:]]   空格或tab<br>[[:alpha:]]   [a-zA-Z]  </p>
<p>(1)使用<br>    grep ‘5[[:upper:]][[:upper:]]’ data.doc     #查询以5开头以两个大写字母结尾的行  **</p>
<p><strong>  
</strong>转自：<a href="http://www.cnblogs.com/end/archive/2012/02/21/2360965.html" target="_blank" rel="external">http://www.cnblogs.com/end/archive/2012/02/21/2360965.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++泛型编程原理]]></title>
      <url>https://shijingjing07.github.io/2016/06/17/C++%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p><strong>1.什么是泛型编程</strong><br>前面我们介绍的vector,list,map都是一种数据结构容器，<br>容器本身的存储结构不同，各容器中存在的数据类型也可以不同。<br>但我们在访问这些容器中数据时，拥有相同的方式。<br>这种方式就叫做”泛型编程”，顾名思义，不同的类型采用相同的方式来操作。</p>
<p><strong>2.泛型编程的原理。</strong><br>我们先看下面的两个分别访问数组和链表中元素的示例。<br>示例1，数组类型遍历</p>
<pre><code>void show(double* arr,int n)
{
    for(int i=0;i&lt;n;i++)
        cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;
}
</code></pre><p>示例2，链表类型遍历</p>
<pre><code>struct Node
{
    double item;
    Node * p_next;
};
void show(Node* head)
{
    for(Node* start=head;start!=0;start=start-&gt;p_next)
        cout&lt;&lt;start.item&lt;&lt;&quot; &quot;;
}
</code></pre><p>我们可以看到，数组和链表的访问方式是完全不同的。<br>那么，如何使用相同的方式去访问呢？<br>这两种数据结构的共同点是，它们都是一个顺序存储数据的容器，<br>所以我们可为每一种容器中定义一个相应的指针类p，在泛型编程中，叫做”迭代器类(iterator)”<br>该指针类中需要重载两个操作符，<br>1)<em>p，访问数据元素内容<br>2)p++，访问下一个数据元素<br>示例1，数组容器(double </em>本身具有*p,p++操作符)：</p>
<pre><code>typedef double* iterator;
void show(iterator head,int n)
{
    int i=0;
    for(iterator start=head;i&lt;n;++start)
    {
        cout&lt;&lt;*start&lt;&lt;&quot; &quot;;
        i++
    }
}
</code></pre><p>示例2，链表容器：</p>
<pre><code>struct Node
{
    double item;
    Node * p_next;
};
class iterator
{
    Node *pt;
public:
    double operator*()
    {
        return pt-&gt;item;
    }
    iterator&amp; operator++()
    {
        pt=pt-&gt;p_next;
        return *this;
    }
};
void show(iterator head)
{
    for(iterator start=head;start!=0;++start)
    {
        cout&lt;&lt;*start&lt;&lt;&quot; &quot;;
    }
}
</code></pre><p>我们看到这两种容器的show()方法已基本相同，唯一的区别是结束判断。<br>在数组中，根据数组长度来判断结尾。<br>在链表中，根据最后一个元素指向的下一个元素指针为空来判断。<br>链表比数组多出来一个指向null的指针。</p>
<p>在泛型编程中，使用了”超尾”的概率来解决这个问题，<br>“超尾”是指在容器的最后一个元素后面，还有一个额外的元素，该元素表示结束。<br>这样数组和链表都有这个超尾指针。我们统一使用这个超尾指针来判断结尾。</p>
<p><strong>3.泛型编程中迭代器的使用</strong><br>C++为每个容器类(vector,list,deque等)定义了相应的迭代器类型，<br>其begin()返回指向第一个元素的迭代器，end()返回指向超尾元素(额外添加的元素)的迭代器。<br>如下例所示：</p>
<pre><code>vector&lt;double&gt;::iterator pr;
for(pr=scores.begin();pr!=scores.end();pr++)
    cout&lt;&lt;*pr&lt;&lt;endl;
</code></pre><p>在C++11中，简化了迭代器类型的定义，使用auto自动类型</p>
<pre><code>for(auto pr=scores.begin();pr!=scores.end();pr++)
    cout&lt;&lt;*pr&lt;&lt;endl;
</code></pre><p><strong>4.建议使用的遍历方式</strong><br>很多语言，如C#，并没有使用迭代器iterator，而是使用for,foreach等来遍历数据元素。<br>所以，C++中最好也避免直接使用迭代器，而尽可能使用for_each()。<br>C++11中，新增了for循环，如下例所示：</p>
<pre><code>for(auto x:scores)
    cout&lt;&lt;x&lt;&lt;endl;
</code></pre><p>参考资料：《C++ Primer.Plus》 pp.685-688</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++ typedef详解]]></title>
      <url>https://shijingjing07.github.io/2016/06/16/C++%20typedef%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><strong>1.typedef的用途</strong><br>1)定义一种类型的别名<br>注意typedef并不是简单的宏替换，如下例所示：</p>
<pre><code>int main()
{
    char *pa,pb;//声明了一个指向字符变量的指针pa，和一个字符变量pb
    pa = &quot;hello&quot;;
    pb = &quot;hello&quot;;//报错,不能将const char*类型的值赋给char类型的实体
    pb = &apos;h&apos;;//正常
    return 0;
}
</code></pre><p>再看以下示例：</p>
<pre><code>int main()
{
    typedef char* PCHAR;
    PCHAR pa,pb;
    pa = &quot;hello&quot;;
    pb = &quot;hello&quot;;//正常
    pb = &apos;h&apos;;//报错，不能将char类型的值赋给PCHAR类型实体
    return 0;
}
</code></pre><p>可以看出，typedef char<em> PCHAR;之后，PCHAR是char</em>类型的别名，<br>PCHAR pa,pb;将pa,pb都定义成char*类型。</p>
<p>2)定义struct结构体别名<br>我们知道，当声明一个结构体对象时，必须要带上struct，<br>格式为：struct 结构体名 对象名;<br>如下例所示：</p>
<pre><code>struct tagPOINT1
{
    int x;
    int y;
};
struct tagPOINT1 p1;
</code></pre><p>当我们用typedef定义struct的别名后，可以直接用别名 对象名来声明一个对象。<br>如下例所示：</p>
<pre><code>typedef struct tagPOINT1
{
    int x;
    int y;
}POINT;
POINT p1;
</code></pre><p>3)用typedef来定义与平台无关的类型。<br>比如，某一平台支持int类型，而不支持long类型。<br>则可以使用typedef定义一个支持类型的别名，程序中使用该别名声明变量。<br>这样，我们使用极小的修改，typedef int REAL;就可以实现类型的平台无关性。</p>
<p>标准库中广泛使用了这个技巧。</p>
<p>4)为复杂的声明定义一个简单的别名<br>如：typedef int (*A) (char, char);<br>A是我们定义的别名，表示的是一个指向函数的指针，<br>该函数有两个char类型的参数，返回一个int类型的值。<br>则A类型的对象可以指向任何符合上述规则的函数。<br>如下例所示：</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
typedef int (*A)(char,char);
int fun0(char a,char b);
int fun1(char a,char b);
int main()
{
    A a;
    a = fun0;
    a(&apos;a&apos;,&apos;b&apos;);
    a = fun1;
    a(&apos;a&apos;,&apos;b&apos;);
    return 0;
}
int fun0(char a,char b)
{
    cout&lt;&lt;&quot;fun0&quot;&lt;&lt;endl;
    return 0;
}
int fun1(char a,char b)
{
    cout&lt;&lt;&quot;fun1&quot;&lt;&lt;endl;
    return 0;
}
</code></pre><p>输出结果：<br>fun0<br>fun1</p>
<p><strong>2.typedef和#define的区别</strong><br>由前面的讲解，我们知道typedef和#define有本质的区别。<br>typedef是一种类型别名，而#define只是宏定义。二者并不总是可以互换的。<br>如下例所示：</p>
<pre><code>typedef char *pStr1;
#define pStr2 char *;
pStr1 s1, s2;
pStr2 s3, s4;
</code></pre><p>其中s1, s2, s3是char*类型，而s4是char类型。</p>
<p><strong>3.typedef需要注意的事项。</strong><br>我们看一下下面的示例：</p>
<pre><code>typedef char* pStr;
const char* p1 = &quot;hello&quot;;
const pStr p2 = &quot;hello&quot;;
p1++;//正常
p2++;//报错
</code></pre><p>p1和p2都是常量指针，意思是指针指向的内容不能修改，而指针是可以修改的。<br>那为什么p1++正常，而p2++报错呢。<br>对于p1++,我们不用再解释了，因为常量指针是可变的。<br>而p2是我们定义的别名，而不是系统固有类型，编译器在编译时，会认为p2是常量，不可修改，<br>所以p2++会报错。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++ map详解]]></title>
      <url>https://shijingjing07.github.io/2016/06/15/C++%20map%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><strong>1.什么是map</strong><br>map是一个键值对容器。在处理一对一数据是，很有用。</p>
<p><strong>2.map数据结构的特点</strong><br>map内部自建一颗红黑树，这棵树具有对数据自动排序的功能，<br>因此，map内的数据都是按key的值排好序的。</p>
<p><strong>3.map数据插入</strong><br>数据的插入有三种方法：<br>第一种，调用insert函数，插入pair类型数据<br>示例如下所示：</p>
<pre><code>#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
Using namespace std;
int main()
{
       map&lt;int, string&gt; mapStudent;
       mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_one&quot;));
       mapStudent.insert(pair&lt;int, string&gt;(2, &quot;student_two&quot;));
       mapStudent.insert(pair&lt;int, string&gt;(3, &quot;student_three&quot;));
       map&lt;int, string&gt;::iterator  iter;
       for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)
       {
            cout&lt;&lt;iter-&gt;first&lt;&lt;&quot;   &quot;&lt;&lt;iter-&gt;second&lt;&lt;end;
       }
       return 0;
}
</code></pre><p>第二种，调用insert插入value_type类型数据<br>示例如下所示：</p>
<pre><code>#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
Using namespace std;
int main()
{
       map&lt;int, string&gt; mapStudent;
       mapStudent.insert(map&lt;int, string&gt;::value_type(1, &quot;student_one&quot;));
       mapStudent.insert(map&lt;int, string&gt;::value_type(2, &quot;student_two&quot;));
       mapStudent.insert(map&lt;int, string&gt;::value_type(3, &quot;student_three&quot;));
       map&lt;int, string&gt;::iterator  iter;
       for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)
       {
            cout&lt;&lt;iter-&gt;first&lt;&lt;&quot;   &quot;&lt;&lt;iter-&gt;second&lt;&lt;end;
       }
       return 0;
}
</code></pre><p>第三种，使用数组赋值方式</p>
<pre><code>#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
Using namespace std;
int main()
{
       map&lt;int, string&gt; mapStudent;
       mapStudent[1]=&quot;student_one&quot;;
       mapStudent[2]=&quot;student_two&quot;;
       mapStudent[3]=&quot;student_three&quot;;
       map&lt;int, string&gt;::iterator  iter;
       for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)
       {
            cout&lt;&lt;iter-&gt;first&lt;&lt;&quot;   &quot;&lt;&lt;iter-&gt;second&lt;&lt;end;
       }
       return 0;
}
</code></pre><p>如何判断数据是否插入成功？<br>insert函数的返回值类型为：Pair&lt;map&lt;int,string&gt;::iterator,bool&gt;<br>返回值的key值表示，返回map的迭代器<br>返回值的value值表示，是否插入成功<br>因此，我们可以使用以下代码来判断，map键值对是否插入成功</p>
<pre><code>Pair&lt;map&lt;int,string&gt;::iterator,bool&gt; Insert_Pair=mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_one&quot;));
if(Insert_Pair.second)
    cout&lt;&lt;&quot;success.\n&quot;;
else
    cout&lt;&lt;&quot;failed.\n&quot;;
</code></pre><p><strong>4.map数据查找</strong><br>第一种，使用count方法判定是否存在<br>第二种，使用find方法，定位key出现的位置，该方法返回一个迭代器。<br>当数据出现时，返回数据所在位置的迭代器；<br>否则，返回的迭代器等于end方法返回的迭代器。<br>示例代码如下：</p>
<pre><code>map&lt;int,string&gt;::iterator iter;
iter=mapStudent.find(1);
if(iter!=mapStudent.end())
    cout&lt;&lt;&quot;success find.\n&quot;;
else    
    cout&lt;&lt;&quot;failed.\n&quot;;
</code></pre><p>第三种，使用Lower_bound，Upper_bound方法，返回key的边界，在此，不再详细介绍。</p>
<p><strong>5.map数据删除</strong><br>使用了我们很熟悉的erase函数，map中该函数有三个重载。<br>1)使用迭代器删除</p>
<pre><code>map&lt;int,string&gt;::iterator iter;
iter = mapStudent.find(1);
mapStudent.erase(iter);
</code></pre><p>2)使用关键字key删除</p>
<pre><code>int result = mapStudent.erase(1);
</code></pre><p>成功返回1，否则返回0</p>
<p>3)使用迭代器，删除区间内的数据</p>
<pre><code>mapStudent.erase(mapStudent.begin(),mapStudent.end());
</code></pre><p><strong>6.关于map的自动排序</strong><br>前面我们说过，map内的数据会根据key值由大到小排序,<br>也就是说key值必须支持小于&lt;运算，否则无法插入map。<br>对于上面的示例，我们知道int类型本身是支持小于运算的。<br>但是对于不支持小于运算的key类型，我们该如何插入map呢？<br>很显然，我们需要自定义该类型的&lt;操作符。<br>如下例所示，我们要建立一个map&lt;学生信息,分数&gt;：</p>
<pre><code>typedef struct tagStudentInfo
{
    int nID;
    string strName;
    bool operator&lt;(tagStudentInfo const &amp;_A) const
    {
        if(nID&lt;_A.nID) 
            return true;
        return false;
    }
}StudentInfo,*PStudentInfo;
int main()
{
    map&lt;StudentInfo,int&gt; mapStudent;
    StudentInfo studentInfo;
    studentInfo.nID=1;
    studentInfo.strName=&quot;student_one&quot;;
    mapStudent.insert(pair&lt;StudentInfo, int&gt;(studentInfo,80));
    return 0;
}
</code></pre><p>另外一种方式是，定义一个单独的类，类中定义key类型的比较函数<br>示例代码如下：</p>
<pre><code>typedef struct tagStudentInfo
{
    int nID;
    string strName;

}StudentInfo,*PStudentInfo;
class sort
{
public:
    bool operator()(tagStudentInfo const &amp;_A,tagStudentInfo const &amp;_B) const
    {
        if(_A.nID&lt;_B.nID) 
            return true;
        return false;
    }
}
int main()
{
    map&lt;StudentInfo,int,sort&gt; mapStudent;
    StudentInfo studentInfo;
    studentInfo.nID=1;
    studentInfo.strName=&quot;student_one&quot;;
    mapStudent.insert(pair&lt;StudentInfo, int&gt;(studentInfo,80));
    return 0;
}
</code></pre><p><strong>7.map内存占用</strong><br>前面我们介绍过，map的数据结构为一颗红黑树，<br>该树的一个节点在不保存数据时，占用16字节的空间，<br>包括一个父节点指针，左右孩子指针，还有一个枚举值(标示红黑的，相当于平衡二叉树中的平衡因子)，<br>可见，map还是很耗内存的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++ vector和list的区别]]></title>
      <url>https://shijingjing07.github.io/2016/06/15/C++%20vector%E5%92%8Clist%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p><strong>1.vector数据结构</strong><br>vector和数组类似，拥有一段连续的内存空间，并且起始地址不变。<br>因此能高效的进行随机存取，时间复杂度为o(1);<br>但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。<br>另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。</p>
<p><strong>2.list数据结构</strong><br>list是由双向链表实现的，因此内存空间是不连续的。<br>只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);<br>但由于链表的特点，能高效地进行插入和删除。</p>
<p><strong>3.vector和list的区别</strong><br>我们看一个简单的vector和list使用示例：</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;list&gt;
using namespace std;
int main()
{
    vector&lt;int&gt; v;
    list&lt;int&gt; l;
    for(int i=0;i&lt;8;i++) ////往v和l中分别添加元素
    {
        v.push_back(i);
        l.push_back(i);
    }
    cout&lt;&lt;&quot;v[2]=&quot;&lt;&lt;v[2]&lt;&lt;endl;
    //cout&lt;&lt;&quot;l[2]=&quot;&lt;&lt;l[2]&lt;&lt;endl;  //编译错误,list没有重载[]
    cout&lt;&lt;(v.begin()&lt;v.end())&lt;&lt;endl; 
    //cout&lt;&lt;(l.begin()&lt;l.end())&lt;&lt;endl; /编译错误,list::iterator没有重载&lt;或&gt;
    cout&lt;&lt;*(v.begin()+1)&lt;&lt;endl;
    //cout&lt;&lt;*(l.begin()+1)&lt;&lt;endl; //编译错误,list::iterator没有重载+
    vector&lt;int&gt;::iterator itv=v.begin();
    list&lt;int&gt;::iterator itl=l.begin();
    itv = itv+2;
    //itl=itl+2; //编译错误,list::iterator没有重载+
    itl++; //list::iterator中重载了++，只能使用++进行迭代访问。
    itl++;
    cout&lt;&lt;*itv&lt;&lt;endl;
    cout&lt;&lt;*itl&lt;&lt;endl;
    getchar();
    return 0;
}
</code></pre><p>vector拥有一段连续的内存空间，能很好的支持随机存取，<br>因此vector&lt;int&gt;::iterator支持”+”，”+=”，”&lt;”等操作符。</p>
<p>list的内存空间可以是不连续，它不支持随机访问，<br>因此list&lt;int&gt;::iterator则不支持”+”、”+=”、”&lt;”等</p>
<p>vector&lt;int&gt;::iterator和list&lt;int&gt;::iterator都重载了”++”运算符。</p>
<p>总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;<br>如果需要大量的插入和删除，而不关心随机存取，则应使用list。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++静态存储，动态存储]]></title>
      <url>https://shijingjing07.github.io/2016/06/15/C++%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%EF%BC%8C%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8/</url>
      <content type="html"><![CDATA[<p><strong>什么是静态存储，动态存储</strong><br>静态存储变量通常是在变量定义时就分定存储单元并一直保持不变， 直至整个程序结束。</p>
<p>动态存储变量是在程序执行过程中，使用它时才分配存储单元， 使用完毕立即释放。<br>典型的例子是函数的形式参数，在函数定义时并不给形参分配存储单元，只是在函数被调用时，才予以分配，<br>调用函数完毕立即释放。如果一个函数被多次调用，则反复地分配、 释放形参变量的存储单元。</p>
<p>从以上分析可知， 静态存储变量是一直存在的， 而动态存储变量则时而存在时而消失。<br>我们又把这种由于变量存储方式不同而产生的特性称变量的生存期。 生存期表示了变量存在的时间。<br>生存期和作用域是从时间和空间这两个不同的角度来描述变量的特性，这两者既有联系，又有区别。<br>一个变量究竟属于哪一种存储方式， 并不能仅从其作用域来判断，还应有明确的存储类型说明。</p>
<p><strong>四种变量的存储方式和作用域</strong><br>在Ｃ语言中，有以下四种变量：静态变量(static)、自动变量(auto)、寄存器变量(register)、外部变量(extern)。<br>其中自动变量和寄存器变量属于动态存储方式，外部变量和静态局部变量属于静态存储方式。<br>下面我们详细介绍这四种变量：</p>
<p>一、静态局部变量-静态存储<br>定义格式：<br>static 数据类型 变量名；</p>
<p>存储特点：<br>静态局部变量属于静态存储。<br>在程序执行过程中，即使所在函数调用结束也不释放。<br>换句话说，在程序执行期间，静态局部变量始终存在，但其它函数是不能引用它们的。  </p>
<p>初始化：<br>定义但不初始化，则自动赋以”０”（整型和实型）或’\0’（字符型）；<br>且每次调用它们所在的函数时，不再重新赋初值，只是保留上次调用结束时的值！</p>
<p>使用场合：<br>需要保留函数上一次调用结束时的值。<br>变量只被引用而不改变其值。</p>
<p>二、自动变量-动态存储<br>定义格式：<br>[auto] 数据类型 变量名；</p>
<p>存储特点：<br>自动变量属于动态存储方式。<br>在函数或复合语句中定义的自动变量，只在该函数复合语句内有效；函数复合语句被调用时分配存储空间，调用结束就释放。  </p>
<p>初始化：<br>定义而不初始化，则其值是不确定的。<br>如果初始化，则赋初值操作是在调用时进行的，且每次调用都要重新赋一次初值。</p>
<p>由于自动变量的作用域和生存期，都局限于定义它的个体内（函数或复合语句），<br>因此不同的个体中允许使用同名的变量而不会混淆。<br>即使在函数内定义的自动变量，也可与该函数内部的复合语句中定义的自动变量同名。<br>建议：系统不会混淆，并不意味着人也不会混淆，所以尽量少用同名自动变量！</p>
<p>自动变量与静态局部变量的示例如下：</p>
<pre><code>void  auto_static() 
{      
    int var_auto=0; /*自动变量：每次调用都重新初始化*/ 
    static int var_static=0; /*静态局部变量：只初始化1次*/ 
    printf(&quot;var_auto=%d, var_static=%d\n&quot;, var_auto, var_static); 
    ++var_auto; 
    ++var_static; 
} 
void main() 
{   int i; 
    for(i=0; i&lt;5; i++) 
        auto_static(); 
} 
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160615110055417-1375673411.png" alt=""></p>
<p>三、寄存器变量-动态存储<br>存储特点：<br>一般情况下，变量的值都是存储在内存中的。<br>为提高执行效率，Ｃ语言允许将局部变量的值存放到寄存器中，这种变量就称为寄存器变量。</p>
<p>定义格式：<br>register 数据类型 变量名；  </p>
<p>寄存器变量需要注意以下几点：<br>1)只有局部变量才能定义成寄存器变量，即全局变量不行。<br>2)对寄存器变量的实际处理，随系统而异。例如，微机上的MSC和TC 将寄存器变量实际当作自动变量处理。<br>3)允许使用的寄存器数目是有限的，不能定义任意多个寄存器变量。</p>
<p>四、外部变量-静态存储<br>存储特点：<br>外部变量属于静态存储方式。又分为静态外部变量和非静态外部变量</p>
<p>静态外部变量<br>只允许被本源文件中的函数引用<br>定义格式： static 数据类型 外部变量名；</p>
<p>非静态外部变量<br>允许被其它源文件中的函数引用<br>定义时缺省static关键字的外部变量，即为非静态外部变量。<br>定义格式：数据类型 外部变量名；<br>其它源文件中的函数，引用非静态外部变量时，需要在引用函数所在的源文件中进行说明：<br>格式：extern 数据类型 外部变量表；  </p>
<p>静态局部变量和静态外部变量同属静态存储方式，但两者区别较大：<br>1)定义的位置不同。<br>静态局部变量在函数内定义，静态外部变量在函数外定义。<br>2)作用域不同。<br>静态局部变量属于内部变量，其作用域仅限于定义它的函数内；<br>虽然生存期为整个源程序，但其它函数是不能使用它的。</p>
<p>静态外部变量在函数外定义，其作用域为定义它的源文件内；<br>生存期为整个源程序，但其它源文件中的函数也是不能使用它的。<br>3)初始化处理不同。<br>静态局部变量，仅在第1次调用它所在的函数时被初始化，<br>当再次调用定义它的函数时，不再初始化，而是保留上1次调用结束时的值。<br>而静态外部变量是在函数外定义的，不存在静态内部变量的”重复”初始化问题，<br>其当前值由最近1次给它赋值的操作决定。</p>
<p>把局部变量改变为静态内部变量后，改变了它的存储方式，即改变了它的生存期。<br>把外部变量改变为静态外部变量后，改变了它的作用域，限制了它的使用范围。<br>因此，关键字”static”在不同的地方所起的作用是不同的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++文件输入和输出]]></title>
      <url>https://shijingjing07.github.io/2016/06/13/C++%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/</url>
      <content type="html"><![CDATA[<p><strong>1.引入头文件fstream</strong><br>fstream头文件定义了用于文件输入的类ifstream和文件输出的类ofstream</p>
<p><strong>2.写文件</strong><br>1)创建一个ofstream对象来管理输出流<br>2)将该对象与文件关联起来<br>3)使用cout方式使用该对象，唯一区别是输出将进入文件，而不是屏幕。<br>4)关闭到文件的连接<br>示例如下：</p>
<pre><code>ofstream fout;
fout.open(&quot;test.txt&quot;);
fout&lt;&lt;&quot;write something&quot;;
fout.close();
</code></pre><p>创建对象和关联文件可使用构造函数合并到一步，以上代码等价于：</p>
<pre><code>ofstream fout(&quot;test.txt&quot;);
fout&lt;&lt;&quot;write something&quot;;
fout.close();
</code></pre><p><strong>3.读文件</strong><br>1)创建一个ifstream对象来管理输入流<br>2)将该对象与文件关联起来<br>3)使用ifstream的方法读文件<br>4)关闭到文件的连接<br>示例如下：</p>
<pre><code>ifstream fin(&quot;test.txt&quot;);
char ch;
fin&gt;&gt;ch;//从文件中读取一个字符
char buf[80];
fin&gt;&gt;buf;//从文件中读取一个单词
fin.getline(buf,80);//从文件中读取一行
string line;
getline(fin,line);//读取一行转换成字符串
fin.close();
</code></pre><p><strong>4.读写缓冲区</strong><br>fstream流管理对象在使用cout或cin方式，读或写时，是通过缓冲区和文件进行交互的，<br>而不是逐字节读取或写入文件的。</p>
<p>关于close()函数，当流对象过期(如程序终止)时，到文件的连接自动关闭，<br>也可使用cose()显示关闭该连接。连接关闭后，将刷新缓冲区。</p>
<p>与文件的连接关闭后，并不会删除流，fstream流对象和它管理的缓冲区仍然存在，<br>可以将流重新连接到文件。</p>
<p><strong>5.一个简单的读写文件示例</strong></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;fstream&gt;
#include&lt;string&gt;
using namespace std;
const string filename=&quot;test.txt&quot;;
int main()
{
ofstream fout(filename.c_str());
if(!fout.is_open())
{
cerr&lt;&lt;&quot;无法打开文件 &quot;&lt;&lt;filename&lt;&lt;endl;
exit(0);
}
cout&lt;&lt;&quot;输入密码：&quot;;
float secret;
cin&gt;&gt;secret;
fout&lt;&lt;secret&lt;&lt;endl;
fout.close();

ifstream fin(filename.c_str());
if(!fin.is_open())
{
cerr&lt;&lt;&quot;无法打开文件 &quot;&lt;&lt;filename&lt;&lt;endl;
exit(0);
}
cout&lt;&lt;&quot;输入的密码为：\n&quot;;
char ch;
while(fin.get(ch))
cout&lt;&lt;ch;
fin.close();
return 0;
}
</code></pre><p>程序中is_open()函数，是用来检查文件是否被打开<br>流对象的状态包括：<br>一切顺利，已达到文件尾，I/O操作失败等。如果一切顺利，流状态设置为0，否则设置为1。</p>
<p><strong>6.打开多个文件</strong><br>1)需要同时打开多个文件，则需要为每个文件创建一个流。<br>2)需要依次打开一组文件，可以只打开一个流，将它依次关联到各个文件。</p>
<p>如下例所示：</p>
<pre><code>ifstream fin;
fin.open(&quot;test.txt&quot;);
fin.close();
fin.clear();
fin.open(&quot;test2.txt&quot;);
fin.close();  
</code></pre><p><strong>7.文件模式</strong></p>
<table>
<thead>
<tr>
<th><strong>常量</strong></th>
<th><strong>含义</strong>  </th>
</tr>
</thead>
<tbody>
<tr>
<td>ios_base::in</td>
<td>打开文件，以便读取  </td>
</tr>
<tr>
<td>ios_base::out</td>
<td>打开文件，以便写入  </td>
</tr>
<tr>
<td>ios_base::ate</td>
<td>打开文件，并移到文件尾，和ios_base::app的区别是，后者只能在文件尾写入，前者只是将写入指针初始化在文件尾  </td>
</tr>
<tr>
<td>ios_base::app</td>
<td>追加到文件尾  </td>
</tr>
<tr>
<td>ios_base::trunc</td>
<td>如果文件存在，则清空文件内容  </td>
</tr>
<tr>
<td>ios_base::binary</td>
<td>二进制文件  </td>
</tr>
</tbody>
</table>
<p>对于ifstream open()，默认的模式为ios_base::in<br>对于ofstream open()，默认的模式为ios_base::out|ios_base::trunc，打开并清空文件</p>
<p><strong>8.二进制模式 ios_base::binary </strong></p>
<p>文件的存储类型有两种，文本格式或二进制格式。<br>文本格式便于读取，而二进制格式更加精确，占用空间小，读取速度快。<br>写操作：</p>
<pre><code>fout.write((char*)&amp;T,sizeof T);
</code></pre><p>读操作：</p>
<pre><code>fin.read((char*)&amp;T,sizeof T);
</code></pre><p>注意需要将类型实例地址，强制转换为char*类型。</p>
<p><strong>9.随机存取</strong></p>
<p>随机存取是指，读写指针直接移动到文件的任何位置。</p>
<p>跳转函数：</p>
<pre><code>istream &amp; seekg(streamoff,ios_base::seekdir);//相对地址
istream &amp; seekg(streampos);//绝对地址
</code></pre><p>第一个方法的意思是，离seekdir参数指定文件位置，距离streamoff的位置。<br>其中，streamoff单位的是字节，seekdir表示文件的三个位置(顶端ios_base::beg，底端ios_base::end，当前位置ios_base::cur)</p>
<p>第二个方法的意思是，离文件开头streampos的位置<br>streampos表示文件中的绝对位置，单位是字节</p>
<p>seekg()<br>移到文件开头</p>
<p>tellg()<br>返回读写指针当前的位置</p>
<p>下面，我们用二进制文件模式，写一个简单的随机存取示例：</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;fstream&gt;
#include&lt;iomanip&gt;
const int LIM=20;
struct planet
{
    char name[LIM];
    double population;
    double g;
};
const char *file = &quot;planets.dat&quot;;
inline void eatline(){while(std::cin.get()!=&apos;\n&apos;) continue;}
int main()
{
    using namespace std;
    planet pl;
    cout&lt;&lt;fixed;

    fstream finout;
    finout.open(file,ios_base::in|ios_base::out|ios_base::binary);
    int ct = 0;
    if(finout.is_open())
    {
        finout.seekg(0);
        cout&lt;&lt;&quot;contents of file &quot;&lt;&lt;file&lt;&lt;endl;
        while(finout.read((char *)&amp;pl,sizeof pl))
        {
            cout&lt;&lt;ct++&lt;&lt;&quot;:&quot;&lt;&lt;setw(20)&lt;&lt;pl.name&lt;&lt;&quot;:&quot;
                &lt;&lt;setprecision(0)&lt;&lt;setw(12)&lt;&lt;pl.population
                &lt;&lt;setprecision(2)&lt;&lt;setw(6)&lt;&lt;pl.g&lt;&lt;endl;
        }
        if(finout.eof())
            finout.clear();
        else{
            cerr&lt;&lt;&quot;无法打开文件 &quot;&lt;&lt;file&lt;&lt;endl;
            exit(0);
        }
    }
    else{
        cerr&lt;&lt;&quot;无法打开文件 &quot;&lt;&lt;file&lt;&lt;endl;
        exit(0);
    }
    cout&lt;&lt;&quot;enter record number to change:&quot;;
    long rec;
    cin&gt;&gt;rec;
    eatline();
    if(rec&lt;0||rec&gt;=ct)
    {
        cerr&lt;&lt;&quot;无效 index number&quot;&lt;&lt;endl;
        exit(0);
    }
    streampos place = rec*sizeof pl;
    finout.seekg(place);
    if(finout.fail())
    {
        cerr&lt;&lt;&quot;无法找到 index number&quot;&lt;&lt;endl;
        exit(0);
    }
    finout.read((char *)&amp;pl,sizeof pl);
    cout&lt;&lt;&quot;找到的 index number&quot;&lt;&lt;endl;
    cout&lt;&lt;rec&lt;&lt;&quot;:&quot;&lt;&lt;setw(20)&lt;&lt;pl.name&lt;&lt;&quot;:&quot;
                &lt;&lt;setprecision(0)&lt;&lt;setw(12)&lt;&lt;pl.population
                &lt;&lt;setprecision(2)&lt;&lt;setw(6)&lt;&lt;pl.g&lt;&lt;endl;
    if(finout.eof())
        finout.clear();
    cout&lt;&lt;&quot;输入name:&quot;;
    cin.get(pl.name,LIM);
    eatline();
    cout&lt;&lt;&quot;population:&quot;;
    cin&gt;&gt;pl.population;
    cout&lt;&lt;&quot;g:&quot;;
    cin&gt;&gt;pl.g;
    finout.seekp(place);
    finout.write((char*)&amp;pl,sizeof pl)&lt;&lt;flush;
    if(finout.fail())
    {
        cerr&lt;&lt;&quot;写失败 index number&quot;&lt;&lt;endl;
        exit(0);
    }

    ct = 0;
    finout.seekg(0);
    cout&lt;&lt;&quot;contents of file &quot;&lt;&lt;file&lt;&lt;endl;
    while(finout.read((char *)&amp;pl,sizeof pl))
    {
        cout&lt;&lt;ct++&lt;&lt;&quot;:&quot;&lt;&lt;setw(20)&lt;&lt;pl.name&lt;&lt;&quot;:&quot;
            &lt;&lt;setprecision(0)&lt;&lt;setw(12)&lt;&lt;pl.population
            &lt;&lt;setprecision(2)&lt;&lt;setw(6)&lt;&lt;pl.g&lt;&lt;endl;
    }
    finout.close();
    cout&lt;&lt;&quot;Done.\n&quot;;
    return 0;
}
</code></pre><p>程序中，我们使用了一个特别的流管理对象fstream，<br>fstream继承子iostream,而iostream继承自istream和ostream<br>因此fstream继承了两个缓冲区，一个用于输入，一个用于输出<br>并能同步化两个缓冲区的处理。即输入指针和输出指针的位置始终相同。<br>这样用一个流管理对象，就可以同时进行读和写。</p>
<p>参考资料：《C++ Primer.Plus》 pp.768-788</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++运算符重载详解]]></title>
      <url>https://shijingjing07.github.io/2016/06/12/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><strong>1.什么是运算符重载</strong></p>
<p>运算符重载是一种函数重载。</p>
<p>运算符函数的格式：<br>operatorop(argument-list)<br>例如，operator+()重载+运算符。<br>其中的op，必须是有效的C++运算符，如operator@()会报错，因为C++中没有@运算符。</p>
<p><strong>2.重载运算符的使用</strong></p>
<p>如下例所示：</p>
<pre><code>class Test
{
public:
Test operator+(Test &amp;test);
}
</code></pre><p>调用运算符函数的方式有两种：<br>Test t1;<br>Test t2;<br>1)普通函数调用<br>Test t3 = t1.operator+(t2);<br>2)运算符方式调用，实质上是调用的1)中的operator+()函数<br>Test t3 = t1+t2;</p>
<p><strong>3.运算符重载示例</strong><br>示例代码如下，+运算符重载,计算时分相加。</p>
<p>mytest.h</p>
<pre><code>#pragma once
class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h,int m=0);
    Time operator+(const Time&amp;t) const;
    void Show() const;
};
</code></pre><p>mytest.cpp</p>
<pre><code>#include &quot;mytest.h&quot;
#include&lt;iostream&gt;
Time::Time()
{
    hours=minutes=0;
}
Time::Time(int h,int m)
{
    hours = h;
    minutes = m;
}
Time Time::operator+(const Time &amp;t) const
{
    Time sum;
    sum.minutes = minutes+t.minutes;
    sum.hours = hours+t.hours+sum.minutes/60;
    sum.minutes%=60;
    return sum;
}
void Time::Show() const
{
    std::cout&lt;&lt;hours&lt;&lt;&quot; hours, &quot;&lt;&lt;minutes&lt;&lt;&quot; minutes&quot;&lt;&lt;std::endl;
}
</code></pre><p>test.cpp</p>
<pre><code>#include &quot;mytest.h&quot;
#include &lt;iostream&gt;
int main()
{
    Time planning;
    Time coding(2,40);
    Time fixing(5,55);
    Time total;

    total = coding+fixing;

    std::cout&lt;&lt;&quot;coding+fixing = &quot;;
    total.Show();

    total = coding.operator+(fixing);
    std::cout&lt;&lt;&quot;coding.operator+(fixing) = &quot;;
    total.Show();

    total = coding+fixing+coding;
    std::cout&lt;&lt;&quot;coding.operator+(fixing) = &quot;;
    total.Show();

    return 0;
}
</code></pre><p>输出结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160612111008949-2115776626.png" alt=""></p>
<p><strong>4.运算符重载的注意事项：</strong><br>1)重载的运算符必须是有效的C++运算符<br>2)运算符操作数至少有一个是用户定义类型<br>这是为了防止重载标准类型的运算符<br>如将减法运算符(-)重载为计算两个double的和，而不是差，是不被允许的。<br>3)不能违反运算符原有的规则<br>如求模运算符(%)，必须要有两个操作数。<br>4)部分运算符不允许重载<br>如：sizeof,::,:等</p>
<p>参考资料：《C++ Primer.Plus》 pp.381-390</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图解正向代理、反向代理、透明代理]]></title>
      <url>https://shijingjing07.github.io/2016/06/08/%E5%9B%BE%E8%A7%A3%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<p><strong>一、正向代理(Forward Proxy)</strong></p>
<p>一般情况下，如果没有特别说明，代理技术默认说的是正向代理技术。关于正向代理的概念如下：<br>正向代理(forward)是一个位于客户端【用户A】和原始服务器(origin server)【服务器B】之间的服务器【代理服务器Z】，<br>为了从原始服务器取得内容，用户A向代理服务器Z发送一个请求并指定目标(服务器B)，然后代理服务器Z向服务器B转交请求并将获得的内容返回给客户端。<br>客户端必须要进行一些特别的设置才能使用正向代理。如下图1.1</p>
<p> <img src="http://img1.51cto.com/attachment/201210/105641260.jpg" alt=""></p>
<p>（图1.1）</p>
<p>从上面的概念中，我们看出，文中所谓的正向代理就是代理服务器替代访问方【用户A】去访问目标服务器【服务器B】，这就是正向代理的意义所在。<br>而为什么要用代理服务器去代替访问方【用户A】去访问服务器B呢？这就要从代理服务器使用的意义说起。<br>使用正向代理服务器作用主要有以下几点：<br>1、访问本无法访问的服务器B，如下图1.2</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://img1.51cto.com/attachment/201210/105737336.jpg" alt=""></h2><h2 id="（图1-2）"><a href="#（图1-2）" class="headerlink" title="（图1.2）"></a>（图1.2）</h2><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><p>我们抛除复杂的网络路由情节来看图1.2，假设图中路由器从左到右命名为R1,R2<br>假设最初用户A要访问服务器B需要经过R1和R2路由器这样一个路由节点，<br>如果路由器R1或者路由器R2发生故障，那么就无法访问服务器B了。<br>但是如果用户A让代理服务器Z去代替自己访问服务器B，<br>由于代理服务器Z没有在路由器R1或R2节点中，而是通过其它的路由节点访问服务器B，那么用户A就可以得到服务器B的数据了。</p>
<p>现实中的例子就是”翻墙”。不过自从VPN技术被广泛应用外，”翻墙”不但使用了传统的正向代理技术，有的还使用了VPN技术。</p>
<p>2、加速访问服务器B</p>
<p>这种说法目前不像以前那么流行了，主要是带宽流量的飞速发展。<br>早期的正向代理中，很多人使用正向代理就是提速。还是如图1.2<br>假设用户A到服务器B，经过R1路由器和R2路由器，而R1到R2路由器的链路是一个低带宽链路。<br>而用户A到代理服务器Z，从代理服务器Z到服务器B都是高带宽链路。那么很显然就可以加速访问服务器B了。</p>
<p>3、Cache作用<br>Cache（缓存）技术和代理服务技术是紧密联系的（不光是正向代理，反向代理也使用了Cache（缓存）技术。<br>还如上图所示，如果在用户A访问服务器B某数据J之前，已经有人通过代理服务器Z访问过服务器B上得数据J，那么代理服务器Z会把数据J保存一段时间，<br>如果有人正好取该数据J，那么代理服务器Z不再访问服务器B，而把缓存的数据J直接发给用户A。<br>这一技术在Cache中术语就叫Cache命中。<br>如果有更多的像用户A的用户来访问代理服务器Z，那么这些用户都可以直接从代理服务器Z中取得数据J，而不用千里迢迢的去服务器B下载数据了。</p>
<p>4、客户端访问授权<br>这方面的内容现今使用的还是比较多的，例如一些公司采用ISA SERVER做为正向代理服务器来授权用户是否有权限访问互联网，挼下图1.3</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="http://img1.51cto.com/attachment/201210/105935673.jpg" alt=""></h2><h2 id="（图1-3）"><a href="#（图1-3）" class="headerlink" title="（图1.3）"></a>（图1.3）</h2><p>图1.3防火墙作为网关，用来过滤外网对其的访问。<br>假设用户A和用户B都设置了代理服务器，用户A允许访问互联网，而用户B不允许访问互联网（这个在代理服务器Z上做限制）<br>这样用户A因为授权，可以通过代理服务器访问到服务器B，而用户B因为没有被代理服务器Z授权，<br>所以访问服务器B时，数据包会被直接丢弃。</p>
<p>5、隐藏访问者的行踪<br>如下图1.4 我们可以看出服务器B并不知道访问自己的实际是用户A，因为代理服务器Z代替用户A去直接与服务器B进行交互。<br>如果代理服务器Z被用户A完全控制（或不完全控制），会惯以”肉鸡”术语称呼。</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a><img src="http://img1.51cto.com/attachment/201210/110037136.jpg" alt=""></h2><h2 id="（图1-4）"><a href="#（图1-4）" class="headerlink" title="（图1.4）"></a>（图1.4）</h2><p>我们总结一下<br>正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，<br>为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，<br>然后代理向原始服务器转交请求并将获得的内容返回给客户端。<br>客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。</p>
<p><strong>二、反向代理（reverse proxy）</strong><br>反向代理正好与正向代理相反，<br>对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。<br>客户端向反向代理的命名空间(name-space)中的内容发送普通请求，<br>接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。</p>
<p>使用反向代理服务器的作用如下：<br>1、保护和隐藏原始资源服务器，如下图2.1</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a><img src="http://img1.51cto.com/attachment/201210/110207878.jpg" alt=""></h2><p>（图2.1）</p>
<p>用户A始终认为它访问的是原始服务器B而不是代理服务器Z，但实用际上反向代理服务器接受用户A的应答，从原始资源服务器B中取得用户A的需求资源，然后发送给用户A。由于防火墙的作用，只允许代理服务器Z访问原始资源服务器B。尽管在这个虚拟的环境下，防火墙和反向代理的共同作用保护了原始资源服务器B，但用户A并不知情。</p>
<p>2、负载均衡，如下图2.2</p>
<p> <img src="http://img1.51cto.com/attachment/201210/110311352.jpg" alt=""></p>
<p>（图2.2）</p>
<p>当反向代理服务器不止一个的时候，我们甚至可以把它们做成集群，<br>当更多的用户访问资源服务器B的时候，让不同的代理服务器Z（x）去应答不同的用户，然后发送不同用户需要的资源。  </p>
<p>当然反向代理服务器像正向代理服务器一样拥有CACHE的作用，<br>它可以缓存原始资源服务器B的资源，而不是每次都要向原始资源服务器B请求数据，<br>特别是一些静态的数据，比如图片和文件，<br>如果这些反向代理服务器能够做到和用户X来自同一个网络，那么用户X访问反向代理服务器X，就会得到很高质量的速度。<br>这正是CDN技术的核心。如下图2.3</p>
<h2 id="-5"><a href="#-5" class="headerlink" title=""></a><img src="http://img1.51cto.com/attachment/201210/110403848.jpg" alt=""></h2><h2 id="（图2-3）"><a href="#（图2-3）" class="headerlink" title="（图2.3）"></a>（图2.3）</h2><p>我们并不是讲解CDN，所以去掉了CDN最关键的核心技术智能DNS。只是展示CDN技术实际上利用的正是反向代理原理这块。  </p>
<p>反向代理结论与正向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。<br>客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，<br>并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。  </p>
<p>基本上，网上做正反向代理的程序很多，能做正向代理的软件大部分也可以做反向代理。<br>开源软件中最流行的就是squid，既可以做正向代理，也有很多人用来做反向代理的前端服务器。另外MSISA也可以用来在WINDOWS平台下做正向代理。<br>反向代理中最主要的实践就是WEB服务，近些年来最火的就是Nginx了。<br>网上有人说NGINX不能做正向代理，其实是不对的。NGINX也可以做正向代理，不过用的人比较少了。</p>
<p><strong>三、透明代理</strong><br>透明代理的意思是客户端根本不需要知道有代理服务器的存在，<br>它改编你的request fields（报文），并会传送真实IP。<br>注意，加密的透明代理则是属于匿名代理，意思是不用设置使用代理了。</p>
<p>透明代理实践的例子就是时下很多公司使用的行为管理软件。</p>
<p>比如为了工作效率或者安全，A公司屏蔽了QQ软件的使用。A公司的员工接上了网络，但发现无法使用qq。这就是透明代理捣的鬼。<br>公司在内网和外网的中间插入一个透明代理，这个代理会根据规则抓取请求内容，遇到qq的请求我就把这个请求给屏蔽掉，<br>这样就完成了透明屏蔽。当然了，如果你明白原理，就可以自己搞 个正向代理来绕过公司的屏蔽。如下图3.1</p>
<p><img src="http://img1.51cto.com/attachment/201210/110500391.jpg" alt=""></p>
<h1 id="（图3-1）"><a href="#（图3-1）" class="headerlink" title="（图3.1）"></a>（图3.1）</h1><p>用户A和用户B并不知道行为管理设备充当透明代理行为，<br>当用户A或用户B向服务器A或服务器B提交请求的时候，透明代理设备根据自身策略拦截并修改用户A或B的报文，<br>并作为实际的请求方，向服务器A或B发送请求，<br>当接收信息回传，透明代理再根据自身的设置把允许的报文发回至用户A或B，<br>如上图，如果透明代理设置不允许访问服务器B，那么用户A或者用户B就不会得到服务器B的数据。</p>
<p>转自：<a href="http://z00w00.blog.51cto.com/515114/1031287" target="_blank" rel="external">http://z00w00.blog.51cto.com/515114/1031287</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++ const使用详解]]></title>
      <url>https://shijingjing07.github.io/2016/06/08/C++%20const%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><strong>1.const常量和宏常量</strong><br>const int max=100;  </p>
<p>#define max 100;<br>const常量相对宏常量有两个有点：<br>1)有类型安全检查<br>2)占用内存空间少</p>
<p><strong>2.const变量在内存中的位置</strong><br>我们在C程序的内存布局中，已经通过示例进行了说明</p>
<pre><code>#include &lt;stdio.h&gt;
const int a = 10; ////全部常量a
int main()
{
    const int b = 20; //局部常量b
    int* pa = (int*)&amp;a;//报错，因为全部常量放在只读数据段
    int* pb = (int*)&amp;b;//修改成功，因为局部常量放在栈上
    *pa = 30;
    *pb = 30;
    return 0;
}
</code></pre><p><strong>3.const常成员变量的初始化</strong><br>在某个对象生存期内是常量。</p>
<pre><code>class Test
{
public:
    const int a;
    Test(int i):a(i){}
}
</code></pre><p>const常量只能通过初始化列表的方式进行初始化。</p>
<p><strong>4.const修饰对象</strong><br>该对象不能修改。只能访问成员变量，不能修改。只能调用常成员函数。<br>关于常成员函数，我们在后面介绍。<br>如下例所示:</p>
<pre><code>#include&lt;iostream&gt;
class Test
{
public:
    int a;
    void fun0(){}
    void fun1() const{}
};
int main()
{
    Test test;
    const Test&amp; a_test = test;
    std::cout&lt;&lt;a_test.a&lt;&lt;std::endl;//正常，访问公共成员a
    a_test.fun0();//报错，对象包含与成员函数不兼容的类型限定符
    a_test.fun1();//正常
    return 0;
}
</code></pre><p><strong>5.const修饰指针</strong><br>我们看一下下面四种写法：</p>
<pre><code>1) const int* a = 10;
2) int const *a = 10;
3) int* const a = 10;
4) const int* const a = 10;
</code></pre><p>我们需要知道的是，<br>const在<em>左，表示指针指向的内容为常量，这也是我们平时说的常量指针<br>const在</em>右，表示指针本身为常量，这也是我们平时说的指针常量<br>因此，1),2)表示指针a指向的内容不能修改<br>3)表示指针a本身不能修改<br>4)表示指针a和a指向的内容都不能修改</p>
<p><strong>6.const修饰成员函数,函数参数，返回值</strong><br>1)修饰成员函数</p>
<pre><code>void fun1() const;
</code></pre><p>成员函数名后加上const，即表明该函数为常成员函数。<br>常成员函数的const隐式修饰this指针，即对象不可修改,<br>所以，常成员函数只能访问成员变量，而不能修改。只能调用其他常成员函数。<br>如下例所示:</p>
<pre><code>int g_a;
void g_fun(){}
class Test
{
public:
    void fun0(){}
    void fun1() const{} 
    void fun2() const
    {
        a = 10;//报错，&quot;必须是可修改的左值&quot;
        fun0();//报错，对象包含与成员函数不兼容的类型限定符
        fun1();//正常，可调用其他常成员函数

        g_a = 10;//正常
        g_fun();//正常
    }
private:
    int a;
}
</code></pre><p>2)修饰函数参数</p>
<pre><code>void fun0(const Test* p_test);
void fun1(const Test&amp; test);
</code></pre><p>在传入的参数前，加上const，表明传入的参数不可修改。</p>
<p>3)修饰函数返回值</p>
<pre><code>const Test fun0();
const Test* fun1();
</code></pre><p>当使用const Test* fun1();返回指针时，该返回值只能赋给const修饰的同类型指针。<br>如下例所示：</p>
<pre><code>class Test
{
public:
    void fun0(){}
    const Test fun1(){
        return *this;
    }
    const Test* fun2(){
        return this;
    }
};
int main()
{
    Test test;
    Test r = test.fun1();
    const Test* rp = test.fun2();
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++多继承]]></title>
      <url>https://shijingjing07.github.io/2016/06/06/C++%E5%A4%9A%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<p><strong>1.继承的三种方式：</strong></p>
<p>公有继承(public),私有继承(private),保护继承(protected)<br>三种继承方式的说明，如下表所示：</p>
<table>
<thead>
<tr>
<th><strong>特征</strong></th>
<th><strong>公有继承</strong></th>
<th><strong>保护继承</strong></th>
<th><strong>私有继承</strong>  </th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>公有成员变成</strong></td>
<td><strong>派生类的公有成员</strong></td>
<td><strong>派生类的保护成员</strong></td>
<td><strong>派生类的私有成员</strong>  </td>
</tr>
<tr>
<td><strong>保护成员变成</strong></td>
<td><strong>派生类的保护成员</strong></td>
<td><strong>派生类的保护成员</strong></td>
<td><strong>派生类的私有成员</strong>  </td>
</tr>
<tr>
<td><strong>私有成员变成</strong></td>
<td><strong>只能通过基类接口访问</strong></td>
<td><strong>只能通过基类接口访问</strong></td>
<td><strong>只能通过基类接口访问</strong>  </td>
</tr>
<tr>
<td><strong>能否隐式向上转换</strong></td>
<td><strong>是</strong></td>
<td><strong>是</strong></td>
<td><strong>否</strong>  </td>
</tr>
</tbody>
</table>
<p><strong>2.什么是多继承</strong></p>
<p>一个类有多个基类，那么这种继承关系就叫做多继承。<br>比如有两个类，服务员类Waiter，歌手类Singer，我们有一个类既是服务员，又是歌手，<br>那么我们可以定义类的多继承关系如下：</p>
<pre><code>class Waiter
{};
class Singer
{};
class SingerWaiter:public Waiter,public Singer
{};
</code></pre><p><strong>3.使用多继承会带来哪些问题</strong><br>多继承比单继承复杂，也更容易出现问题，因此我们不建议使用多继承。<br>多继承的两个主要问题是：<br>1)从两个不同的基类，继承同名方法<br>如下例所示：</p>
<pre><code>class Waiter
{
public:
    void work(){std::cout&lt;&lt;&quot;Service&quot;&lt;&lt;std::endl;}
};
class Singer
{
public:
    void work(){std::cout&lt;&lt;&quot;Sing&quot;&lt;&lt;std::endl;}
};
class SingerWaiter:public Waiter,public Singer
{};
int main()
{
    SingerWaiter singerWaiter;
    singerWaiter.work();
    return 0;
}
</code></pre><p>编译器不知道该调用哪个基类的work方法，所以会报singerWaiter.work();不明确错误。<br>2)从多个基类间接继承同一个类的多个实例<br>如下例所示：</p>
<pre><code>class Worker
{};
class Waiter:public Worker
{};
class Singer:public Worker
{};
class SingerWaiter:public Waiter,public Singer
{};
int main()
{
    SingerWaiter singerWaiter;
    Worker *pw = &amp;singerWaiter;
    return 0;
}
</code></pre><p>会报错Worker *pw = &amp;singerWaiter;基类Worker不明确。<br>这是因为SingerWaiter对象创建时，会分别调用Waiter类和Singer类的构造函数，<br>Waiter类和Singer类又会分别调用Worker类的构造函数，生成了两份Worker类的实例，<br>所以pw指针，不知道该指向哪一份Worker实例。</p>
<p><strong>4.如何解决多继承带来的问题</strong><br>对于问题一，我们在调用时，需要明确指出具体要调用哪个类的方法，如下所示：</p>
<pre><code>int main()
{
    SingerWaiter singerWaiter;
    singerWaiter.Waiter::work();//调用Waiter类的方法
    singerWaiter.Singer::work();//调用Singer类的方法
    return 0;
}
</code></pre><p>对于问题二，我们引入了虚基类的概念。如下所示：</p>
<pre><code>class Worker
{};
class Waiter:virtual public Worker
{};
class Singer:virtual public Worker
{};
class SingerWaiter:public Waiter,public Singer
{};
int main()
{
    SingerWaiter singerWaiter;
    Worker *pw = &amp;singerWaiter;
    return 0;
}
</code></pre><p>我们在子类继承时，声明一个virtual关键字，这时，就表明基类Worker是一个虚基类。<br>实例化SingerWaiter时产生的Waiter对象和Singer对象，共享一个基类Worker对象。</p>
<p><strong>5.使用虚基类需要注意的问题</strong><br>我们知道继承关系中，类的构造函数具有传递性，如以下代码所示：</p>
<pre><code>class A
{
private:
    int a;
public:
    A(int n=0):a(n){}
    int get(){return a;}
};
class B:public A
{
private:
    int b;
public:
    B(int m=0,int n=0):A(n),b(m){}
    int get(){return b;}
};
class C:public B
{
private:
    int c;
public:
    C(int q=0,int m=0,int n=0):B(m,n),c(q){}
    int get(){return c;}
    void Show()
    {
        std::cout&lt;&lt;A::get()&lt;&lt;&quot; &quot;&lt;&lt;B::get()&lt;&lt;&quot; &quot;&lt;&lt;C::get()&lt;&lt;std::endl;
    }
};
int main()
{
    C c(1,2,3);
    c.Show();
    return 0;
}
</code></pre><p>输出结果为： 3 2 1<br>调用C的构造函数，则B,A构造函数都将使用传入的参数进行初始化。</p>
<p>我们再看使用虚基类的情况：</p>
<pre><code>class A
{
private:
    int a;
public:
    A(int n=0):a(n){}
    int get(){return a;}
};
class B:virtual public A
{
private:
    int b;
public:
    B(int m=0,int n=0):A(n),b(m){}
    int get(){return b;}
};
class C:public B
{
private:
    int c;
public:
    C(int q=0,int m=0,int n=0):B(m,n),c(q){}
    int get(){return c;}
    void Show()
    {
        std::cout&lt;&lt;A::get()&lt;&lt;&quot; &quot;&lt;&lt;B::get()&lt;&lt;&quot; &quot;&lt;&lt;C::get()&lt;&lt;std::endl;
    }
};
int main()
{
    C c(1,2,3);
    c.Show();
    return 0;
}
</code></pre><p>输出结果为： 0 2 1<br>说明A并没有使用传入的参数进行初始化，<br>这是因为在虚基类中，我们假想会有多个子类向虚基类传递参数，为了避免这种情况，<br>在虚基类的情况下，禁止了子类C使用中间类B向虚基类A传递参数，此时调用的是A的默认构造函数。<br>那么我们该如何使用参数，初始化虚基类呢？<br>答案是我们可以在子类C中，直接调用虚基类A的构造函数进行初始化，如以下代码所示：</p>
<pre><code>class A
{
private:
    int a;
public:
    A(int n=0):a(n){}
    int get(){return a;}
};
class B:virtual public A
{
private:
    int b;
public:
    B(int m=0,int n=0):A(n),b(m){}
    int get(){return b;}
};
class C:public B
{
private:
    int c;
public:
    C(int q=0,int m=0,int n=0):A(m),B(m,n),c(q){}
    int get(){return c;}
    void Show()
    {
        std::cout&lt;&lt;A::get()&lt;&lt;&quot; &quot;&lt;&lt;B::get()&lt;&lt;&quot; &quot;&lt;&lt;C::get()&lt;&lt;std::endl;
    }
};
int main()
{
    C c(1,2,3);
    c.Show();
    return 0;
}
</code></pre><p>输出结果为： 3 2 1</p>
<p>跳过中间类，直接调用基类的构造函数，这种方式只适合虚基类。<br>在非虚基类中会报错”不允许使用间接非虚拟基类”。</p>
<p>参考资料：《C++ Primer.Plus》 pp.551-567</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++抽象类]]></title>
      <url>https://shijingjing07.github.io/2016/06/05/C++%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p><strong>1.为什么要有抽象类</strong></p>
<p>我们举一个例子，程序有两个类，椭圆Ellipse类，圆Circle类。<br>我们知道椭圆是包括圆的，那么我们可以使用继承：</p>
<pre><code>class Ellipse
{};
class Circle:public Ellipse
{};
</code></pre><p>然而，我们在定义各自的成员变量和成员函数时，发现两个类的成员有很大的不同，<br>比如Ellipse类需要长短轴半径，中心坐标，方向角才能确定位置，另外还包括移动椭圆，返回椭圆面积，旋转椭圆的方法。<br>而Circle类只需要半径，中心坐标，就能确定位置，旋转方法对圆来说也是没有意义的。<br>可以看出，若简单使Circle继承Ellipse，将使简单的问题复杂化。</p>
<p><strong>2.什么是抽象类</strong></p>
<p>解决的方法是，我们可以抽象出Ellipse类，Circle类的公共部分</p>
<pre><code>class BaseEllipse
{
private:
    double x;
    double y;
public:
    BaseEllipse(double a,double b):x(a),y(b){}
    virtual ~BaseEllipse(){}
    void Move(int a,int b){x=a;y=b;}
    virtual double Area() const=0;//纯虚函数
};
</code></pre><p>当类声明中有纯虚函数，比如virtual double Area()=0;时，该类就是抽象类。<br>抽象类不能实例化，子类继承抽象类时，必须定义纯虚函数。</p>
<pre><code>class Ellipse:public BaseEllipse
{
public:
    virtual double Area() const
    {
        std::cout&lt;&lt;&quot;Ellipse::Area()&quot;&lt;&lt;std::endl;
    }
};
class Circle:publi BaseEllipse
{
public:    
    virtual double Area() const
    {
        std::cout&lt;&lt;&quot;Circle::Area()&quot;&lt;&lt;std::endl;
    }
};
</code></pre><p><strong>3.抽象类与普通基类</strong><br>由上面的讲解，可看出，抽象类与普通基类的区别是，<br>普通基类表现的是一种父子关系，比如人和学生的关系。<br>抽象类更像是一种接口规则的约定，<br>比如规定了一些公共的move()方式，对人来说，移动的方式是”走”，对鸟来说，是”飞”，对鱼来说，是”游”<br>该约定类不能实例化，所有继承自抽象类的子类都必须覆盖其纯虚函数，迫使派生类遵循接口规则。  </p>
<p> 参考资料：《C++ Primer.Plus》 pp.508-516</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++重载，重写，重定义]]></title>
      <url>https://shijingjing07.github.io/2016/06/04/C++%E9%87%8D%E8%BD%BD%EF%BC%8C%E9%87%8D%E5%86%99%EF%BC%8C%E9%87%8D%E5%AE%9A%E4%B9%89/</url>
      <content type="html"><![CDATA[<p><strong>1.重载：</strong><br>重载是在一个类中，函数名一样，参数类型或参数个数不同的一系列函数<br>需要注意的是，与返回类型无关。</p>
<pre><code>class Test
{
public:
    void show();
    void show(int a);
    void show(double a);
    void show(int a,int b);
    void show(int a,double b);
};
</code></pre><p><strong>2.重写</strong><br>我们比较熟悉的另一个词是”覆盖”<br>用在继承中，子类若没有重新定义父类的虚方法，则子类对象调用该方法时，使用的仍是父类的方法；<br>否则，子类覆盖了父类的虚方法，调用时使用的是重新定义的方法。</p>
<pre><code>class Test
{
public:
    virtual void show()
    {
        std::cout&lt;&lt;&quot;Test::show()&quot;&lt;&lt;std::endl;
    }
};
class SubTest:public Test
{
public:
    virtual void show()
    {
        std::cout&lt;&lt;&quot;SubTest::show()&quot;&lt;&lt;std::endl;
    }
};
int main()
{
    Test *p = new SubTest;
    p-&gt;show();
    return 0;
}
</code></pre><p>输出结果：<br>SubTest::show()  </p>
<p><strong>3.重定义</strong><br>我们比较熟悉的另一个词是”隐藏”<br>子类重新定义父类中有相同名称的非虚函数，则对象调用该非虚方法时，使用的对象本身定义的方法。</p>
<pre><code>class Test
{
public:
        void show()
    {
        std::cout&lt;&lt;&quot;Test::show()&quot;&lt;&lt;std::endl;
    }
};
class SubTest:public Test
{
public:
    void show()
    {
        std::cout&lt;&lt;&quot;SubTest::show()&quot;&lt;&lt;std::endl;
    }
};
int main()
{
    Test *p = new SubTest;
    p-&gt;show();
    return 0;
}
</code></pre><p>输出结果：<br>Test::show()  </p>
<p>关于重写与重定义，如果了解了虚函数表的原理，就很容易理解了，<br>关于虚函数表，可参考<a href="http://www.cnblogs.com/shijingjing07/p/5559989.html" target="_blank" rel="external">C++虚函数表与虚析构函数</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++虚函数表与虚析构函数]]></title>
      <url>https://shijingjing07.github.io/2016/06/04/C++%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E4%B8%8E%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p><strong>1.静态联编和动态联编</strong><br>联编：将源代码中的函数调用解释为要执行函数代码。  </p>
<p>静态联编：编译时能确定唯一函数。<br>在C中，每个函数名都能确定唯一的函数代码。<br>在C++中，因为有函数重载，编译器须根据函数名，参数才能确定唯一的函数代码。  </p>
<p>动态联编：编译时不能确定调用的函数代码，运行时才能。<br>C++中因为多态的存在，有时编译器不知道用户将选择哪种类型的对象，因此无法确定调用的唯一性，只有在运行时才能确定。</p>
<p><strong>2.虚成员函数，指针或引用，动态联编</strong><br>指针或引用才能展现类的多态性。<br>当类中的方法声明为virtual时，使用指针或引用调用该方法，就是动态联编。<br>若是普通方法，则为静态联编。<br>示例如下：</p>
<pre><code>class Test
{
public:
    virtual show()
    {
        std::cout&lt;&lt;&quot;Test::show()&quot;&lt;&lt;std::endl;
    }
};
class SubTest:public Test
{
public:
    virtual show()
    {
        std::cout&lt;&lt;&quot;SubTest::show()&quot;&lt;&lt;std::endl;
    }
};
int main()
{
    SubTest subTest;
    Test * p = &amp;subTest;//指向子类的指针
    Test &amp; a = subTest;//子类的引用
    Test * p2 = new Test;//指向父类的指针
    p-&gt;show();
    a.show();
    p2-&gt;show();
    return 0;
}
</code></pre><p>程序没有释放内存，我们将在后面析构函数的时候，完善该程序。</p>
<p><strong>3.动态联编使用原则</strong><br>动态联编，需要跟踪基类指针或引用指向的实际对象类型，因此效率低于静态联编。<br>1)当类不会用作基类时，成员函数不要声明为virtual<br>2)当成员函数不重新定义基类的方法，成员函数不要声明为virtual</p>
<p><strong>4.关于虚函数</strong><br>1)父类成员函数若声明为virtual，则子类中也是虚的，若要重新定义该方法，可显式加上virtual关键字，也可不加，编译器编译时会自动加上。<br>2)使用指向对象的引用或指针来调用虚方法，将使用具体对象类型定义的方法，而不一定是引用或指针类型定义的方法。<br>SubTest subTest;<br>Test * p = &amp;subTest;//指向子类的指针<br>p-&gt;show();//将调用SubTest对象定义的show()方法</p>
<p><strong>5.虚函数的工作原理</strong><br>当类中存在虚函数时，编译器默认会给对象添加一个隐藏成员。该成员为一个指向虚函数表(virtual function table,vtbl)的指针。<br>虚函数表是一个保存了虚函数地址的数组。编译器会检查类中所有的虚函数，依次将每个虚函数的地址，存入虚函数表。</p>
<pre><code>class Test
{
public:
    virtual show()
    {
        std::cout&lt;&lt;&quot;Test::show()&quot;&lt;&lt;std::endl;
    }
private:
    int a;
};
class SubTest:public Test
{
public:
    virtual show()
    {
        std::cout&lt;&lt;&quot;SubTest::show()&quot;&lt;&lt;std::endl;
    }
};
</code></pre><p>内存结构图如下所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201606/300946-20160605012038071-1297873383.png" alt=""></p>
<p>可以看出，父类和子类有独立的虚函数表，且虚函数表中虚函数指针也指向各自的虚函数地址，<br>若子类没有覆盖父类中的show方法，则虚函数指针show_ptr指向的虚函数show()的地址是一样的，均指向父类show()函数地址。虚函数表的存在和动态联编，就是多态的原理。</p>
<p><strong>6.虚析构函数</strong><br>1)构造函数是特殊的，是没有虚函数的概念的。<br>构造函数是不继承的，创建子类对象时，将调用子类的构造函数，子类的构造函数将自动调用父类的构造函数。  </p>
<p>2)析构函数应是虚函数，除非类不用做基类。<br>我们看下面的代码：<br>Test *p = new SubTest;<br>delete p;<br>p=NULL;</p>
<p>由虚函数表，我们知道，若析构函数不声明为virtual，则调用的将是Test类的析构函数，而没有调用SubTest类的析构函数，此时造成了内存泄露。<br>所以析构函数必须声明为虚函数，调用的将是子类SubTest的析构函数，<br>我们还需要知道的一点是，子类析构函数，一定会调用父类析构函数，释放父类对象，则内存安全释放。<br>我们第一个例子的完整的示例代码如下：</p>
<pre><code>class Test
{
public:
    virtual show()
    {
        std::cout&lt;&lt;&quot;Test::show()&quot;&lt;&lt;std::endl;
    }
    virtual ~Test(){}
};
class SubTest:public Test
{
public:
    virtual show()
    {
        std::cout&lt;&lt;&quot;SubTest::show()&quot;&lt;&lt;std::endl;
    }
};
int main()
{
    SubTest subTest;
    Test * p = &amp;subTest;//指向子类的指针
    Test &amp; a = subTest;//子类的引用
    Test * p2 = new Test;//指向父类的指针
    p-&gt;show();
    a.show();
    p2-&gt;show();
    delete p;
    p=NULL;
    delete p2;
    p2=NULL;
    return 0;
}
</code></pre><p>参考资料：《C++ Primer.Plus》 pp.490-507<br>                  <a href="http://www.cnblogs.com/%20http:/www.imooc.com/video/9199" target="_blank" rel="external"> http://www.imooc.com/video/9199</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++ 初始化列表]]></title>
      <url>https://shijingjing07.github.io/2016/06/01/C++%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p><strong>1.初始化列表的写法</strong></p>
<p>初始化列表，写在类的构造函数后面，以冒号开头，后跟一系列用逗号分隔的初始化字段。如下列所示：  </p>
<pre><code>class Person
{
public:
    Person(std::string s, int i):name(s), age(i)
    {
    std::cout&lt;&lt;&quot;Person(std::string s, int i)&quot;&lt;&lt;std::endl;
    } ;
private:
    std::string name ;
    int age;   
};
</code></pre><p>其中的:name(s), age(i){} 即为初始化列表，创建对象时，有两个步骤：<br>成员变量初始化阶段：会将对象中的变量进行初始化，就是初始化列表，示例中我们自定义了部分变量初始化的方式。<br>构造函数执行阶段：执行构造函数中的代码。</p>
<p>下面的示例说明了以上的两个步骤，我们给Person类增加一个Pet字段，</p>
<p>这样在创建Person对象时，会先初始化成员变量，执行Pet的构造函数，再执行Person的构造函数：</p>
<pre><code>class Pet
{
public:
Pet()
{
    std::cout&lt;&lt;&quot;Pet()&quot;&lt;&lt;std::endl;
}
private:
    std::string  category;
};
class Person
{
public:
    Person(std::string s, int i):name(s), age(i)
    {
    std::cout&lt;&lt;&quot;Person(std::string s, int i)&quot;&lt;&lt;std::endl;
    } ;
private:
    std::string name ;
    int age;
    Pet pet;   
};
int main()
{
    Person(&quot;Jack&quot;,20);
    return 0;
}
</code></pre><p>输出结果：<br>Pet()<br>Person(std::string s, int i)</p>
<p><strong>2.使用初始化列表的好处</strong><br>在上例中，每次初始化Person对象时都会调用Pet的构造函数，如果使用初始化列表，则在成员变量初始化步骤时，可以用一个已经存在的Pet对象，直接赋给Person的Pet字段，省略了调用Pet构造函数的过程，提高了效率。</p>
<p>代码示例如下：</p>
<pre><code>class Pet
{
public:
Pet()
{
    std::cout&lt;&lt;&quot;Pet()&quot;&lt;&lt;std::endl;
}
private:
    std::string  category;
};
class Person
{
public:
    Person(std::string s,int i,Pet p):name(s), age(i),pet(p)
    {
    std::cout&lt;&lt;&quot;Person(std::string s, int i)&quot;&lt;&lt;std::endl;
    } ;
private:
    std::string name ;
    int age;
    Pet pet;   
};
int main()
{
    Pet pet;
    Person(&quot;Jack&quot;,20,pet);
    return 0;
}
</code></pre><p><strong>3.必须使用初始化列表的几种情况</strong><br>1)常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</p>
<pre><code>class Test
{
public:
    Test(int i):a(i){};
private:
    const int a;
}
</code></pre><p>2)引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</p>
<pre><code>class Test
{
public:
    Test(int i):a(i){};
private:
    int&amp; a;
}
</code></pre><p>3)没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。</p>
<pre><code>class Test
{
public:
    Test(int i):a(i){};
private:
    int a;
}
</code></pre><p>4)类继承中，基类私有字段的初始化有时必须通过在初始化列表中调用基类的构造函数</p>
<pre><code>#include&lt;iostream&gt;
class Test
{
public:
        Test(int i):a(i){};
        void Show()
        {
                std::cout&lt;&lt;a&lt;&lt;std::endl;
        }
private:
        int a;
};
class SubTest:public Test
{
public:
        SubTest(int i):Test(i){}
};
int main()
{
        SubTest subtest(5);
        subtest.Show();
        return 0;
}
</code></pre><p><strong>4.成员变量的初始化顺序</strong><br>成员是按照他们在类中出现的顺序进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的，看代码。</p>
<pre><code>class Test
{
public:
    Test(int x):j(x), i(j){} 
private:
    int i ;
    int j ;
};
</code></pre><p>代码会报错，因为类中i限于j定义，所以用j初始化i时，会报错j还没有初始化。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++类的构造函数详解]]></title>
      <url>https://shijingjing07.github.io/2016/05/31/C++%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><strong>1.默认构造函数</strong><br>1) 当没有定义任何构造函数时，编译器会提供默认构造函数，可以直接使用。<br>2) 如果定义了带参数的构造函数，又需要使用默认构造函数，此时，必须显式定义无参构造函数，这和C#中有很大的不同。例如有一个蔬菜类Veg：<br>Veg(const char* name,int num,double price);//声明了带三个参数的构造函数<br>要初始化Veg对象，可使用<br>Veg veg(“tomato”,15,3.5);</p>
<p>3) 定义了带参数的构造函数的同时，又需要使用Veg veg;若带参数的构造函数，参数全部用默认值，如：</p>
<p>Veg(const char* name=”NONE”,int num=0,double price=0.0);<br>则可成功初始化对象，否则将报错，<br>若要使用默认构造函数，必须显式声明<br>Veg veg();//声明了默认构造函数</p>
<p><strong>2.创建并初始化对象的几种方式</strong><br>1)Veg veg(“tomato”,15,3.5);<br>在栈中，创建一个名为veg的Veg对象，并调用构造函数初始化<br>2)Veg veg=Veg(“tomato”,15,3.5);<br>和方法一原理一样<br>3)Veg veg;<br>无参构造函数或参数全部有默认值的构造函数的初始化</p>
<p>以上三种方式创建的对象，是放在栈中的，当作用域结束时，析构函数将被隐式调用，对象将被释放。</p>
<p>4)Veg *p = new veg(“tomato”,15,3.5);<br>在堆中，创建一个Veg对象，并调用构造函数初始化，并返回指向该对象的指针p<br>关于new的详细介绍，可参考 <a href="http://www.cnblogs.com/shijingjing07/p/5519153.html" target="_blank" rel="external">C++<br>new操作符详解</a></p>
<p>堆中创建的对象，在不需要使用时，要使用delete关键字，删除指针，此时析构函数会立即被隐式调用，指针指向的对象将被释放，<br>否则的话，将造成内存泄漏。</p>
<p><strong>3.对象赋值</strong><br>Veg veg1=Veg(“tomato”,15,3.5);<br>Veg veg2 = veg2;<br>属于值传递，对象中每个数据成员的值都将复制到目标对象相应的数据成员。</p>
<p><strong>4.关于只带一个参数的构造函数</strong></p>
<p>只有一个惨的构造函数初始化时，可以将对象初始化为该参数，语法如下：<br>Classname object= value;</p>
<p>编程时，我们使用了很多此种初始化方式，简洁明了，如：<br>int a(10)=&gt;int a = 10;<br>string a(“hello”)=&gt;string a= “hello”;</p>
<p>然而，很多时候，此种初始化方式，是不对的。如：<br>针对构造函数Veg(const char<em> name);我们可以直接初始化为：<br>Veg veg = name;<br>显然，Veg对象并不是一个char</em>类型的字符串，那么如何避免误用此种初始化方式呢？<br>可在构造函数声明时，加上explicit关键字，如：explicit Veg(const char* name);<br>explicit关键字的详细介绍，可参考 <a href="http://www.cnblogs.com/shijingjing07/p/5525800.html" target="_blank" rel="external">C++ explicit关键字
</a></p>
<p>5.构造函数使用示例</p>
<p>如下例所示，定义了一个蔬菜类Veg，main函数中演示了几种构造函数初始化方式。</p>
<p>Veg.h</p>
<pre><code>#pragma once
#include&lt;iostream&gt;
#include&lt;string&gt;
class Veg
{
private:
    std::string name;
    int num;
    double price;
    double total;
    void set_tot(){total = num*price;}
public:
    Veg();
    Veg(const std::string &amp;name);
    Veg(const std::string &amp;name,int num=0,double price = 0.0);
    ~Veg();
    void show();
};
</code></pre><p>Veg.cpp</p>
<pre><code>#include &quot;Veg.h&quot;
Veg::Veg()
{
    name=&quot;NONE&quot;;
    num = 0;
    price = 0.0;
    total = 0.0;
}
Veg::Veg(const std::string &amp;name)
{
    this-&gt;name=name;
}
Veg::Veg(const std::string &amp;name,int num,double price)
{
    this-&gt;name = name;
    this-&gt;num = num;
    this-&gt;price  = price;
    set_tot();
}
Veg::~Veg()
{
    std::cout&lt;&lt;&quot;~Veg()&quot;&lt;&lt;std::endl;
}
void Veg::show()
{
    std::cout&lt;&lt;&quot;name:&quot;&lt;&lt;name&lt;&lt;&quot; num:&quot;&lt;&lt;num&lt;&lt;&quot; price:&quot;&lt;&lt;price&lt;&lt;&quot; total:&quot;&lt;&lt;total&lt;&lt;std::endl;
}
</code></pre><p>useveg.cpp</p>
<pre><code>#include &quot;Veg.h&quot;
int main()
{
    Veg veg1;
    Veg veg2(&quot;tomato&quot;,15,3.5);
    Veg veg3=Veg(&quot;potato&quot;,8,2.0);
    Veg *p=new Veg(&quot;tomato&quot;,15,3.5);
    veg1.show();
    veg2.show();
    veg3.show();
    veg2 = veg3;
    veg2.show();
    veg3.show();
    delete p;
    p=NULL;
    return 0;
}
</code></pre><p>运行结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201605/300946-20160531152939571-1620287468.png" alt=""></p>
<p>参考资料：《C++ Primer.Plus》 pp.352-363</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++异常详解]]></title>
      <url>https://shijingjing07.github.io/2016/05/30/C++%E5%BC%82%E5%B8%B8%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><strong>1.对异常的几种处理方式</strong><br>1)调用abort()<br>abort()函数的原型位于头文件cstlib中，其实现是向标准错误流发送abnormal program<br>termination（程序异常终止），然后终止程序。<br>示例如下:</p>
<pre><code>#inclide&lt;iostream&gt;
#inclide&lt;cstlib&gt;
double hmean(double x,double y)
{
    if(x==-y)
    {
        std::cout&lt;&lt;&quot;arguments are not valid\n&quot;;
        std::abort();
    }
    return 2*x*y/(x+y);
}
int main()
{
    double x,y,z;
    while(std::cin&gt;&gt;x&gt;&gt;y)
    {
        z=hmean(x,y);
        std::cout&lt;&lt;&quot;result is &quot;&lt;&lt;z&lt;&lt;std::endl;
        std::cout&lt;&lt;&quot;next loop &quot;&lt;&lt;std::endl;
    }
    return 0;
}
</code></pre><p>2)返回错误码<br>使用一个bool值来标记，运行结果是成功，还是失败。<br>示例如下：</p>
<pre><code>#inclide&lt;iostream&gt;
bool hmean(double x,double y,double &amp;z)
{
    if(x==-y)
    {
        return false;
    }
    z= 2*x*y/(x+y);
    return true;
}
int main()
{
    double x,y,z;
    while(std::cin&gt;&gt;x&gt;&gt;y)
    {
        if(hmean(x,y,z))
        {
            std::cout&lt;&lt;&quot;result is false!&quot;&lt;&lt;std::endl;
        }
        else{
            std::cout&lt;&lt;&quot;result is true!&quot;&lt;&lt;std::endl;
            std::cout&lt;&lt;&quot;result is &quot;&lt;&lt;z&lt;&lt;std::endl;
        }
        std::cout&lt;&lt;&quot;next loop &quot;&lt;&lt;std::endl;
    }
    return 0;
}
</code></pre><p>3)使用全局变量errno<br>出现异常时可以将全局变量errno设值，需要注意的是，要确保没有其他的函数同时在使用这个全局变量</p>
<p><strong>2.异常机制</strong><br>涉及try,catch,throw关键字<br>示例代码如下：</p>
<pre><code>#inclide&lt;iostream&gt;
double hmean(double x,double y)
{
    if(x==-y)
    {
        throw &quot;arguments are not valid&quot;;
    }
    return 2*x*y/(x+y);
}
int main()
{
    double x,y,z;
    while(std::cin&gt;&gt;x&gt;&gt;y)
    {
        try
        {
            z = hmean(x,y);
        }
        catch(const char* s)
        {
            std::cout&lt;&lt;s&lt;&lt;std::endl;
            std::cout&lt;&lt;&quot;next loop &quot;&lt;&lt;std::endl;
            continue;
        }
        std::cout&lt;&lt;&quot;result is &quot;&lt;&lt;z&lt;&lt;std::endl;
        std::cout&lt;&lt;&quot;next loop &quot;&lt;&lt;std::endl;
    }
    return 0;
}
</code></pre><p><strong>3.上面的示例中，我们抛出的是字符串，通常情况，我们会为每个可能出现的异常，定义一个异常类，当出现异常时，抛出该异常对象，catch块对该异常对象进行捕获。</strong><br>示例代码如下：</p>
<pre><code>#inclide&lt;iostream&gt;
class bad_hmean
{
private:
    double x;
    double y;
public:
    bad_hmean(int a=0,int b=0):x(a),y(b){}
    void mesg();
};
inline void bad_hmean::mesg()
{
    std::cout&lt;&lt;&quot;arguments are not valid &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;std::endl;
}
double hmean(double x,double y)
{
    if(x==-y)
    {
        throw bad_mean(x,y);
    }
    return 2*x*y/(x+y);
}
int main()
{
    double x,y,z;
    while(std::cin&gt;&gt;x&gt;&gt;y)
    {
        try
        {
            z = hmean(x,y);
        }
        catch(bad_hmean &amp;hg)
        {
            hg.mesg();
            std::cout&lt;&lt;&quot;next loop &quot;&lt;&lt;std::endl;
            continue;
        }
        std::cout&lt;&lt;&quot;result is &quot;&lt;&lt;z&lt;&lt;std::endl;
        std::cout&lt;&lt;&quot;next loop &quot;&lt;&lt;std::endl;
    }
    return 0;
}
</code></pre><p><strong>4.异常规范</strong><br>我们看下面的两行代码<br>double hmean(int x,int y) throw(bad_thing)//可能抛出bad_thing异常<br>double hmean(int x,int y) throw()//不抛出异常<br>其中后面的throw()部分就是异常规范，指出该函数可能抛出的异常。<br>程序员来确定可能抛出的异常，这样并不好。<br>在C++11中，已经摒弃了该规范。</p>
<p><strong>5.栈解退</strong></p>
<p>栈解退是很重要的概念。为什么这么说呢，当抛出异常后，程序终止，或被catch块捕捉，我们必须要考虑内存的释放问题。</p>
<p>我们先看一下，正常函数是如何处理内存释放的。<br>函数调用时，调用函数的指令的地址会放到栈中，函数的参数或局部变量也将被添加到栈中或堆中。<br>如果在其中又调用了函数，则执行同样的操作。<br>当函数结束以后，程序会跳到被调用时存储的地址处，栈顶的元素被释放，同时释放其自动变量。<br>如果自动变量时类对象，则类的析构函数将被调用。</p>
<p>当函数出现异常时，程序也将不断释放栈，直到找到一个与该异常相对应的try块的返回地址。<br>随后，控制权将转到块尾的catch处理程序，而不是函数调用后面的第一条语句，这个过程称为栈解退。<br>和正常函数调用不同的是，函数返回将处理该函数放在栈中的对象，而函数异常则处理，try块和throw之间放在栈中的对象。<br>有了栈解退机制，引发异常后，也会释放调用中间函数时栈中的对象。</p>
<p>我们看看下面的两个例子：</p>
<pre><code>void test1()
{
    string mesg(&quot;hello&quot;);
    if(false)
        throw exception();
    return;
}

void test2()
{
    double *ar = new double[n];
    if(false)
        throw exception();
    delete [] ar;
    return;
}
</code></pre><p>对于test1,函数异常后，会进行栈解退，string类析构函数会被调用，占用的内存将释放。<br>对于test2,栈解退时，将删除栈中变量ar，但ar指向的内存块未释放，并且不可访问，会造成内存泄漏的问题。此时要如何处理呢？<br>可以在引发异常的代码块中，捕获该异常，释放该内存块，然后重新引发异常。此时，内存块就被释放了。</p>
<pre><code>void test2()
{
    double *ar = new double[n];
    try
    {
        if(false)
            throw exception();
    }
    catch(exception &amp;ex)
    {
        delete[] ar;
        throw;
    }
    delete [] ar;
    return;
}
</code></pre><p><strong>6.关于catch块</strong></p>
<pre><code>try
{}
catch(exception &amp;ex)
{}
</code></pre><p>注意catch块中参数为引用类型。当throw异常向上抛出时，该异常对象会被释放，此时catch块接收的异常对象为原始异常对象的一个副本。<br>使用引用的目的是，基类引用可以执行派生类对象。若不使用引用，则只能调用基类的特性。</p>
<p><strong>7.C++标准异常库</strong><br>标准异常类exception在头文件exception中定义，类含有一个名为what()的虚拟成员函数。从exception派生的类可以重新定义它。<br>C++库定义了很多基于exception的异常类型，此处不再详细介绍。</p>
<p>参考资料：《C++ Primer.Plus》 pp.616-642</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++程序文件链接]]></title>
      <url>https://shijingjing07.github.io/2016/05/27/C++%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5/</url>
      <content type="html"><![CDATA[<p><strong>1.什么是转换单元</strong><br>程序中的每个.cpp文件和它包含的所有头文件称为一个转换单元。<br>编译器处理每个转换单元，生成二进制对象文件，用扩展名.obj来标识。<br>链接器将对象文件组合起来，生成一个可执行文件，用扩展名.exe来标识。</p>
<p><strong>2.作用域</strong><br>使用{}来限定变量的作用域</p>
<p>内部作用域可以定义一个和外部作用域相同的名称，此时，内部作用域中定义的名称，将隐藏外部作用域中的名称，</p>
<p>若要访问外层作用域中的名称，可使用解析运算符::，解析运算符的介绍，可参考 <a href="http://www.cnblogs.com/shijingjing07/p/5531419.html" target="_blank" rel="external">C++范围解析运算符::的使用
</a></p>
<pre><code>int main()
{
const int limit =10;
std::cout&lt;&lt;&quot;limit 1 is &quot;&lt;&lt;limit&lt;&lt;std::endl;
{
const int limit = 5;
std::cout&lt;&lt;&quot;limit 2 is &quot;&lt;&lt;limit&lt;&lt;std::endl;
std::cout&lt;&lt;&quot;limit 3 is &quot;&lt;&lt;::limit&lt;&lt;std::endl;
}
std::cout&lt;&lt;&quot;limit 4 is &quot;&lt;&lt;limit&lt;std::endl;
}
</code></pre><p>输出结果：<br>limit 1 is 10<br>limit 2 is 5<br>limit 3 is 10<br>limit 4 is 10</p>
<p><strong>3.转换单元的全局名称属性linkage</strong><br>每个转换单元中的全局名称，都有一个属性linkage，该属性指明该全局名称可以在程序代码的什么地方使用。<br>内部链接属性：该名称只能在同一转换单元的任何地方访问。比如全局const变量。<br>外部链接属性：该名称除了在同一转换单元访问外，还可在其他的转换单元中访问。除了全局const变量，其他的全局名称都是外部链接属性的。</p>
<p>局部名称没有链接属性。</p>
<p><strong>4.什么是”一个定义”规则</strong><br>在所有的转换单元中，外部链接属性的全局名称，如变量、函数、类类型、枚举类型、模板都只能定义一次。<br>内联函数除外，内联函数的定义必须出现在调用该函数的每个转换单元中。</p>
<p>内部链接属性的名称可以在多个转换单元中同时定义。</p>
<p><strong>5.如何访问另一转换单元中定义的变量</strong><br>对于函数来说，如果函数的调用和定义不在同一个转换单元，编译器会把这个函数调用标记为外部的，让链接程序去处理它。</p>
<p>对于变量来说，是不同的。必须使用extern关键字来声明该变量。表示该变量的定义在另一个转换单元中。</p>
<p>示例代码如下：</p>
<pre><code>myextern.cpp
int limit = 15;

mymain.cpp
int main()
{
    extern int limit;
    std::cout&lt;&lt;&quot;Extern limit is &quot;&lt;&lt;limit&lt;&lt;std::endl;
    return 0;
}
</code></pre><p>由链接属性linkage的介绍，我们知道const变量是内部链接属性的，只能在转换单元内部访问。</p>
<p>而定义一个const变量，希望其他的转换单元都可以使用的情况是常见的，如圆周率PI，const double pi=3.14159265，</p>
<p>那么，怎么才能让const变量也具有外部链接属性呢。<br>我们只需要在定义const变量时，也加上extern关键字就可以了。</p>
<p>示例代码如下：</p>
<pre><code>myextern.cpp
extern const double pi=3.14159265；

mymain.cpp
int main()
{
    extern const double pi;
    std::cout&lt;&lt;&quot;Extern pi is &quot;&lt;&lt;pi&lt;&lt;std::endl;
    return 0;
}
</code></pre><p>另外需要说明的是，extern变量声明的位置，决定了该外部变量的作用域。</p>
<p>参考资料：《C++入门经典 第三版》 pp.309-318</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C程序的内存布局]]></title>
      <url>https://shijingjing07.github.io/2016/05/26/C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<p><strong> 1.代码段(code或text)：</strong></p>
<p>通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读。 某些架构也允许代码段为可写，即允许修改程序。<br>在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等，但一般都是放在只读数据段中。</p>
<p><strong>2.数据段(data segment)：</strong><br>通常是指用来存放程序中已初始化的全局变量和静态变量的一块内存区域。<br>数据段属于静态内存分配，可以分为只读数据段和读写数据段。<br>字符串常量等，但一般都是放在只读数据段中。</p>
<p><strong>3.BSS段(bss)：</strong><br>通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。<br>BSS节不包含任何数据，只是简单的维护开始和结束的地址，即总大小，以便内存区能在运行时分配并被有效地清零。<br>BSS节在应用程序的二进制映象文件中并不存在，即不占用磁盘空间而只在运行的时候占用内存空间，<br>所以如果全局变量和静态变量未初始化那么其可执行文件要小很多。BSS段属于静态内存分配。<br>这里注意一个问题：一般的书上都会说全局变量和静态变量是会自动初始化的，那么哪来的未初始化的变量呢？<br>变量的初始化可以分为显示初始化和隐式初始化，全局变量和静态变量如果程序员自己不初始化的话的确也会被初始化，<br>那就是不管什么类型都初始化为0，这种没有显示初始化的就是我们这里所说的未初始化。<br>既然都是0那么就没必要把每个0都存储起来，从而节省磁盘空间，这是BSS的主要作用。</p>
<p><strong>4.堆（heap）：</strong><br>堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。<br>当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；<br>当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</p>
<p><strong>5.栈(stack)：</strong><br>栈又称堆栈，<br>是用户存放程序临时创建的局部变量，也就是说我们函数括弧”{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。<br>除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。<br>由于栈的后进先出特点，所以栈特别方便用来保存/恢复调用现场。<br>从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p>
<p>简单示例如下：</p>
<pre><code>const char ro[ ] = {&quot;this is read onlydata&quot;};                  //只读数据区   
static char rw_1[ ] ={&quot;this is globalread write data&quot;};        //已初始化读写数据段   
char BSS_1[ 100];                                              //未初始化数据段   
const char *ptrconst =&quot;constantdata&quot;;                          //字符串放在只读取数据段   
int main()   
{   
      short b;                                                 //在栈上，占用2个字节   
      char a[100];                                             //在栈上开辟100个字节，工的值是其首地址   
      char s[ ]=&quot;abcdefg&quot;;                                     //s在栈上，占用4个字节   
                                                               //&quot;abcdefg&quot;本身放置在只读数据存储区，占8个字节   
      char *p1;                                                //p1在栈上，占用4个字节                 
      char *p2=&quot;123456&quot;;                                       //p2 在栈上，p2指向的内容不能改，   
                                                               //&quot;123456&quot;在只读数据区        

      static char rw_2[ ]={&quot;this is local read write data&quot;};   //局部已初始化读写数据段   
      static char BSS_2[100];                                  //局部未初始化数据段   
      static int c = 0;                                        //全局（静态）初始化区   
       p1=(char *)malloc(10 * sizeof(char ) );                 //分配内存区域在堆区   
       strcpy(p1,&quot;xxxx&quot;);                                      //&quot;XXXX&quot;放在只读数据区，占5个字节   
      free(p1);                                                //使用free释放p1所指向的内存   

  return 0;   
}  
</code></pre><p> 我们再看一下以下的代码：</p>
<pre><code>#include &lt;stdio.h&gt;
const int a = 10; ////全部常量a
int main()
{
    const int b = 20; //局部常量b
    int* pa = (int*)&amp;a;//报错，因为全部常量放在只读数据段
    int* pb = (int*)&amp;b;//修改成功，因为局部常量放在栈上
    *pa = 30;
    *pb = 30;
    return 0;
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ARM中LDR伪指令与LDR加载指令]]></title>
      <url>https://shijingjing07.github.io/2016/05/26/ARM%E4%B8%ADLDR%E4%BC%AA%E6%8C%87%E4%BB%A4%E4%B8%8ELDR%E5%8A%A0%E8%BD%BD%E6%8C%87%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>ARM指令集中，LDR通常都是作加载指令的，但是它也可以作伪指令。</p>
<p>LDR伪指令的形式是”LDR Rn,=expr”。下面举一个例子来说明它的用法。</p>
<p>COUNT EQU       0x40003100</p>
<p>……</p>
<p>LDR       R1,=COUNT</p>
<p>MOV      R0,#0</p>
<p>STR       R0,[R1]</p>
<p>COUNT是我们定义的一个变量，地址为0x40003100。这中定义方法在汇编语言中是很常见的，如果使用过单片机的话，应该都熟悉这种用法。</p>
<p>LDR       R1,=COUNT是将COUNT这个变量的地址，也就是0x40003100放到R1中。</p>
<p>MOV      R0,#0是将立即数0放到R0中。最后一句STR<br>R0,[R1]是一个典型的存储指令，将R0中的值放到以R1中的值为地址的存储单元去。实际就是将0放到地址为0x40003100的存储单元中去。可<br>见这三条指令是为了完成对变量COUNT赋值。用三条指令来完成对一个变量的赋值，看起来有点不太舒服。这可能跟ARM的采用RISC有关。</p>
<p>下面还有一个例子</p>
<p>；将COUNT的值赋给R0</p>
<p>LDR       R1,=COUNT</p>
<p>LDR       R0,[R1]</p>
<p>LDR<br>R1,=COUNT这条伪指令，是怎样完成将COUNT的地址赋给R1，有兴趣的可以看它编译后的结果。这条指令实际上会编译成一条LDR指令和一条DCD伪指令。</p>
<p>LDR 的两种用法</p>
<p>1）LDR pc, =MyHandleIRQ 表示将MyHandleIRQ符号放入pc寄存器中</p>
<p>2）LDR PC，MyHandleIRQ 表示将读取存储器中MyHandleIRQ符号所表示的地址中的值，及需要多读一次存储器。</p>
<p>在代码中：</p>
<p>start:<br>        ldr pc,=MyHandleReset   @jump to HandleReset<br>        ldr pc,=MyHandleUndef   @jump to HandleUndef<br>        ldr pc,=MyHandleSWI     @jump to HandleSWI<br>        ldr pc,=MyHandleIabort  @jump to HandleIabort<br>        ldr pc,=MyHandleDabort  @jump to HandleDabort<br>        nop<br>        ldr pc,=MyHandleIRQ     @jump to HandleIRQ             &lt;=之前出错的一行<br>        ldr pc,=MyHandleFIQ     @jump to HandleFIQ</p>
<p>@MyHandleIRQ:   .word OS_CPU_IRQ_ISR<br>MyHandleIRQ:<br>        sub lr, lr, #4          @ to calculate the return address<br>        stmdb sp!, {r0-r12,lr}<br>        ldr lr, =int_return     @ restore the return address<br>        ldr pc, =int_handle     @ call for the interrupt handler</p>
<p>在”之前出错的一行”处，如果改成”ldr pc,MyHandleIRQ”当中断来临时，无法进行中断处理。</p>
<p>另一种情况是正确的，注意体会：</p>
<p>start:<br>        ldr pc,=MyHandleReset   @jump to HandleReset<br>        ldr pc,=MyHandleUndef   @jump to HandleUndef<br>        ldr pc,=MyHandleSWI     @jump to HandleSWI<br>        ldr pc,=MyHandleIabort  @jump to HandleIabort<br>        ldr pc,=MyHandleDabort  @jump to HandleDabort<br>        nop<br>        ldr pc,MyHandleIRQ     @jump to HandleIRQ             &lt;=之前出错的一行<br>        ldr pc,=MyHandleFIQ     @jump to HandleFIQ</p>
<p>MyHandleIRQ:   .word OS_CPU_IRQ_ISR<br>@MyHandleIRQ:<br>@        sub lr, lr, #4          @ to calculate the return address<br>@        stmdb sp!, {r0-r12,lr}<br>@        ldr lr, =int_return     @ restore the return address<br>@        ldr pc, =int_handle     @ call for the interrupt handler</p>
<p>因为当中断来临时，还需要去MyHandleIRQ处把OS_CPU_IRQ_ISR取出，即多取一次存储器。</p>
<h1 id="这篇文章针对用法1进行了详细的说明"><a href="#这篇文章针对用法1进行了详细的说明" class="headerlink" title="这篇文章针对用法1进行了详细的说明"></a>这篇文章针对用法1进行了详细的说明</h1><h1 id="说说ARM汇编的LDR伪指令"><a href="#说说ARM汇编的LDR伪指令" class="headerlink" title="说说ARM汇编的LDR伪指令"></a>说说ARM汇编的LDR伪指令</h1><p><strong><a href="http://my.chinaunix.net/link.php?url=http://blog.csdn.net%2Faxx1611%2Farchive%2F2008%2F04%2F27%2F2335410.aspx" target="_blank" rel="external">http://blog.csdn.net/axx1611/archive/2008/04/27/2335410.aspx</a></strong></p>
<p>转自：<a href="http://www.cnblogs.com/hnrainll/archive/2011/06/14/2080241.html" target="_blank" rel="external">http://www.cnblogs.com/hnrainll/archive/2011/06/14/2080241.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[每天一个linux命令(12)：more命令]]></title>
      <url>https://shijingjing07.github.io/2016/05/25/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4(12)%EF%BC%9Amore%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>more命令，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。<br>more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b<br>键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。</p>
<p><strong>1．命令格式：</strong></p>
<p>more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file … ]</p>
<p><strong>2．命令功能：</strong></p>
<p>more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能。</p>
<p><strong>3．命令参数：</strong></p>
<p>+n      从笫n行开始显示</p>
<p>-n       定义屏幕大小为n行</p>
<p>+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示  </p>
<p>-c       从顶部清屏，然后显示</p>
<p>-d       提示”Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能</p>
<p>-l        忽略Ctrl+l（换页）字符</p>
<p>-p       通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</p>
<p>-s       把连续的多个空行显示为一行</p>
<p>-u       把文件内容中的下画线去掉</p>
<p><strong>4．常用操作命令：</strong></p>
<p>Enter    向下n行，需要定义。默认为1行</p>
<p>Ctrl+F   向下滚动一屏</p>
<p>空格键  向下滚动一屏</p>
<p>Ctrl+B  返回上一屏</p>
<p>=       输出当前行的行号</p>
<p>：f     输出文件名和当前行的行号</p>
<p>V      调用vi编辑器</p>
<p>!命令   调用Shell，并执行命令</p>
<p>q       退出more</p>
<p><strong>5．命令实例：</strong></p>
<p>实例1：显示文件中从第3行起的内容</p>
<p>命令：</p>
<p>more +3 log2012.log</p>
<p>输出：</p>
<p>[root@localhost test]# cat log2012.log</p>
<p>2012-01</p>
<p>2012-02</p>
<p>2012-03</p>
<p>2012-04-day1</p>
<p>2012-04-day2</p>
<p>2012-04-day3</p>
<p>======[root@localhost test]# more +3 log2012.log</p>
<p>2012-03</p>
<p>2012-04-day1</p>
<p>2012-04-day2</p>
<p>2012-04-day3</p>
<p>======[root@localhost test]#</p>
<p>实例2：从文件中查找第一个出现”day3”字符串的行，并从该处前两行开始显示输出</p>
<p>命令：</p>
<p> more +/day3 log2012.log</p>
<p>输出：</p>
<p>[root@localhost test]# more +/day3 log2012.log</p>
<p>…skipping</p>
<p>2012-04-day1</p>
<p>2012-04-day2</p>
<p>2012-04-day3</p>
<p>2012-05</p>
<p>2012-05-day1</p>
<p>======[root@localhost test]#</p>
<p>实例3：设定每屏显示行数</p>
<p>命令：</p>
<p>more -5 log2012.log</p>
<p>输出：</p>
<p>[root@localhost test]# more -5 log2012.log</p>
<p>2012-01</p>
<p>2012-02</p>
<p>2012-03</p>
<p>2012-04-day1</p>
<p>2012-04-day2</p>
<p>说明：</p>
<p>当前屏展示的内容占文件总行数的比例，按 Ctrl+F 或者 空格键 将会显示下一屏5条内容，百分比也会跟着变化。</p>
<p>实例4：列一个目录下的文件，由于内容太多，我们应该学会用more来分页显示。这得和管道 | 结合起来</p>
<p>命令：</p>
<p>ls -l  | more -5</p>
<p>输出：</p>
<p>[root@localhost test]#  ls -l  | more -5</p>
<p>总计 36</p>
<p>-rw-r–r– 1 root root  308 11-01 16:49 log2012.log</p>
<p>-rw-r–r– 1 root root   33 10-28 16:54 log2013.log</p>
<p>-rw-r–r– 1 root root  127 10-28 16:51 log2014.log</p>
<p>lrwxrwxrwx 1 root root    7 10-28 15:18 log_link.log -&gt; log.log</p>
<p>-rw-r–r– 1 root root   25 10-28 17:02 log.log</p>
<p>-rw-r–r– 1 root root   37 10-28 17:07 log.txt</p>
<p>drwxr-xr-x 6 root root 4096 10-27 01:58 scf</p>
<p>drwxrwxrwx 2 root root 4096 10-28 14:47 test3</p>
<p>drwxrwxrwx 2 root root 4096 10-28 14:47 test4</p>
<p>说明：</p>
<p>每页显示5个文件信息，按 Ctrl+F 或者 空格键 将会显示下5条文件信息。</p>
<p>转自：<a href="http://www.cnblogs.com/peida/archive/2012/11/02/2750588.html" target="_blank" rel="external">http://www.cnblogs.com/peida/archive/2012/11/02/2750588.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++ explicit关键字]]></title>
      <url>https://shijingjing07.github.io/2016/05/25/C++%20explicit%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      <content type="html"><![CDATA[<p><strong>按照默认规定，只有一个参数的构造函数也定义了一个隐式转换，将该构造函数对应数据类型的数据转换为该类对象，如下面所示：</strong></p>
<p>class String {</p>
<p>String ( const char* p ); // 用C风格的字符串p作为初始化值</p>
<p>//…</p>
<p>}</p>
<p>String s1 = “hello”; //OK 隐式转换，等价于String s1 = String（”hello”）;</p>
<p><strong>但是有的时候可能会不需要这种隐式转换，如下：</strong></p>
<p>class String {</p>
<pre><code>String ( int n ); //本意是预先分配n个字节给字符串
</code></pre><p>String ( const char* p ); // 用C风格的字符串p作为初始化值</p>
<p>//…</p>
<p>}</p>
<p>下面两种写法比较正常：</p>
<p>String s2 ( 10 );   //OK 分配10个字节的空字符串</p>
<p>String s3 = String ( 10 ); //OK 分配10个字节的空字符串</p>
<p>下面两种写法就比较疑惑了：</p>
<p>String s4 = 10; //编译通过，也是分配10个字节的空字符串</p>
<p>String s5 = ‘a’; //编译通过，分配int（’a’）个字节的空字符串</p>
<p>s4 和s5 分别把一个int型和char型，隐式转换成了分配若干字节的空字符串，容易令人误解。</p>
<p>为了避免这种错误的发生，我们可以声明显示的转换，使用<strong>explicit</strong> 关键字：</p>
<p>class String {</p>
<pre><code>**explicit** String ( int n ); //本意是预先分配n个字节给字符串
</code></pre><p>String ( const char* p ); // 用C风格的字符串p作为初始化值</p>
<p>//…</p>
<p>}</p>
<p>加上<strong>explicit**</strong>，**就抑制了String ( int n )的隐式转换，</p>
<p>下面两种写法仍然正确：</p>
<p>String s2 ( 10 );   //OK 分配10个字节的空字符串</p>
<p>String s3 = String ( 10 ); //OK 分配10个字节的空字符串</p>
<p>下面两种写法就不允许了：</p>
<p>String s4 = 10; //编译不通过，不允许隐式的转换</p>
<p>String s5 = ‘a’; //编译不通过，不允许隐式的转换</p>
<p>因此，某些时候，<strong>explicit</strong> 可以有效得防止构造函数的隐式转换带来的错误或者误解  </p>
<p>-———————————————————<br>explicit   只对构造函数起作用，用来抑制隐式转换。如：<br>  class   A   {<br>          A(int   a);<br>  };<br>  int   Function(A   a);  </p>
<p>  当调用   Function(2)   的时候，2   会隐式转换为   A   类型。这种情况常常不是程序员想要的结果，所以，要避免之，就可以这样写：  </p>
<p>  class   A   {<br>          explicit   A(int   a);<br>  };<br>  int   Function(A   a);  </p>
<p>  这样，当调用   Function(2)   的时候，编译器会给出错误信息（除非   Function   有个以   int<br>为参数的重载形式），这就避免了在程序员毫不知情的情况下出现错误。  </p>
<p>总结：explicit   只对构造函数起作用，用来抑制隐式转换。  </p>
<p>参考：<br><a href="http://blog.csdn.net/smilelance/archive/2007/03/14/1528737.aspx" target="_blank" rel="external">http://blog.csdn.net/smilelance/archive/2007/03/14/1528737.aspx</a><br><a href="http://topic.csdn.net/t/20040509/15/3046021.html" target="_blank" rel="external">http://topic.csdn.net/t/20040509/15/3046021.html</a></p>
<p>转自：<a href="http://www.cnblogs.com/cutepig/archive/2009/01/14/1375917.html" target="_blank" rel="external">http://www.cnblogs.com/cutepig/archive/2009/01/14/1375917.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++内联函数详解]]></title>
      <url>https://shijingjing07.github.io/2016/05/24/C++%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><strong>1.函数调用原理</strong></p>
<p><em>“编译过程的最终产品是可执行程序–<br>由一组机器语言指令组成。运行程序时，操作系统将这些指令载入计算机内存中，因此每条指令都有特定的内存地址。计算机随后将逐步执行这些指令。有时（如有循环和分支语句时），将跳过一些指令，向前或向后跳到特定地址。常规函数调用也使程序跳到另一个地址（函数的地址），并在函数结束时返回。下面更详细地介绍这一过程的典型实现。执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈（为此保留的内存块），跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入寄存器中），然后跳回到地址被保存的指令处（这与阅读文章时停下来看脚注，并在阅读完脚注后返回到以前阅读的地方类似）。来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销。”</em></p>
<p><strong>2.内联函数</strong><br>内联函数提供了另一种选择。编译器将使用相应的函数代码替换函数调用。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。</p>
<p><strong>3.内联函数的使用</strong><br>在函数声明前加上关键字inline;<br>在函数定义前加上关键字inline。<br>示例如下：</p>
<pre><code>#include&lt;iostream&gt;
inline double square(double x){return x*x;}
int main()
{
    using namespace std;
    double a,b;
    double c = 13.0;
    a = square(5.0);
    b = square(4.5+7.5);
    cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;&quot;,b=&quot;&lt;&lt;b&lt;&lt;endl;
    cout&lt;&lt;&quot;c=&quot;&lt;&lt;c&lt;&lt;endl;
    cout&lt;&lt;&quot;c squared=&quot;&lt;&lt;square(c++)&lt;&lt;endl;
    cout&lt;&lt;&quot;now c=&quot;&lt;&lt;c&lt;&lt;endl;
    return 0;
}
</code></pre><p>程序输出结果如下：<br>a=25,b=144<br>c=13<br>c square=169<br>now c=14</p>
<p><strong>4.内联函数与宏定义的区别</strong><br>C语言使用预处理器语句#define来提供宏。如下例所示：  </p>
<p>#define SQUARE(X) X<em>X<br>宏定义时通过文本替换开实现的–X是参数的符号标记。<br>a = square(5.0);-&gt;a=5.0</em>5.0;<br>b = square(4.5+7.5);-&gt;b=4.5+7.5<em>4.5+7.5<br>d = square(c++);-&gt;d=c++</em>c++<br>可以看出，对于b，需要使用括号才能正常运算。  </p>
<p>#define SQUARE(X) ((X)*(X))<br>对于c,却仍递增了两次。<br>因此，宏定义和内联函数存在本质的区别，转换的时候应考虑是否转换后功能是否正常。</p>
<p><strong>5.什么时候使用内联函数</strong><br>如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间占比很小。若代码执行时间很短，则内联函数就可以节省函数调用的时间。</p>
<p>参考资料：《C++ Primer.Plus》 pp.253-255</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++友元详解]]></title>
      <url>https://shijingjing07.github.io/2016/05/24/C++%E5%8F%8B%E5%85%83%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><strong>1.什么是友元</strong><br>在一个类A中，将类B声明为友元类，则类B可以访问类A的私有成员和保护成员。另外，也可以将函数声明为友元函数。</p>
<p><strong>2.什么时候用到友元</strong><br>若不同的类之间某些共享数据成员，可以使用友元，简化类的设计。</p>
<p><strong>3.友元类</strong><br>友元类的声明：friend class 类名<br>示例如下：<br>对于电视和遥控器来说，都共享频道数据成员和开关操作，这时可以将遥控器声明为电视的友元类，则遥控器可以直接访问电视的数据成员,且一个遥控器可以控制多台电视，这则例子很好的体现了友元的特点。</p>
<p>tv.h</p>
<pre><code>#ifndef TV_H_
#define TV_H_
class Tv
{
public :
    friend class Remote;
    enum State{off,on};

    Tv(int s=off,int mc=125):state(s),maxchannel(mc),channel(2){}

    void onoff(){state=(state==on)?off:on;}
    void chanup();
    void chandown();
    void settings() const;
private:
    int state;
    int maxchannel;
    int channel;
};
class Remote{
public:
    Remote(){};
    void onoff(Tv &amp;t){t.onoff();};
    void chanup(Tv &amp;t){t.chanup();};
    void chandown(Tv &amp;t){t.chandown();};
    void set_chan(Tv &amp;t,int c){t.channel=c;};
};
</code></pre><p>tv.cpp</p>
<pre><code>#include&lt;iostream&gt;
#include &quot;tv.h&quot;
void Tv::chanup()
{
    if(channel&lt;maxchannel){
        channel++;
    }
    else{
        channel = 1;
    }
}
void Tv::chandown()
{
    if(channel&gt;1){
        channel--;
    }
    else{
        channel = maxchannel;
    }
}
void Tv::settings() const
{
    using std::cout;
    using std::endl;
    cout&lt;&lt;&quot;Tv is &quot;&lt;&lt;(state==on?&quot;on&quot;:&quot;off&quot;)&lt;&lt;endl;
    if(state==on)
    {
        cout&lt;&lt;&quot;channel:&quot;&lt;&lt;channel&lt;&lt;endl;    
    }
}
</code></pre><p>use_tv.cpp 可使用同一个遥控器控制多台不同的电视</p>
<pre><code>#include&lt;iostream&gt;
#include &quot;tv.h&quot;
int main()
{
    using std::cout;
    using std::endl;
    Tv s42;
    cout&lt;&lt;&quot;Initing Tv s42......&quot;&lt;&lt;endl;
    s42.settings();
    s42.onoff();
    s42.chanup();
    cout&lt;&lt;&quot;adjusted Tv s42.....&quot;&lt;&lt;endl;
    s42.settings();

    Remote control;
    control.set_chan(s42,10);
    control.volup(s42);
    cout&lt;&lt;&quot;settings after using remote......&quot;&lt;&lt;endl;
    s42.settings();
    getchar();
    return 0;
}
</code></pre><p>示例可以看出，若不使用友元，则必须将Tv类的私有部分设置为共有的，或者创建一个大型类来包含电视和遥控器。这种解决方法也无法反应，一个遥控器可以用于多台电视。</p>
<p><strong>4.友元函数</strong><br>从上例可以看出，Remote类只有set_chan方法使用到了Tv类的私有成员，因此我们可以让Remote::set_chan()成为Tv类的友元函数，而不必让整个类成为友元。</p>
<p>tvfm.h</p>
<pre><code>#ifndef TV_H_
#define TV_H_
class Tv;
class Remote{
public :
    enum State{off,on};
private:
    int mode;
public:
    Remote(){};
    void onoff(Tv &amp;t);
    void chanup(Tv &amp;t);
    void chandown(Tv &amp;t);
    void set_chan(Tv &amp;t,int c);
};
class Tv
{
public :
    friend void Remote::set_chan(Tv &amp;t,int c);
    enum State{off,on};

    Tv(int s=off,int mc=125):state(s),maxchannel(mc),channel(2){}

    void onoff(){state=(state==on)?off:on;}
    void chanup();
    void chandown();
    void settings() const;
private:
    int state;
    int maxchannel;
    int channel;
};

inline void Remote::onoff(Tv &amp;t){t.onoff();}
inline void Remote::chanup(Tv &amp;t){t.chanup();}
inline void Remote::chandown(Tv &amp;t){t.chandown();}
inline void Remote::set_chan(Tv &amp;t,int c){t.channel=c;}
#endif
</code></pre><p><strong>5.共同的友元</strong><br>多个类需要访问同一个函数，则可以在这些类中将这个函数声明为友元函数。例如：有一个计数器函数counter,两个类A和B同时调用这个函数，则可以在类A和B中将函数counter声明为友元函数。</p>
<pre><code>void counter()
{
    //....
}
class A
{
    friend int counter();
}
class B
{
    friend int counter();
}
</code></pre><p><strong>6.使用友元类时注意：</strong><br>1) 友元关系不能被继承。<br>2)友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元。<br>3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元</p>
<p>参考资料：《C++ Primer.Plus》 pp.602-610</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++ new操作符详解]]></title>
      <url>https://shijingjing07.github.io/2016/05/23/C++%20new%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>一.new操作符的概念</p>
<p>我们通常讲的new是指的是new operator，其实还有另外两个概念，operator new 和 placement new。</p>
<p>1、new operator  </p>
<p>我们在使用new operator的时候，实际上是执行了三个步骤:</p>
<p>1）调用operator new分配内存 ；2）调用构造函数生成类对象；3）返回相应指针。</p>
<p>2、operator new</p>
<p>所以说operator new做的事情是new operator的一部分。</p>
<p>operator new的原型是</p>
<p>Void* operator new(size_t size);</p>
<p>参数size指定待分配的内存大小，函数内部调用malloc初始化内存，返回指向这个内存的指针。</p>
<p>你可以重载这个函数(注意是重载operator new，而不能重载new operator)。operator<br>new默认情况下首先调用分配内存的代码，尝试得到一段堆上的空间，如果成功就返回，如果失败，则转而去调用一个new_hander(异常处理函数)，若没有定义new_hander，则抛出异常，否则执行new_hander，然后继续重复前面过程。你可以在重载的时候加上额外的参数，但是第一个参数类型必须是size_t.例如：</p>
<pre><code>class A
{
public:
   void* operator new(size_t size)
   {
       printf(&quot;operator new calledn&quot;);
       return ::operator new(size);
   }
};
A* a = new A();
</code></pre><p>这里通过::operator new调用了原有的全局的new，实现了在分配内存之前输出一句话。全局的operator<br>new也是可以重载的，但这样一来就不能再递归的使用new来分配内存，而只能使用malloc了：</p>
<pre><code>void* operator new(size_t size)
{
   printf(&quot;global newn&quot;);
   return malloc(size);
}
</code></pre><p>相应的，delete也有delete operator和operator delete之分，后者也是可以重载的。并且，如果重载了operator<br>new，就应该也相应的重载operator delete，这是良好的编程习惯。</p>
<p>3、placement new</p>
<p>placement new是用来实现定位构造的，因此可以实现new operator三步操作中的第二步。</p>
<p>其实它也只是operator<br>new的一个重载的版本，只是我们很少用到它。如果你想在已经分配的内存中创建一个对象，使用new时行不通的。也就是说placement<br>new允许你在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。原型中void*p实际上就是指向一个已经分配好的内存缓冲区的的首地址。</p>
<p>我 们知道使用new操作符分配内存需要在堆中查找足够大的剩余空间，这个操作速度是很慢的，而且有可能出现无法分配内存的异常（空间不够）。 placement<br>new就可以解决这个问题。我们构造对象都是在一个预先准备好了的内存缓冲区中进行，不需要查找内存，内存分配的时间是常数；而且不会出现在程序运行中途<br>出现内存不足的异常。所以，placement new非常适合那些对时间要求比较高，长时间运行不希望被打断的应用程序。</p>
<p>使用方法如下：<br>1. 缓冲区提前分配<br>可以使用堆的空间，也可以使用栈的空间，所以分配方式有如下两种：</p>
<pre><code>class MyClass {…};
char *buf=new char[N*sizeof(MyClass)+sizeof(int)];或者char buf[N*sizeof(MyClass)+sizeof(int)];
</code></pre><p>2. 对象的构造</p>
<pre><code>MyClass * pClass=new(buf) MyClass;
</code></pre><p>3. 对象的销毁<br>一旦这个对象使用完毕，你必须显式的调用类的析构函数进行销毁对象。但此时内存空间不会被释放，以便其他的对象的构造。</p>
<pre><code>pClass-&gt;~MyClass();
</code></pre><p>4. 内存的释放<br>如果缓冲区在堆中，那么调用delete[] buf;进行内存的释放；如果在栈中，那么在其作用域内有效，跳出作用域，内存自动释放。</p>
<p>注意：</p>
<pre><code>* 在C++标准中，对于placement operator new []有如下的说明： placement operator new[] needs implementation-defined amount of additional storage to save a size of array. 所以我们必须申请比原始对象大小多出sizeof(int)个字节来存放对象的个数，或者说数组的大小。
* 使用方法第二步中的new才是placement new，其实是没有申请内存的，只是调用了构造函数，返回一个指向已经分配好的内存的一个指针，所以对象销毁的时候不需要调用delete释放空间，但必须调用析构函数销毁对象。
</code></pre><p>placement new 是重载operator new 的一个标准、全局的版本，它不能够被自定义的版本代替（不像普通版本的operator new 和<br>operator delete能够被替换）。<br>void <em>operator new( size_t, void </em>p ) throw()     { return p; }<br>placement new的执行忽略了size_t参数，只使用第二个参数。其结果是允许用户把一个对象放到一个特定的地方，达到调用构造函数的效果。<br>和其他普通的new不同的是，它在括号里多了另外一个参数。比如：<br>Widget * p = new Widget; - - - - - - - - - //ordinary new<br>pi = new (ptr) int; pi = new (ptr) int;     //placement new  </p>
<p>括号里的参数ptr是一个指针，它指向一个内存缓冲器，placement new将在这个缓冲器上分配一个对象。Placement<br>new的返回值是这个被构造对象的地址(比如括号中的传递参数)。placement<br>new主要适用于：在对时间要求非常高的应用程序中，因为这些程序分配的时间是确定的；长时间运行而不被打断的程序；</p>
<p>三、处理内存分配异常</p>
<p>正如前面所说，operator<br>new的默认行为是请求分配内存，如果成功就返回，如果失败，则转而去调用一个new_hander(异常处理函数)，若没有定义new_hander，则抛出异常，否则执行new_hander，然后继续重复前面过程。于是，想要从operator<br>new的执行过程中返回，则必然需要满足下列条件之一：</p>
<p>1）分配内存成功</p>
<p>2）new_handler中抛出bad_alloc异常</p>
<p>3）new_handler中调用exit()或类似的函数，使程序结束</p>
<p>于是，我们可以假设默认情况下operator new的行为是这样的：</p>
<pre><code>void* operator new(size_t size)  
{  
   void* p = null  
   while(!(p = malloc(size)))  
   {  
       if(null == new_handler)  
          throw bad_alloc();  
       try  
       {  
          new_handler();  
       }  
       catch(bad_alloc e)  
       {  
          throw e;  
       }  
       catch(…)  
       {}  
   }  
   return p;  
}  
</code></pre><p>当operator new不能满足一个内存分配请求的时候，默认会抛出一个异常，我们可以通过设置new_handler定义处置策略。</p>
<p>new_handler的模型为：void (*new_handler)()</p>
<p>可以通过”void set_new_handler( void(*new_handler)())<br>throw();”设置这个处理函数（new_handler），它定义在&lt;new&gt;标准函数库中：</p>
<pre><code>namespace std
{
    void (*new_handler)();
    void set_new_handler( new_handler )throw();
}


//error-handling function
void MemErrorHandling()
{
    std::cerr &lt;&lt; &quot;Failed to allocate memory.\n&quot;;
    std::abort();
}
... ...
std::set_new_handler(MemErrorHandling);
</code></pre><p>现在我们知道了new操作失败后，系统地大概处理流程，以及怎么设置用户自定义处理函数，但是我们究竟可以在new_handler中做些什么处理呢？</p>
<p>1、删除其它无用的内存，使系统具有可以更多的内存可以使用，为下一步的内存申请作准备。<br>2、设置另外一个new_handler。如果当前的new_handler不能够做到更多的内存申请操作，或者它知道另外一个new_handler可<br>以做到，则可以调用set_new_handler函数设置另外一个new_handler，这样在operator<br>new下一次调用的时候，可以使用这个新的new_handler。<br>3、卸载new_handler（通过set_new_handler(0)），使operator<br>new在下一次调用的时候，因为new_handler为空抛出内存申请异常。<br>4、抛出自定义异常。<br>5、不再返回，调用abort或者exit退出程序。</p>
<p>参考：<br>1、<a href="http://www.bc-cn.net/Article/kfyy/cjj/jszl/200604/4002.html" target="_blank" rel="external">http://www.bc-cn.net/Article/kfyy/cjj/jszl/200604/4002.html</a></p>
<p>2、<a href="http://blog.csdn.net/youdianmengxiangba/article/details/8233651" target="_blank" rel="external">http://blog.csdn.net/youdianmengxiangba/article/details/8233651</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CDN技术详解笔记]]></title>
      <url>https://shijingjing07.github.io/2016/05/20/CDN%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>1.影响网络传输的四个因素<br>（1）”第一公里”：网站服务器接入互联网的链路所能提供的带宽。<br>（2）”最后一公里”：用户接入带宽。<br>（3）对等互联关口：不同网络之间的互联互通带宽。<br>（4）长途骨干传输：首先是长距离传输时延问题，其次是骨干网拥塞问题</p>
<p>2.用户通过浏览器访问网站的过程如下图所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201605/300946-20160520133722216-1539567662.png" alt=""></p>
<p>①用户在自己的浏览器中输入要访问的网站域名。</p>
<p>②浏览器向本地DNS服务器请求对该域名的解析。</p>
<p>③本地DNS服务器中如果缓存有这个域名的解析结果，则直接用户的解析请求。</p>
<p>④本地DNS服务器中如果没有关于这个域名的解析结果的缓存，则以递归方式向整个DNS系统请求解析，获得应答后将结果反馈给浏览器。</p>
<p>⑤浏览器得到域名解析结果，就是该域名相应的服务设备的IP地址。</p>
<p>⑥浏览器向服务器请求内容。</p>
<p>⑦服务器将用户请求内容传送给浏览器。</p>
<p>3.引入CDN后的访问流程</p>
<p><img src="http://images.51cto.com/files/uploadimg/20120528/1230001.jpg" alt=""></p>
<p>①当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。</p>
<p>②CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。</p>
<p>③用户向CDN的全局负载均衡设备发起内容URL访问请求。</p>
<p>④CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。</p>
<p>⑤区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务。选择的依据包括:根据用户IP地址，判断哪一台服务器距离用户最近；根据用户请求的URL携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。</p>
<p>⑥全局负载均衡设备把IP地址返回用户。</p>
<p>⑦用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域负载均衡设备依然将它分配给了用户，那么这一台服务器要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</p>
<p>4.CDN的系统架构</p>
<p><img src="http://images.51cto.com/files/uploadimg/20120528/123332551.jpg" alt=""></p>
<p>5.CDN部署架构</p>
<p><img src="http://images.51cto.com/files/uploadimg/20120528/1235500.jpg" alt=""></p>
<p>在一个节点中，Cache设备和本地负载均衡设备的连接方式有两种：一种是旁路方式，一种是穿越方式。</p>
<p><img src="http://images.51cto.com/files/uploadimg/20120528/1235501.jpg" alt=""></p>
<p>6.CDN系统分类</p>
<p>（1）基于不同内容承载类型的分类</p>
<ul>
<li>网页加速</li>
<li>流媒体加速</li>
<li>文件传输加速</li>
<li>应用协议加速：针对TCP/IP等传输协议的优化。</li>
</ul>
<p>（2）基于内容生成机制的分类</p>
<p>主流的Web网站系统都能够在逻辑上分为三个层次，表现层、业务逻辑层、数据访问层。</p>
<p>根据CDN完成的不同层面的Web转移功能，将CDN分为表示层复制（静态网站）和全站复制（动态网站）两类。</p>
<p>7.CDN系统三维模型图</p>
<p><img src="http://images.51cto.com/files/uploadimg/20120528/123808115.jpg" alt=""></p>
<p>X轴方向是贯穿系统头端到终端的垂直系统，每一种业务能力都可以有自己的中心、区域、边缘层设备，有自己独立的管理系统、负载均衡系统、分发服务系统。<br>因此，在X轴方向上，每一个CDN服务能力都可以是一套相对独立的子系统。</p>
<p>Y轴方向的分级划分是依据CDN逐级缓存、分级调度、分级服务的要求。<br>CDN的管理功能、调度功能、缓存功能、服务功能都是分级部署的，不同层级的相同功能实体之间相互配合。<br>从控制功能上看，往往下一级控制实体是上一级控制实体的执行者；<br>从缓存功能上看，上一级缓存是下一级缓存实体的内容提供者；<br>从 服务功能上看，上一级服务实体是下一级服务实体的能力补充和备份。</p>
<p>Z轴方向上，管理层主要完成CDN网络管理和业务逻辑处理。<br>网络管理提供IP网络层面的配置管理、故障管理、网络性能管理以及网络安全管理等，负责对整个CDN系统的网络和设备资源进行抽象，提取其业务能力，提供给上层业务平台。<br>业务逻辑处理指CDN系统辅助其服务的业务平台完成部分应用层功能的实现，完成和其他系统之间的接口适配，负责系统的认证、计费、统计分析、系统管理、用户管理、SP管理等功能。<br>控制平面负责对整个CDN网络的内容分布情况进行管理，对内容分发和访问路由策略进行控制，它是整个内容分发系统内容数据流向的控制点。<br>数据平面承担实际的内容分发工作，根据Z轴方向与X轴、Y轴相交点的具体要求，数据平面设备具备不同的应用服务提供能力。</p>
<p>参考资料：《CDN技术详解》 pp.1-29</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MSVC與CRT的恩怨情仇]]></title>
      <url>https://shijingjing07.github.io/2016/05/19/MSVC%E8%88%87CRT%E7%9A%84%E6%81%A9%E6%80%A8%E6%83%85%E4%BB%87/</url>
      <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><p>很久沒有寫程式設計入門知識的相關文章了，這篇文章要來談談程式庫 (Library) 連結，以及關於 MSVC 與 CRT 之間的種種恩怨情仇。</p>
<p>如果你使用的作業系統是 Linux、Mac 或其他非 Windows 平台，你可以忽略這篇文章；如果你使用的作業系統是 Windows 平台，但沒有用<br>Microsoft Visual Studio C++（以下簡稱為 MSVC）軟體撰寫 C++ 程式的話，這篇文章對你的幫助可能很有限；但如果你的作業系統是<br>Windows，而且你使用的程式整合開發環境是 MSVC 軟體撰寫 C++ 程式的話，這篇文章應該能夠幫助你釐清一些重要的基礎觀念。</p>
<p>身為程式設計者，在學習程式設計的過程中，你是否曾經遇過某些看起來不知所云的錯誤訊息，卻不知該如何解決？例如當你快快樂樂地寫完程式，並且確認<br>所有的程式碼都能成功通過編譯之後，接著執行「建置方案」(Build Solution) 的步驟，結果卻跑出一堆莫名其妙的錯誤：</p>
<blockquote>
<p>LIBCMTD.lib(mlock.obj) : error LNK2005: <strong>lock 已在 MSVCRTD.lib(MSVCR80D.dll)<br>中定義過了<br> LIBCMTD.lib(mlock.obj) : error LNK2005: </strong>unlock 已在<br>MSVCRTD.lib(MSVCR80D.dll) 中定義過了<br> LIBCMTD.lib(crt0.obj) : error LNK2005: _mainCRTStartup 已在<br>MSVCRTD.lib(crtexe.obj) 中定義過了</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>…………</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>LINK : warning LNK4098: 預設的程式庫 ‘MSVCRTD’ 與其他使用的程式庫衝突，請使用<br>/NODEFAULTLIB:library<br> LINK : warning LNK4098: 預設的程式庫 ‘LIBCMTD’ 與其他使用的程式庫衝突，請使用<br>/NODEFAULTLIB:library<br> D:\Workspace\CrtLibTest\Debug\CrtLibTest.exe : fatal error LNK1169:<br>找到有一或多個已定義的符號</p>
</blockquote>
<p>以一般的情況來說，如果在你的程式專案中有使用某些由他人所撰寫的第三方程式庫或是開源專案的程式庫，比較容易會發生上述的錯誤狀況。從上述這些看<br>似離奇而令人摸不著頭緒的錯誤訊息中，我們大概可以猜測問題點應該在於 LIBCMTD.lib 與 MSVCRTD.lib 這兩個程式庫身上。<strong>但到底什麼是<br>LIBCMTD.lib 和 MSVCRTD.lib？在我們的程式碼中有使用這些程式庫嗎？</strong></p>
<p>答案是肯定的。</p>
<p>熟悉 C 語言的程式設計者都知道，如果要使用 printf()、scanf() 或者 fopen() 等等 C 語言的基本 I/O 操作函式時，首先必須用</p>
<p>#include 語法將 stdio.h 這個標頭檔納入我們的程式碼中。藉由 stdio.h 中對這些 I/O 操作函式所做出的函式宣告 (function<br>declaration)，編譯器 (Compiler) 才得以確認 printf、scanf 以及 fopen 等等都是合法可用的函式。</p>
<p>而當我們撰寫的程式碼經過編譯器產出 OBJ 形式的檔案之後，需要再經由連結器 (Linker) 的處理程序，將程式碼中全部有使用到的函式定義<br>(function definition) 連結建置起來，才能夠產生出最後的程式執行檔。問題來了，我們知道 printf、scanf 以及 fopen<br>的函式宣告存在於 stdio.h 當中，但是這些傢伙的函式定義，也就是真正的實做程式碼，究竟存放在什麼地方呢？</p>
<p><strong>在 C 語言的標準程式庫中。</strong></p>
<p>由 C 語言所制訂的標準程式庫，稱之為<strong>「執行階段程式庫」</strong>，也就是 <strong>C Run-Time Library</strong>，通常可簡稱為 <strong>CRT</strong>。在 C<br>語言的標準程式庫中，包含了一組常用的基礎函式，例如 I/O 處理與字串操作程序等等，所以只要我們使用 C 語言撰寫程式碼，就一定要將編譯完成後的程式碼<br>OBJ 檔，連結至 C 語言的執行階段程式庫，才能夠產生出合法的 C 語言程式執行檔。</p>
<p>而 CRT 並非只有單一一種版本存在。事實上，除了可以依「除錯」與「釋出」用途分成兩個版本之外，兩者又可分別衍生分出「靜態連結」與「動態連結」兩種形式：</p>
<blockquote>
<p><strong>靜態連結</strong>：</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>LIBCMTD.lib（除錯版本）</p>
</li>
<li><p>LIBCMT.lib</p>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<p>&gt;</p>
<blockquote>
<p><strong>動態連結</strong>：</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>MSVCRTD.lib（除錯版本）</p>
</li>
<li><p>MSVCRT.lib</p>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<p>雖然這四個 CRT 版本的用途與使用方式各不相同，但卻有個共通的特點，就是<strong>它們都是滿足執行緒安全需求，可在多執行緒程式碼中安全使用的程式庫版本</strong>。<br>事實上，在過去 MSVC 6 的版本中，本來還有另外兩個 LIBCD.lib（除錯版本）與 LIBC.lib 程式庫，是專門給單執行緒程式使用的 CRT<br>版本，但是這兩個選項自 MSVC 2005 開始就從設定選項中被刪除掉了，所以現在大多數程式設計者使用的都是多執行緒的 CRT 版本。</p>
<p>在程式庫連結 (library linking)<br>的行為中，靜態連結和動態連結的分別，在於使用靜態連結時，會直接將程式庫的函式定義嵌入執行檔之中，而使用動態連結時，程式庫的函式定義則存在於另外的<br>獨立檔案，通常是 DLL<br>格式的檔案中，然後與程式執行檔一同發佈給使用者。因此在檔案的尺寸上，使用動態連結的執行檔檔案，通常會比使用靜態連結的執行檔檔案來得更小一些。</p>
<p>使用動態連結 CRT 版本的好處，是能夠將經常使用到的標準程式庫們獨立出來，放在 Windows<br>的系統資料夾中，以減少我們建置出來的執行檔檔案尺寸。但反過來說，<strong>使用動態連結 CRT 版本的缺點也在於這些與執行檔相依為命的 DLL 檔案上</strong>。<br>舉例來說，如果程式以 MSVC 2005 建置出 Debug 組態的執行檔，則此執行檔需要有 msvcr80d.dll 存在才能順利執行；如果是<br>Release 組態，則相依於 msvcr80.dll。但是如果你把相同的程式碼拿到 MSVC 2008 上建置，產生出來的執行檔則相依於<br>msvcr90d.dll 與 msvcr90.dll 兩個不同的 DLL 檔案。<strong>不同版本的 MSVC，都會有各自不同的相依 DLL 檔案。</strong></p>
<p>在 MSVC 的程式專案中，如何指定程式碼要使用靜態連結或者動態連結的 CRT<br>版本？其實很容易，只要在專案屬性的「C/C++」頁面中，選擇「程式碼產生」(Code Generation)<br>子頁面，其中有個「執行階段程式庫」(Runtime Library) 的項目，也就是專案中用來設定 CRT<br>連結版本的地方。其中總共有四個選項，正好對應於上述靜態連結與動態連結的四個不同程式庫版本。</p>
<ul>
<li><strong>多執行緒偵錯 (/MTd)</strong>：對應 LIBCMTD.lib</li>
<li><strong>多執行緒 (/MT)</strong>：對應 LIBCMT.lib</li>
<li><strong>多執行緒偵錯 DLL (/MDd)</strong>：對應 MSVCRTD.lib</li>
<li><strong>多執行緒 DLL (/MD)</strong>：對應 MSVCRT.lib</li>
</ul>
<p>如果你沒有做任何設定就開始建置程式的話，MSVC 的預設選項則會使用動態連結的版本。</p>
<p><img src="http://blog.monkeypotion.net/wp-content/uploads/2009/03/c
-runtime-library.jpg" alt="c-runtime-library">C Runtime Library</p>
<p>請注意，以上只是單純 C 語言的程式庫而沒有包含 C++ 語言在內。如果你的程式系統中，有包含 C++<br>語言的程式碼的話，那又是另外一回事了。但是在專案屬性的頁面中，為什麼找不到相關的設定選項呢？<strong>因為 MSVC<br>悄悄地幫程式設計者代勞處理掉了。</strong>只要在程式碼中使用 #include 語法納入任何一個 C++ 的標頭檔，例如 iostream 或<br>fstream，MSVC 就會在連結器的運作階段中，自動幫我們連結 C++ 的執行階段程式庫。而 C++ 的執行階段程式庫，同樣可分為四個版本：</p>
<blockquote>
<p><strong>靜態連結</strong>：</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>LIBCPMTD.lib（除錯版本）</p>
</li>
<li><p>LIBCPMT.lib</p>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<p>&gt;</p>
<blockquote>
<p><strong>動態連結</strong>：</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>MSVCPRTD.lib（除錯版本）：執行檔相依於 MSVCP90D.dll</p>
</li>
<li><p>MSVCPRT.lib：執行檔相依於 MSVCP90.dll</p>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<p>至於程式執行檔使用的是靜態連結或者動態連結的版本，就仰賴於 C 語言的版本設定選項了。舉個例子來說，如果你撰寫了一個 Debug 組態的 C++<br>程式，並且保留專案原先預設的建置選項（動態連結），那麼最終建置出來的程式執行檔將會相依於 MSVCR90D.dll 以及 MSVCP90D.dll 兩個<br>DLL 檔案。如果將相同的程式以 Release 組態建置完成，則會相依於 MSVCR90.dll 以及 MSVCP90.dll 二者。</p>
<p><img src="http://blog.monkeypotion.net/wp-
content/uploads/2009/03/standard-cpp-library.jpg" alt="standard-cpp-library">Standard C++ Library</p>
<p>剛學習程式設計的入門者，經常會在滿心歡喜地完成一件程式作品並且傳給其他人使用時，卻發現不能在別人的電腦上啟動程式，其實就是陷入了使用者電腦缺少 DLL<br>檔案而無法執行程式的窘境。有三種方法可以解決這個令人困擾的問題：</p>
<ol>
<li>使用者的電腦，必須先安裝「Visual C++ 可轉發套件」（<a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=A5C84275-3B97-4AB7-A40D-3802B2AF5FC2&amp;displaylang=zh-tw" target="_blank" rel="external">MSVC 2008</a> 或 <a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=200B2FD9-AE1A-4A14-984D-389C36F85647&amp;displaylang=zh-tw" target="_blank" rel="external">MSVC 2005</a> ）。</li>
<li>將所需的 DLL 檔案，例如 MSVCR90D.dll 與 MSVCP90D.dll，直接附在程式的下載包當中。</li>
<li>以靜態連結方式建置程式執行檔。</li>
</ol>
<p>當你無法確定自己的程式或別人的程式，是否相依於某些特定的 DLL 檔案時，有一個非常好用的免費工具程式 <a href="http://www.dependencywalker.com/" target="_blank" rel="external">Dependency<br>Walker</a>，可以開啟 EXE 格式的執行檔或者 DLL<br>格式的動態程式庫，然後詳細地條列出它們所相依的 DLL 檔案。</p>
<p>瞭解了幾種不同的 CRT 版本選項之後，回到最前面的錯誤訊息問題，相信各位現在應該能夠很清楚地理解，原來會發生這些奇怪的錯誤狀況，<strong>是因為程式同時連結了<br>LIBCMTD.lib 與 MSVCRTD.lib 所以造成函式定義版本衝突</strong>。也就是說，程式連結器已經在其中一個 CRT<br>的版本中找到所需的函式定義，但此時卻又跳出另外一位 CRT，也給了一份相同函式的實作版本，所以連結器無法判斷應該忽略誰並且選擇誰。</p>
<p>而這個狀況的發生原因，就是你的程式與程式所連結的外部程式庫，使用了不同的 CRT 版本之故。例如，當你的程式使用了 Lua，自然必須連結至 Lua 的程式庫<br>lua5.1.lib，但如果 lua5.1.lib 是以靜態連結版本的 CRT 建置而成，而你的程式卻是以預設選項，動態連結 CRT<br>來建置程式執行檔的話，如此一來就會產生上述這些錯誤訊息了。至此，問題的答案已昭然若揭，解決方法有二種：<strong>其一是將 Lua 重新以動態連結 CRT<br>的方式建置出一個新的程式庫，其二則是將自己的程式專案改成以靜態連結 CRT 方式建置。</strong></p>
<p>換個角度想，當你身為一位程式庫的設計開發者，想要將自己寫的東西分享給其他人，但又不想要完全開放自己撰寫的程式源碼時，至少可以同時提供以下四種版本的程式庫，以妥善滿足使用者的各種不同需求：</p>
<ul>
<li>Debug：動態連結除錯版本</li>
<li>Release：動態連結版本</li>
<li>Debug_Static：靜態連結除錯版本</li>
<li>Release_Static：靜態連結版本</li>
</ul>
<p>然而，有時候世界並不會運作得如此理想。在某些特殊的狀況下，當我們使用他人所寫的第三方程式庫時，有時可能只拿得到其中某個特定的版本，例如<br>Release_Static<br>版本時，就很有可能會遇到程式庫衝突的錯誤情形。此時就需要視專案的實際需求而定，可以在專案屬性中指定「忽略特定程式庫」(Ignore Specific<br>Library) 這個選項，讓程式碼連結器忽略某些程式庫，以此化解動靜程式庫或新舊程式庫之間的恩怨衝突。</p>
<p><strong>小測驗</strong>：你所撰寫的程式，必須連結某個以靜態多執行緒 (/MT) CRT 建置而成的程式庫。如果你的程式在 Debug 組態下以多執行緒偵錯 (/MTd) 選項建置，是否會產生衝突？如果你的程式在 Release 組態下以多執行緒 (/MT) 選項建置，是否會產生衝突？是的話，應該如何解決？</p>
<p><strong>延伸閱讀：</strong></p>
<ul>
<li><a href="http://msdn.microsoft.com/en-us/library/abx4dbyh.aspx" target="_blank" rel="external">[MSDN] Visual Studio 2008: C Run-Time Libraries</a></li>
<li><a href="http://kobyk.wordpress.com/2007/07/20/dynamically-linking-with-msvcrtdll-using-visual-c-2005/" target="_blank" rel="external">Dynamically linking with MSVCRT.DLL using Visual C++ 2005</a></li>
</ul>
<p>转自：<a href="http://blog.monkeypotion.net/gameprog/beginner/love-and-hate-between-msvc-
and-crt" target="_blank" rel="external">http://blog.monkeypotion.net/gameprog/beginner/love-and-hate-between-msvc-
and-crt</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++中typename和class的区别]]></title>
      <url>https://shijingjing07.github.io/2016/05/18/C++%E4%B8%ADtypename%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<pre><code>在c++Template中很多地方都用到了typename与class这两个关键字，而且好像可以替换，是不是这两个关键字完全一样呢?  

相信学习C++的人对class这个关键字都非常明白，class用于定义类，在模板引入c++后，最初定义模板的方法为： template&lt;class T&gt;...... 
在这里class关键字表明T是一个类型，后来为了避免class在这两个地方的使用可能给人带来混淆，所以引入了typename这个关键字，它的作用同
class一样表明后面的符号为一个类型，这样在定义模板的时候就可以使用下面的方式了： template&lt;typename T&gt;......
在模板定义语法中关键字class与typename的作用完全一样。  

typename难道仅仅在模板定义中起作用吗？其实不是这样，typename另外一个作用为：使用嵌套依赖类型(nested depended name)，如下所示：


#include&lt;iostream&gt;
class MyArray
{
public:
    typedef int LengthType;
};
template&lt;class T&gt;
void MyMethod(T myarr)
{
    typedef typename T::LengthType LengthType;
    LengthType length = 5;
    printf(&quot;%d&quot;,length);
}
int main()
{
    MyArray myArray;
    MyMethod(myArray);
    return 0;
}


这个时候typename的作用就是告诉c++编译器，typename后面的字符串为一个类型名称，而不是成员函数或者成员变量，  
这个时候如果前面没有typename，编译器没有任何办法知道T::LengthType是一个类型还是一个成员名称(静态数据成员或者静态函数)，所以编译不能够通过。
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SDL2中文教程]]></title>
      <url>https://shijingjing07.github.io/2016/05/18/SDL2%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="SDL2-0-Tutorial-Index"><a href="#SDL2-0-Tutorial-Index" class="headerlink" title="SDL2.0 Tutorial Index"></a>SDL2.0 Tutorial Index</h1><p>原文地址:<a href="http://twinklebeardev.blogspot.com/p/sdl-20
-tutorial-index.html" target="_blank" rel="external">SDL 2.0 Tutorial Index</a></p>
<h3 id="Welcome"><a href="#Welcome" class="headerlink" title="Welcome!"></a>Welcome!</h3><p>下面的教程旨在为你提供一个SDL2.0以及c++中游戏设计和相关概念的介绍。在本教程中，我们假定你对C++有一定程度上的知识，至少了解数组，vector，控制结构，函数还有指针。  </p>
<p>如果你觉得理解教程中的代码有困难，你可以在教程后面随意留言，或者在<a href="http://stackoverflow.com/questions/388242
/the-definitive-c-book-guide-and-list" target="_blank" rel="external">StackOverflow</a>上的这个列表里抓一本书来读。  </p>
<p>如果你想要查看或者下载全部的程序代码，你可以在<a href="https://github.com/Twinklebear/TwinklebearDev-
Lessons" target="_blank" rel="external">Github</a>上找到。但是切忌复制粘贴！  </p>
<p>SDL2.0的文档现在可以在<a href="http://wiki.libsdl.org/moin.cgi/FrontPage" target="_blank" rel="external">online wiki</a>上查看到。  </p>
<h3 id="教程目录："><a href="#教程目录：" class="headerlink" title="教程目录："></a>教程目录：</h3><p><a href="http://twinklebeardev.blogspot.com/2012/07/lesson-0
-setting-up-sdl.html" target="_blank" rel="external">Lesson 0: Setting up SDL</a><br><a href="http://adolfans.github.io/sdltutorialcn/blog/2013/01/25/lesson-0
-setting-up-sdl/" target="_blank" rel="external">第0节：配置SDL</a></p>
<p><a href="http://twinklebeardev.blogspot.com/2012/07/lesson-1
-hello-world.html" target="_blank" rel="external">Lesson 1: Hello World!</a> <a href="http://adolfans.github.io/sdltutorialcn/blog/2013/01/26/lesson-1
-hello-world/" target="_blank" rel="external">第一节: Hello<br>World!</a></p>
<p><a href="http://twinklebeardev.blogspot.com/2012/07/lesson-2-dont-put-everything-
in-main.html" target="_blank" rel="external">Lesson 2: Don’t Put Everything in<br>Main</a><br><a href="http://adolfans.github.io/sdltutorialcn/blog/2013/01/28/lesson-2
-dont-put-everything-in-main/" target="_blank" rel="external">第二节：别什么都塞进main里</a></p>
<p><a href="http://twinklebeardev.blogspot.com/2012/07/lesson-3-sdl-extension-
libraries.html" target="_blank" rel="external">Lesson 3: SDL Extension<br>Libraries</a><br><a href="http://adolfans.github.io/sdltutorialcn/blog/2013/01/28/lesson-3
-sdl-extension-libraries/" target="_blank" rel="external">第三节：SDL扩展库</a></p>
<p><a href="http://twinklebeardev.blogspot.com/2012/07/lesson-4-event-driven-
programming.html" target="_blank" rel="external">Lesson 4: Event Driven<br>Programming</a><br><a href="http://adolfans.github.io/sdltutorialcn/blog/2013/02/12/lesson-4
-event-driven-programming/" target="_blank" rel="external">第四节：事件驱动的编程</a></p>
<p><a href="http://twinklebeardev.blogspot.com/2012/08/lesson-5-clipping-sprite-
sheets.html" target="_blank" rel="external">Lesson 5: Clipping Sprite<br>Sheets</a><br><a href="http://adolfans.github.io/sdltutorialcn/blog/2013/02/14/lesson-5
-clipping-sprite-sheets/" target="_blank" rel="external">第五节：裁剪精灵表</a></p>
<p><a href="http://twinklebeardev.blogspot.com/2012/08/lesson-6-true-type-fonts-
with-sdlttf.html" target="_blank" rel="external">Lesson 6: True Type Fonts with<br>SDL_ttf</a> <a href="http://adolfans.github.io/sdltutorialcn/blog/2013/03/23/lesson-6-true-
type-fonts-with-sdl-ttf/" target="_blank" rel="external">第六节: 使用SDL_ttf绘制True<br>Type字体</a></p>
<p><a href="http://twinklebeardev.blogspot.com/2012/09/lesson-7-taking-advantage-
of-classes.html" target="_blank" rel="external">Lesson 7: Taking Advantage of<br>Classes</a><br><a href="http://adolfans.github.io/sdltutorialcn/blog/2013/03/24/lesson-7
-taking-advantage-of-classes/" target="_blank" rel="external">第七节：充分利用类</a></p>
<p><a href="http://twinklebeardev.blogspot.com/2012/10/lesson-8-timers.html" target="_blank" rel="external">Lesson 8:<br>Timers</a><br><a href="http://adolfans.github.io/sdltutorialcn/blog/2013/01/28/lesson-8-timers/" target="_blank" rel="external">第八节：计时器</a></p>
<p>转自：<a href="http://adolfans.github.io/sdltutorialcn/sdl-2-dot-0-tutorial-index/" target="_blank" rel="external">http://adolfans.github.io/sdltutorialcn/sdl-2-dot-0-tutorial-index/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SDL介绍]]></title>
      <url>https://shijingjing07.github.io/2016/05/18/SDL%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>SDL库的作用说白了就是封装了复杂的视音频底层操作，简化了视音频处理的难度。</p>
<p>以下转自WiKi：</p>
<p>SDL（Simple DirectMedia<br>Layer）是一套开放源代码的跨平台多媒体开发库，使用C语言写成。SDL提供了数种控制图像、声音、输出入的函数，让开发者只要用相同或是相似的代码就可以开发出跨多个平台（Linux、Windows、Mac<br>OS X等）的应用软件。目前SDL多用于开发游戏、模拟器、媒体播放器等多媒体应用领域。<br>SDL使用GNU宽通用公共许可证为授权方式，意指动态链接（dynamic<br>link）其库并不需要开放本身的源代码。因此诸如《雷神之锤4》等商业游戏也使用SDL来开发。  </p>
<p>结构<br>虽然SDL时常被比较为’跨平台的DirectX’，然而事实上SDL是定位成以精简的方式来完成基础的功能，它大幅度简化了控制图像、声音、输出入等工作所需撰写的代码。但更高级的绘图功能或是音效功能则需搭配OpenGL和OpenAL等API来达成。另外它本身也没有方便创建图形用户界面的函数。<br>SDL在结构上是将不同操作系统的库再包装成相同的函数，例如SDL在Windows平台上其实是DirectX的再包装，旧版本包装的是DirectX<br>5，现时的版本（SDL 1.2）则是DirectX 7。而在使用X11的平台上（包括Linux），SDL则是与Xlib库沟通来输出图像。<br>虽然SDL本身是使用C语言写成，但是它几乎可以被所有的编程语言所使用，例如：C++、Perl、Python（借由pygame库）、Pascal等等，甚至是Euphoria、Pliant这类较不流行的编程语言也都可行。<br>SDL库分为 Video、Audio、CD-ROM、Joystick 和 Timer<br>等若干子系统，除此之外，还有一些单独的官方扩充函数库。这些库由官方网站提供，并包含在官方文档中，共同组成了SDL的”标准库”：<br>SDL_image–支持时下流行的图像格式：BMP、PPM、XPM、 PCX、GIF、JPEG、PNG、TGA。<br>SDL_mixer–更多的声音输出函数以及更多的声音格式支持。<br>SDL_net–网络支持。<br>SDL_ttf–TrueType字体渲染支持。<br>SDL_rtf–简单的RTF渲染支持。</p>
<p><img src="http://img.blog.csdn.net/20130923233206828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>子系统<br>SDL将功能分成下列数个子系统（subsystem）：<br>Video（图像）–图像控制以及线程（thread）和事件管理（event）。<br>Audio（声音）–声音控制<br>Joystick（摇杆）–游戏摇杆控制<br>CD-ROM（光盘驱动器）–光盘媒体控制<br>Window Management（视窗管理）－与视窗程序设计集成<br>Event（事件驱动）－处理事件驱动<br>以下是一支用C语言写成、非常简单的SDL示例：</p>
<pre><code>// Headers
#include &quot;SDL.h&quot;

// Main function
int main(int argc, char* argv[])
{
    // Initialize SDL
    if(SDL_Init(SDL_INIT_EVERYTHING) == -1)
        return(1);

    // Delay 2 seconds
    SDL_Delay(2000);

    // Quit SDL
    SDL_Quit();

    // Return
    return 0;
}
</code></pre><p>SDL与DirectX比较对应关系：</p>
<table>
<thead>
<tr>
<th><strong>SDL</strong></th>
<th><strong>DirectX</strong></th>
<th><strong>说明</strong>  </th>
</tr>
</thead>
<tbody>
<tr>
<td>SDL_Video、SDL_Image、OpenGL</td>
<td>DirectDraw、Direct3D</td>
<td></td>
</tr>
<tr>
<td>SDL_Audio、SDL_Mixer</td>
<td>DirectSound</td>
<td></td>
</tr>
<tr>
<td>SDL_Joystick、SDL_Base</td>
<td>DirectInput</td>
<td></td>
</tr>
<tr>
<td>SDL_Net</td>
<td>DirectPlay</td>
<td></td>
</tr>
<tr>
<td>SMPEG、SDL_Video、SDL_Audio、SDL_Sound、SDL_Filter</td>
<td>DirectShow</td>
<td></td>
</tr>
</tbody>
</table>
<p>使用SDL开发的游戏:</p>
<p>《Spore》<br>《Tux Paint》<br>《Simutrans》<br>《Stepmania》<br>《Frozen Bubble》<br>《无冬之夜》（Neverwinter Nights）<br>《魔法门之英雄无敌III》（Heroes of Might and Magic III）（Linux版）<br>《模拟城市3000》（Sim City 3000）（Linux版）<br>《虚幻竞技场》（Unreal Tournament）（Linux版）<br>《虚幻竞技场2003》（Unreal Tournament 2003）（Linux版）<br>《虚幻竞技场2004》（Unreal Tournament 2004）（Linux版）<br>《第二人生》（Second Life）（Linux版）<br>《佣兵战场》（Soldier of Fortune）（Linux版）<br>《韦诺之战》（Battle for Wesnoth）<br>Bos Wars</p>
<p>转自：<a href="http://blog.csdn.net/leixiaohua1020/article/details/11954039" target="_blank" rel="external">http://blog.csdn.net/leixiaohua1020/article/details/11954039</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu 14.04 配置 Java SE jdk-7u55]]></title>
      <url>https://shijingjing07.github.io/2016/05/14/Ubuntu%2014.04%20%E9%85%8D%E7%BD%AE%20Java%20SE%20jdk-7u55/</url>
      <content type="html"><![CDATA[<p>JDK  目前最新版为jdk-8u5，这次没有选择安装最新的jdk8，而是要安装jdk7的最高版jdk-7u55 。</p>
<pre><code>首先，去官网下载jdk-7u55，地址：&lt;http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html&gt;
</code></pre><p><img src="http://img.blog.csdn.net/20140430145901406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGVjbjE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>选择Accept License Agreement 后，选择对应版本下载，Ubuntu 选择tar.gz的压缩包，64位选x64，32位选i586。</p>
<p>下完后得到压缩包：jdk-7u55-linux-x64.tar.gz，解压再配置 下就可以使用了，不需要安装。我解压到家目录下，终端执行：tar -zxvf<br>jdk-7u55-linux-x64.tar.gz  -C ~/， -C 后是要解压到的目录。得到文件夹：jdk1.7.0_55</p>
<p>接下来设置环境变量，终端执行：sudo gedit /etc/environment</p>
<p><img src="http://img.blog.csdn.net/20140430160007265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGVjbjE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">  </p>
<p>在已有的PATH变量后添加jdk的bin目录，注意用冒号与已有变量隔开</p>
<p>再添加CALSSPATH和JAVA_HOME变量</p>
<p>我的情况如下：</p>
<p>PATH=”/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/tecn/jdk1.7.0_55/bin”<br>CLASSPATH=”/home/tecn/jdk1.7.0_55/lib:.”       注意后面有个点<br>JAVA_HOME=”/home/tecn/jdk1.7.0_55/“  </p>
<p>设置好后，注销或重启使环境变量生效！</p>
<p>查看是否生效，终端执行：<a href="http://lib.csdn.net/base/17" title="Java EE知识库" target="_blank" rel="external">Java</a> -version<br>，就可以看到版本就是刚配置的7u55 。</p>
<p><img src="http://img.blog.csdn.net/20140430160545531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGVjbjE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">  </p>
<p>到此就配置完成了，可以写个helloworld测试下。</p>
<p><img src="http://img.blog.csdn.net/20140430161349421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGVjbjE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">  </p>
<p>已经装有openjdk启用官方jdk的方法：</p>
<p>依次终端执行：</p>
<p>sudo update-alternatives –install /usr/bin/java java<br>/home/tecn/jdk1.7.0_55/bin/java 445<br>sudo update-alternatives –install /usr/bin/javac javac<br>/home/tecn/jdk1.7.0_55/bin/javac 445<br>sudo update-alternatives –config java  </p>
<p>将会提示，要维持当前值[*]请按回车键，或者输入选择的编号：</p>
<p>输入优先级为 445 的那项的编号，回车即可。</p>
<p>-——————————————————————————-</p>
<p>转自：<a href="http://blog.csdn.net/tecn14/article/details/24797545" target="_blank" rel="external">http://blog.csdn.net/tecn14/article/details/24797545</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++引用与指针]]></title>
      <url>https://shijingjing07.github.io/2016/05/11/C++%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88/</url>
      <content type="html"><![CDATA[<p>1.什么是引用<br>引用是某一对象（变量）的一个别名。<br>int m=0;<br>int &amp;n=m;<br>n=1;<br>cout&lt;&lt;”n “&lt;&lt;n&lt;&lt;endl;<br>cout&lt;&lt;”m “&lt;&lt;m&lt;&lt;endl;<br>&amp;表示n是m的引用，即别名，对n的任何操作就是对m的操作。<br>所以n既不是m的拷贝，也不是指向m的指针，其实n就是m它自己。<br>将n的值赋值为1,则m的值也变为1</p>
<p>2.什么是指针<br>指针用于指向对象（变量），指针存放的是对象（变量）的地址。<br>int m;<br>int *n=&amp;m;<br>指针n是一个指向int型变量m的指针。<br>&amp;是取地址操作符，&amp;m为m的地址。</p>
<p>3.引用和指针的联系和区别<br>1)都是有关地址的<br>引用是对象本身，而指针是对象的地址。<br>2)都是间接访问对象<br>3)都能用于函数参数和返回值传递<br>4)指针是一个实体，引用只是别名<br>指针会分配内存（4字节int型），引用不会<br>5)指针可变，引用不可变<br>指针指向的地址，其指向地址中存放的数据都是可变的<br>引用必须在一开始就被初始化，而且一旦和一个对象绑定后，就不能再改变（从一而终）。<br>6)指针可为空，引用不能。</p>
<p>4.函数参数和返回值传递方式<br>1)值引用<br>值传递过程中，被调用的形式参数作为被调函数函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个拷贝。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。</p>
<p>2)指针传递<br>指针传递本质上是值传递，只不过它传递的是一个地址值。我们可以用*操作符访问实参，从而对实参进行操作。</p>
<p>3)引用传递<br>引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址（不必通过*操作符），即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量（此时形参就是实参）。</p>
<p>5.从编译角度理解指针和引用<br>程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应的地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</p>
<p>6.引用不能const，指针能const,const的指针不可变</p>
<p>7.sizeof引用得到的是所指向的变量的大小，而sizeof指针得到的是指针本身的大小</p>
<p>8.指针和引用的自增(++)运算意义不一样。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux-ubuntu使用shadowsocks客户端配置]]></title>
      <url>https://shijingjing07.github.io/2016/05/10/linux-ubuntu%E4%BD%BF%E7%94%A8shadowsocks%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><p>之前介绍过用<a href="http://aitanlu.com/vps-bandwagonhost-openvpn-shadowsocks-
server.html" target="_blank" rel="external">搬瓦工的vps</a>可以轻松的搭建shadowsocks服务，然后在windows上和安卓手机平板等上轻松科学上网，只要下载对应的程序即可，当来到ubuntu上怎么配置shadowsocks来科学上网呢？有两种方法可行</p>
<p>1.安装shadowsocks命令行程序，配置命令。</p>
<p>2.安装shadowsocks GUI图形界面程序，配置。</p>
<p>个人推荐第一种，配置好后基本不用管。但使用的前提是 你的服务端已经搭建好或者你有别人提供的SS 服务（我也不知道该不该写这文章…）</p>
<h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><h3 id="ubuntu安装shadowsocks"><a href="#ubuntu安装shadowsocks" class="headerlink" title="ubuntu安装shadowsocks"></a>ubuntu安装shadowsocks</h3><p>用PIP安装很简单</p>
<p><code>apt-get install python-pip</code></p>
<p>接着安装shadowsocks</p>
<p><code>pip install shadowsocks</code></p>
<p>当然你在安装时候肯定有提示需要安装一些依赖比如python-setuptools m2crypto<br>，依照提示安装然后再安装就好。也可以网上搜索有很多教程的。</p>
<h3 id="启动shadowsocks"><a href="#启动shadowsocks" class="headerlink" title="启动shadowsocks"></a>启动shadowsocks</h3><p>安装好后，在本地我们要用到sslocal ，终端输入sslocal –help 可以查看帮助，像这样</p>
<p><img src="https://aitanlu.com/wp-content/uploads/2016/04/sslocal.png" alt="sslocal"></p>
<p>通过帮助提示我们知道各个参数怎么配置，比如 sslocal -c 后面加上我们的json配置文件，或者像下面这样直接命令参数写上运行。</p>
<p>比如 sslocal -s 11.22.33.44 -p 50003 -k “123456” -l 1080 -t 600 -m aes-256-cfb</p>
<p>-s表示服务IP, -p指的是服务端的端口，-l是本地端口默认是1080, -k 是密码（要加””）, -t超时默认300,-m是加密方法默认aes-256-cfb，</p>
<p><strong>为了方便我推荐直接用sslcoal -c 配置文件路径 这样的方式，简单好用。</strong></p>
<p>我们可以在/home/mudao/ 下新建个文件shadowsocks.json  (mudao是我在我电脑上的用户名，这里路径你自己看你的)。内容是这样：</p>
<ol>
<li><p><code>{</code></p>
</li>
<li><p><code>&quot;server&quot;:&quot;11.22.33.44&quot;,</code></p>
</li>
<li><p><code>&quot;server_port&quot;:50003,</code></p>
</li>
<li><p><code>&quot;local_port&quot;:1080,</code></p>
</li>
<li><p><code>&quot;password&quot;:&quot;123456&quot;,</code></p>
</li>
<li><p><code>&quot;timeout&quot;:600,</code></p>
</li>
<li><p><code>&quot;method&quot;:&quot;aes-256-cfb&quot;</code></p>
</li>
<li><p><code>}</code></p>
</li>
</ol>
<p>server  你服务端的IP<br>servier_port  你服务端的端口<br>local_port  本地端口，一般默认1080<br>passwd  ss服务端设置的密码<br>timeout  超时设置 和服务端一样<br>method  加密方法 和服务端一样</p>
<p>确定上面的配置文件没有问题，然后我们就可以在终端输入 sslocal -c /home/mudao/shadowsocks.json<br>回车运行。如果没有问题的话，下面会是这样…</p>
<p><img src="https://aitanlu.com/wp-
content/uploads/2016/04/sslocal-1.png" alt="sslocal">（如果继续请不要关闭这个终端）</p>
<p>如果你选择这一种请跳过第二种。你可以去系统的代理设置按照说明设置代理，但一般是全局的，<br>然而我们访问baidu,taobao等着些网站如果用代理就有点绕了，而且还会浪费服务器流量。我们最好配置我们的浏览器让它可以自动切换，该用代理用<br>代理该直接连接自动直接连接。所以请看配置浏览器。</p>
<h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><p>安装GUI 图形界面程序，然后按照提示配置相对应的参数。安装教程地址：<a href="https://github.com/shadowsocks/shadowsocks-
qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97" target="_blank" rel="external">shadowsocks-qt5<br>安装指南</a></p>
<p>在ubuntu上可以这样，通过PPA源安装，仅支持Ubuntu 14.04或更高版本。</p>
<ol>
<li><p><code>sudo add-apt-repository ppa:hzwhuang/ss-qt5</code></p>
</li>
<li><p><code>sudo apt-get update</code></p>
</li>
<li><p><code>sudo apt-get install shadowsocks-qt5</code></p>
</li>
</ol>
<p>由于是图形界面，配置和windows基本没啥差别就不赘述了。经过上面的配置，你只是启动了sslocal<br>但是要上网你还需要配置下浏览器到指定到代理端口比如1080才可以正式上网。</p>
<h2 id="配置浏览器"><a href="#配置浏览器" class="headerlink" title="配置浏览器"></a>配置浏览器</h2><p>假如你上面任选一种方式已经开始运行sslocal了，火狐那个代理插件老是订阅不了gfwlist所以配置自动模式的话不好使。这里用的是chrome，你可以在Ubuntu软件中心下载得到。</p>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>我们需要给chrome安装SwitchyOmega插件，但是没有代理之前是不能从谷歌商店安装这个插件的，但是我们可以从Github上直接下载最新版<br><a href="https://github.com/FelisCatus/SwitchyOmega/releases/" target="_blank" rel="external">https://github.com/FelisCatus/SwitchyOmega/releases/</a><br>（这个是chrome的）然后浏览器地址打开chrome://extensions/，将下载的插件托进去安装。</p>
<h3 id="设置代理地址"><a href="#设置代理地址" class="headerlink" title="设置代理地址"></a>设置代理地址</h3><p>安装好插件会自动跳到设置选项，有提示你可以跳过。左边新建情景模式-选择代理服务器-<br>比如命名为SS（叫什么无所谓）其他默认之后创建，之后在代理协议选择SOCKS5，地址为127.0.0.1,端口默认1080 。然后保存即应用选项。</p>
<p><img src="https://aitanlu.com/wp-
content/uploads/2016/04/shadowsocks-0.png" alt="shadowsocks-0"></p>
<p><img src="https://aitanlu.com/wp-
content/uploads/2016/04/shadowsocks-1.png" alt="shadowsocks-1"></p>
<h3 id="设置自动切换"><a href="#设置自动切换" class="headerlink" title="设置自动切换"></a>设置自动切换</h3><p>接着点击自动切换 ( Auto<br>switch）上面的不用管，在按照规则列表匹配请求后面选择刚才新建的SS，默认情景模式选择直接连接。点击应用选项保存。再往下规则列表设置选择AutoProxy<br>然后将<strong><a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="external">这个地址</a></strong>填进去，点击下面的立即更新情景模式，会有提示更新成功！</p>
<p><img src="https://aitanlu.com/wp-
content/uploads/2016/04/shadowsocks-2.png" alt="shadowsocks-2">sorry编辑图片时候少了一步，就是填好规则列表地址后先点击立即更新情景模式<br>后再应用选项保存</p>
<p><a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="external">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a></p>
<p>点击浏览器右上角的SwitchyOmega图标，下面选择自动切换，然后打开google.com试试，其他的就不在这贴图了。</p>
<p><img src="https://aitanlu.com/wp-
content/uploads/2016/04/shadowsocks-3.png" alt="shadowsocks-3"></p>
<h2 id="开机后台自动运行ss"><a href="#开机后台自动运行ss" class="headerlink" title="开机后台自动运行ss"></a>开机后台自动运行ss</h2><p>如果你选择了第二种可以不管这个</p>
<p>如果你上面可以代理上网了可以进行这一步，之前我让你不要关掉终端，因为关掉终端的时候代理就随着关闭了，之后你每次开机或者关掉终端之后，下次你再想用代理就要重新在终端输入这样的命令<br>sslocal  -c /home/mudao/shadowsocks.json ，挺麻烦是不？</p>
<p>我们现在可以在你的ubuntu上安装一个叫做supervisor的程序来管理你的sslocal启动。关于supervisor更多点击这</p>
<p><code>sudo apt-get install supervisor</code></p>
<p>安装好后我们可以在/etc/supervisor/目录下找到supervisor.conf配置文件，我们可以用以下命令来编辑</p>
<p><code>sudo gedit /etc/supervisor/supervisor.conf</code></p>
<p>在这个文件的最后加上以下内容</p>
<ol>
<li><p><code>[program:shadowsocks]</code></p>
</li>
<li><p><code>command=sslocal -c /home/mudao/shadowsocks.json</code></p>
</li>
<li><p><code>autostart=true</code></p>
</li>
<li><p><code>autorestart=true</code></p>
</li>
<li><p><code>user=root</code></p>
</li>
<li><p><code>log_stderr=true</code></p>
</li>
<li><p><code>logfile=/var/log/shadowsocks.log</code></p>
</li>
</ol>
<p>command = 这里json文件的路径根据你的文件路径来填写。确认无误后记得保存。sslocal 和ssserver这两个命令是被存在<br>/usr/local/bin/下面的，我们要拷贝一份命令文件到/bin</p>
<p><code>sudo cp /usr/local/bin/sslocal /bin</code>(注意空格)</p>
<p>现在关掉你之前运行sslocal命令的终端，再打开终端输入sudo service supervisor restart<br>然后去打开浏览器看看可不可以继续代理上网。你也可以用ps -ef|grep sslocal命令查看sslocal是否在运行。</p>
<p>这个时候我们需要在/etc下编辑一个叫rc.local的文件 ，让supervisor开机启动。</p>
<p><code>sudo gedit /etc/rc.local</code></p>
<p>在这个配置文件的exit 0前面一行加上 service supervisor start<br>保存。看你是否配置成功你可以在现在关机重启之后直接打开浏览器看是否代理成功。</p>
<p>转自：<a href="https://aitanlu.com/ubuntu-shadowsocks-ke-
hu-duan-pei-zhi.html" target="_blank" rel="external">linux-ubuntu使用shadowsocks客户端配置</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C--预处理指令]]></title>
      <url>https://shijingjing07.github.io/2016/05/06/C--%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>源代码在编译成机器指令之前，要进行预处理。预处理功能主要包括宏定义，文件包含，条件编译三部分。这些预处理操作发生在编译程序过程中，它们会修改程序的语句，但不会干涉程序的执行。<br>ANSI标准定义的C语言预处理程序包括下列命令：<br>指令 用途  </p>
<p>#include 包含一个源代码文件  </p>
<p>#define 定义宏  </p>
<p>#undef 取消已定义的宏  </p>
<p>#if 如果给定条件为真，则编译下面代码  </p>
<p>#ifdef 如果宏已经定义，则编译下面代码  </p>
<p>#ifndef 如果宏没有定义，则编译下面代码  </p>
<p>#elif 如果前面的#if给定条件不为真，当前条件为真，则编译下面代码  </p>
<p>#endif 结束一个#if……#else条件编译块  </p>
<p>#error 停止编译并显示错误信息  </p>
<p>#else 略  </p>
<p>#line 指令可以改变编译器用来指出警告和错误信息的文件号和行号。  </p>
<p>#pragma 设定编译器的状态或者是指示编译器完成一些特定的动作。  </p>
<p>#pragma指令稍复杂，格式一般为: #pragma para ，下面来看一些#pragma指令常用的参数。<br>(1)message 参数</p>
<p>message参数，能够在编译信息输出窗口中输出相应的信息，<br>这对于源代码信息的控制是非常重要的。其使用方法为：  </p>
<p>#pragma message(“消息文本”)<br>当编译器遇到这条指令时就在编译输出窗口中将消息文本打印出来。<br>当我们在程序中定义了许多宏来控制源代码版本的时候，我们自己有可能都会忘记有没有正确的设置这些宏，<br>此时我们可以用这条指令在编译的时候就进行检查。假设我们希望判断自己有没有在源代码的什么地方定义了_X86这个宏,<br>可以用下面的方法:  </p>
<p>#ifdef _X86  </p>
<p>#pragma message(“_X86 macro activated!”)  </p>
<p>#endif<br>我们定义了_X86这个宏以后，应用程序在编译时就会在编译输出窗口里显示”_86 macro activated!”。<br>我们就不会因为不记得自己定义的一些特定的宏而抓耳挠腮了。  </p>
<p>(2)另一个使用得比较多的pragma参数是code_seg</p>
<p>格式如：  </p>
<p>#pragma code_seg( [“section-name” [, “section-class”] ] )<br>它能够设置程序中函数代码存放的代码段，当我们开发驱动程序的时候就会使用到它。  </p>
<p>(3)#pragma once (比较常用)</p>
<p>只要在头文件的最开始加入这条指令就能够保证头文件被编译一次，这条指令实际上在VC6中就已经有了，<br>但是考虑到兼容性并没有太多的使用它。</p>
<p>(4)#pragma hdrstop</p>
<p>表示预编译头文件到此为止，后面的头文件不进行预编译。BCB可以预编译头文件以加快链接的速度，<br>但如果所有头文件都进行预编译又可能占太多磁盘空间，所以使用这个选项排除一些头文件。<br>有时单元之间有依赖关系，比如单元A依赖单元B，所以单元B要先于单元A编译。<br>你可以用#pragma startup指定编译优先级，如果使用了#pragma package(smart_init)，<br>BCB就会根据优先级的大小先后编译。</p>
<p>(5)#pragma resource “*.dfm”</p>
<p>表示把<em>.dfm文件中的资源加入工程。</em>.dfm中包括窗体<br>外观的定义。</p>
<p>(6)#pragma warning( disable: 4507 34; once: 4385; error: 164 )  </p>
<p>等价于：  </p>
<p>#pragma warning( disable: 4507 34 ) // 不显示4507和34号警告信息  </p>
<p>#pragma warning( once: 4385 ) // 4385号警告信息仅报告一次  </p>
<p>#pragma warning( error: 164 ) // 把164号警告信息作为一个错误。</p>
<p>同时这个pragma warning 也支持如下格式：  </p>
<p>#pragma warning( push [, n ] )  </p>
<p>#pragma warning( pop )<br>这里n代表一个警告等级(1—4)。  </p>
<p>#pragma warning( push )保存所有警告信息的现有的警告状态。  </p>
<p>#pragma warning( push, n )保存所有警告信息的现有的警告状态，并且把全局警告等级设定为n。  </p>
<p>#pragma warning( pop )向栈中弹出最后一个警告信息，在入栈和出栈之间所作的一切改动取消。例如：  </p>
<p>#pragma warning( push )  </p>
<p>#pragma warning( disable: 4705 )  </p>
<p>#pragma warning( disable: 4706 )  </p>
<p>#pragma warning( disable: 4707 )<br>//…….  </p>
<p>#pragma warning( pop )<br>在这段代码的最后，重新保存所有的警告信息(包括4705，4706和4707)。</p>
<p>(7)#pragma comment(…)</p>
<p>该指令将一个注释记录放入一个对象文件或可执行文件中。<br>常用的lib关键字，可以帮我们连入一个库文件。如：  </p>
<p>#pragma comment(lib, “comctl32.lib”)  </p>
<p>#pragma comment(lib, “vfw32.lib”)  </p>
<p>#pragma comment(lib, “wsock32.lib”)  </p>
<p>每个编译程序可以用#pragma指令激活或终止该编译程序支持的一些编译功能。</p>
<p>例如，对循环优化功能：  </p>
<p>#pragma loop_opt(on) // 激活  </p>
<p>#pragma loop_opt(off) // 终止</p>
<p>有时，程序中会有些函数会使编译器发出你熟知而想忽略的警告，<br>如”Parameter xxx is never used in function xxx”，可以这样：  </p>
<p>#pragma warn –100 // Turn off the warning message for warning #100<br>int insert_record(REC <em>r)<br>{ /</em> function body */ }  </p>
<p>#pragma warn +100 // Turn the warning message for warning #100 back on<br>函数会产生一条有唯一特征码100的警告信息，如此可暂时终止该警告。</p>
<p>每个编译器对#pragma的实现不同，在一个编译器中有效在别的编译器中几乎无效。可从编译器的文档中查看。</p>
<p>#pragma pack 与 内存对齐问题</p>
<p>许多实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k<br>(通常它为4或8)的倍数，这就是所谓的内存对齐，而这个k则被称为该数据类型的对齐模数(alignment modulus)。</p>
<p>Win32平台下的微软C编译器(cl.exe for 80x86)在默认情况下采用如下的对齐规则:<br>任何基本数据类型T的对齐模数就是T的大小，即sizeof(T)。比如对于double类型(8字节)，<br>就要求该类型数据的地址总是8的倍数，而char类型数据(1字节)则可以从任何一个地址开始。</p>
<p>Linux下的GCC奉行的是另外一套规则，任何2字节大小的数据类型(比如short)的对齐模数是2，而其它所有超过2字节的数据类型<br>(比如long,double)都以4为对齐模数。</p>
<p>ANSI C规定一种结构类型的大小是它所有字段的大小以及字段之间或字段尾部的填充区大小之和。<br>填充区就是为了使结构体字段满足内存对齐要求而额外分配给结构体的空间。那么结构体本身有什么对齐要求吗？<br>有的，ANSI C标准规定结构体类型的对齐要求不能比它所有字段中要求最严格的那个宽松，可以更严格。</p>
<p>如何使用c/c++中的对齐选项</p>
<p>vc6中的编译选项有 /Zp[1|2|4|8|16] ，/Zp1表示以1字节边界对齐，相应的，/Zpn表示以n字节边界对齐。<br>n字节边界对齐的意思是说，一个成员的地址必须安排在成员的尺寸的整数倍地址上或者是n的整数倍地址上，取它们中的最小值。<br>也就是：<br>min ( sizeof ( member ), n)</p>
<p>实际上，1字节边界对齐也就表示了结构成员之间没有空洞。<br>/Zpn选项是应用于整个工程的，影响所有的参与编译的结构。<br>要使用这个选项，可以在vc6中打开工程属性页，c/c++页，选择Code Generation分类，在Struct member<br>alignment可以选择。</p>
<p>要专门针对某些结构定义使用对齐选项，可以使用#pragma pack编译指令:</p>
<p>(1) #pragma pack( [ n ] )</p>
<p>该指令指定结构和联合成员的紧凑对齐。而一个完整的转换单元的结构和联合的紧凑对齐由/Zp 选项设置。<br>紧凑对齐用pack编译指示在数据说明层设置。该编译指示在其出现后的第一个结构或联合说明处生效。<br>该编译指示对定义无效。<br>当你使用#pragma pack ( n ) 时, 这里n 为1、2、4、8 或16。<br>第一个结构成员之后的每个结构成员都被存储在更小的成员类型或n 字节界限内。<br>如果你使用无参量的#pragma pack, 结构成员被紧凑为以/Zp 指定的值。该缺省/Zp 紧凑值为/Zp8 。</p>
<p>(2) 编译器也支持以下增强型语法:  </p>
<p>#pragma pack( [ [ { push | pop } , ] [ identifier, ] ] [ n] )</p>
<p>若不同的组件使用pack编译指示指定不同的紧凑对齐, 这个语法允许你把程序组件组合为一个单独的转换单元。<br>带push参量的pack编译指示的每次出现将当前的紧凑对齐存储到一个内部编译器堆栈中。<br>编译指示的参量表从左到右读取。如果你使用push, 则当前紧凑值被存储起来;<br>如果你给出一个n 的值, 该值将成为新的紧凑值。若你指定一个标识符, 即你选定一个名称,<br>则该标识符将和这个新的的紧凑值联系起来。</p>
<p>带一个pop参量的pack编译指示的每次出现都会检索内部编译器堆栈顶的值,并且使该值为新的紧凑对齐值。<br>如果你使用pop参量且内部编译器堆栈是空的,则紧凑值为命令行给定的值, 并且将产生一个警告信息。<br>若你使用pop且指定一个n的值, 该值将成为新的紧凑值。若你使用p o p 且指定一个标识符,<br>所有存储在堆栈中的值将从栈中删除, 直到找到一个匹配的标识符, 这个与标识符相关的紧凑值也从栈中移出,<br>并且这个仅在标识符入栈之前存在的紧凑值成为新的紧凑值。如果未找到匹配的标识符,<br>将使用命令行设置的紧凑值, 并且将产生一个一级警告。缺省紧凑对齐为8 。</p>
<p>pack编译指示的新的增强功能让你编写头文件, 确保在遇到该头文件的前后的<br>紧凑值是一样的。</p>
<p>(3) 栈内存对齐</p>
<p>在vc6中栈的对齐方式不受结构成员对齐选项的影响。它总是保持对齐，而且对齐在4字节边界上。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Yii2.0 权威指南]]></title>
      <url>https://shijingjing07.github.io/2016/05/05/Yii2.0%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<p>Yii 是一个高性能，基于组件的 PHP 框架，用于快速开发 Web 应用程序。</p>
<p>一、安装<br>1.Composer 安装<br>Composer是一个基于项目的依赖管理器，负责将PHP项目所依赖的包或库安装到项目所在的目录中<br>curl -sS <a href="https://getcomposer.org/installer" target="_blank" rel="external">https://getcomposer.org/installer</a> | php<br>mv composer.phar /usr/local/bin/composer</p>
<p>2.安装 Yii<br>安装 Composer asset plugin包管理插件<br>composer global require “fxp/composer-asset-plugin:~1.0.0”<br>安装Yii 到名为 basic 的目录中<br>composer create-project –prefer-dist yiisoft/yii2-app-basic basic<br>注：安装过程中会询问你的github身份令牌token,可在github设置中生成token,复制到这里。</p>
<p>将basic项目文件夹，copy到web服务器网页根目录下(/var/www/html),访问地址<a href="http://localhost/basic/web/index.php" target="_blank" rel="external">http://localhost/basic/web/index.php</a><br>出现以下界面，说明安装成功。</p>
<p><img src="http://www.yiichina.com/docs/guide/2.0/images/start-app-
installed.png" alt="Yii 安装成功"></p>
<p>二：Yii请求处理过程</p>
<p>应用中最重要的目录和文件（假设应用根目录是 basic）：</p>
<p>basic/ 应用根目录<br>　　composer.json Composer 配置文件, 描述包信息<br>　　config/ 包含应用配置及其它配置<br>　　　　console.php 控制台应用配置信息<br>　　　　web.php Web 应用配置信息<br>　　commands/ 包含控制台命令类<br>　　controllers/ 包含控制器类<br>　　models/ 包含模型类<br>　　runtime/ 包含 Yii 在运行时生成的文件，例如日志和缓存文件<br>　　vendor/ 包含已经安装的 Composer 包，包括 Yii 框架自身<br>　　views/ 包含视图文件<br>　　web/ Web 应用根目录，包含 Web 入口文件<br>　　　　assets/ 包含 Yii 发布的资源文件（javascript 和 css）<br>　　　　index.php 应用入口文件<br>　　yii Yii 控制台命令执行脚本  </p>
<hr>
<p>Yii 实现了模型-视图-控制器 (MVC)设计模式。 models 目录包含了所有模型类，views 目录包含了所有视图脚本，controllers<br>目录包含了所有控制器类。</p>
<p>以下图表展示了一个应用的静态结构：</p>
<p><img src="http://www.yiichina.com/docs/guide/2.0/images/application-
structure.png" alt="应用静态结构"></p>
<p>每个应用都有一个入口脚本 web/index.php，这是整个应用中唯一可以访问的 PHP 脚本。入口脚本接受一个 Web 请求并创建应用实例去处理它。<br>应用在它的组建辅助下解析请求，并分派请求至 MVC 元素。视图使用小部件去创建复杂和动态的用户界面。</p>
<p>请求生命周期</p>
<p>以下图表展示了一个应用如何处理请求：</p>
<p><img src="http://www.yiichina.com/docs/guide/2.0/images/request-lifecycle.png" alt="请求生命周期"></p>
<p>1.用户向入口脚本 web/index.php 发起请求。<br>2.入口脚本加载应用配置并创建一个应用实例去处理请求。<br>3.应用通过请求组件解析请求的路由。<br>4.应用创建一个控制器实例去处理请求。<br>5.控制器创建一个操作实例并针对操作执行过滤器。<br>6.如果任何一个过滤器返回失败，则操作退出。<br>7.如果所有过滤器都通过，操作将被执行。<br>8.操作会加载一个数据模型，或许是来自数据库。<br>9.操作会渲染一个视图，把数据模型提供给它。<br>10.渲染结果返回给响应组件。<br>11.响应组件发送渲染结果给用户浏览器。</p>
<p>参考资料：<a href="http://www.yiichina.com/doc/guide/2.0" target="_blank" rel="external">http://www.yiichina.com/doc/guide/2.0</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++ Dll 编写入门]]></title>
      <url>https://shijingjing07.github.io/2016/04/26/C++%20Dll%20%E7%BC%96%E5%86%99%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>一、前言  </p>
<p>　　自从微软推出16位的Windows操作系统起，此后每种版本的Windows操作系统都非常依赖于动态链接库(DLL)中的函数和数据，实际上<br>Windows操作系统中几乎所有的内容都由DLL以一种或另外一种形式代表着，例如显示的字体和图标存储在GDI<br>DLL中、显示Windows桌面和处理用户的输入所需要的代码被存储在一个User DLL中、Windows编程所需要的大量的API函数也被包含在Kernel<br>DLL中。  </p>
<p>在Windows操作系统中使用DLL有很多优点，最主要的一点是多个应用程序、甚至是不同语言编写的应用程序可以共享一个DLL文件，真正实现了资源”共享”，大大缩小了应用程序的执行代码，更加有效的利用了内存；使用DLL的另一个优点是DLL文件作为一个单独的程序模块，封装性、独立性好，在软件需要升级的时候，开发人员只需要修改相应的DLL文件就可以了，而且，当DLL中的函数改变后，只要不是参数的改变,程序代码并不需要重新编译。这在编程时十分有用，大大提高了软件开发和维护的效率。  </p>
<p>既然DLL那么重要，所以搞清楚什么是DLL、如何在Windows操作系统中开发使用DLL是程序开发人员不得不解决的一个问题。本文针对这些问题，通过一个简单的例子，即在一个DLL中实现比较最大、最小整数这两个简单函数，全面地解析了在Visual<br>C++编译环境下编程实现DLL的过程，文章中所用到的程序代码在Windows98系统、Visual C++6.0编译环境下通过。  </p>
<p>　　二、DLL的概念  </p>
<p>DLL是建立在客户/服务器通信的概念上，包含若干函数、类或资源的库文件，函数和数据被存储在一个DLL（服务器）上并由一个或多个客户导出而使用，这些客户可以是应用程序或者是其它的DLL。DLL库不同于静态库，在静态库情况下，函数和数据被编译进一个二进制文件（通常扩展名为*.LIB），<br>Visual<br>C++的编译器在处理程序代码时将从静态库中恢复这些函数和数据并把他们和应用程序中的其他模块组合在一起生成可执行文件。这个过程称为”静态链接”，此时因为应用程序所需的全部内容都是从库中复制了出来，所以静态库本身并不需要与可执行文件一起发行。  </p>
<p>在动态库的情况下，有两个文件，一个是引入库（.LIB）文件，一个是DLL文件，引入库文件包含被DLL导出的函数的名称和位置，DLL包含实际的函数和数据，应用程序使用LIB文件链接到所需要使用的DLL文件，库中的函数和数据并不复制到可执行文件中，因此在应用程序的可执行文件中，存放的不是被调用的函数代码，而是DLL中所要调用的函数的内存地址，这样当一个或多个应用程序运行是再把程序代码和被调用的函数代码链接起来，从而节省了内存资源。从上面的说明可以看出，DLL和.LIB文件必须随应用程序一起发行，否则应用程序将会产生错误。  </p>
<p>　　微软的Visual C++支持三种DLL，它们分别是Non-MFC Dll（非MFC动态库）、Regular Dll（常规DLL）、Extension<br>Dll（扩展DLL）。Non-MFC<br>DLL指的是不用MFC的类库结构，直接用C语言写的DLL，其导出的函数是标准的C接口，能被非MFC或MFC编写的应用程序所调用。Regular<br>DLL:和下述的Extension<br>Dlls一样，是用MFC类库编写的，它的一个明显的特点是在源文件里有一个继承CWinApp的类（注意：此类DLL虽然从CWinApp派生，但没有消息循环）,被导出的函数是C函数、C++类或者C++成员函数（注意不要把术语C++类与MFC的微软基础C++类相混淆），调用常规DLL的应用程序不必是MFC应用程序，只要是能调用类C函数的应用程序就可以，它们可以是在Visual<br>C++、Dephi、Visual Basic、Borland C等编译环境下利用DLL开发应用程序。  </p>
<p>常规DLL又可细分成静态链接到MFC和动态链接到MFC上的，这两种常规DLL的区别将在下面介绍。与常规DLL相比，使用扩展DLL用于导出增强MFC基础类的函数或子类，用这种类型的动态链接库，可以用来输出一个从MFC所继承下来的类。  </p>
<p>扩展DLL是使用MFC的动态链接版本所创建的，并且它只被用MFC类库所编写的应用程序所调用。例如你已经创建了一个从MFC的CtoolBar类的派生类用于创建一个新的工具栏，为了导出这个类，你必须把它放到一个MFC扩展的DLL中。扩展DLL<br>和常规DLL不一样，它没有一个从CWinApp继承而来的类的对象，所以，开发人员必须在DLL中的DllMain函数添加初始化代码和结束代码。<br>三、动态链接库的创建  </p>
<p>　　在Visual C++6.0开发环境下，打开File\New\Project选项，可以选择Win32 Dynamic-Link Library或MFC<br>AppWizard[dll]来以不同的方式来创建Non-MFC Dll、Regular Dll、Extension Dll等不同种类的动态链接库。  </p>
<p>　　1． Win32 Dynamic-Link Library方式创建Non-MFC DLL动态链接库  </p>
<p>　　每一个DLL必须有一个入口点，这就象我们用C编写的应用程序一样，必须有一个WINMAIN函数一样。在Non-MFC<br>DLL中DllMain是一个缺省的入口函数，你不需要编写自己的DLL入口函数，用这个缺省的入口函数就能使动态链接库被调用时得到正确的初始化。如果应用程序的DLL需要分配额外的内存或资源时，或者说需要对每个进程或线程初始化和清除操作时，需要在相应的DLL工程的.CPP文件中对DllMain<br>()函数按照下面的格式书写。  </p>
<p>BOOL APIENTRY DllMain(HANDLE hModule,DWORD ul_reason_for_call,LPVOID<br>lpReserved)<br>{<br>switch( ul_reason_for_call )<br>{<br>case DLL_PROCESS_ATTACH:<br>…….<br>case DLL_THREAD_ATTACH:<br>…….<br>case DLL_THREAD_DETACH:<br>…….<br>case DLL_PROCESS_DETACH:<br>…….<br>}<br>return TRUE;<br>}  </p>
<p>　　参数中，hMoudle是动态库被调用时所传递来的一个指向自己的句柄(实际上，它是指向_DGROUP段的一个选择符)；<br>ul_reason_for_call是一个说明动态库被调原因的标志，当进程或线程装入或卸载动态链接库的时候，操作系统调用入口函数，并说明动态链接库被调用的原因，它所有的可能值为：DLL_PROCESS_ATTACH:<br>进程被调用、DLL_THREAD_ATTACH: 线程被调用、DLL_PROCESS_DETACH: 进程被停止、DLL_THREAD_DETACH:<br>线程被停止；lpReserved为保留参数。到此为止，DLL的入口函数已经写了，剩下部分的实现也不难，你可以在DLL工程中加入你所想要输出的函数或变量了。  </p>
<p>我们已经知道DLL是包含若干个函数的库文件，应用程序使用DLL中的函数之前，应该先导出这些函数，以便供给应用程序使用。要导出这些函数有两种方法，一是在定义函数时使用导出关键字_declspec(dllexport)，另外一种方法是在创建DLL文件时使用模块定义文件.Def。需要读者注意的是在使用第一种方法的时候，不能使用DEF文件。下面通过两个例子来说明如何使用这两种方法创建DLL文件。  </p>
<p>1）使用导出函数关键字_declspec(dllexport)创建MyDll.dll，该动态链接库中有两个函数，分别用来实现得到两个数的最大和最小数。在MyDll.h和MyDLL.cpp文件中分别输入如下原代码：  </p>
<p>//MyDLL.h<br>extern “C” _declspec(dllexport) int Max(int a, int b);<br>extern “C” _declspec(dllexport) int Min(int a, int b);<br>//MyDll.cpp  </p>
<p>#include  </p>
<p>#include”MyDll.h”<br>int Max(int a, int b)<br>{<br>if(a&gt;=b)return a;<br>else<br>return b;<br>}<br>int Min(int a, int b)<br>{<br>if(a&gt;=b)return b;<br>else<br>return a;<br>}  </p>
<p>　　该动态链接库编译成功后，打开MyDll工程中的debug目录，可以看到MyDll.dll、MyDll.lib两个文件。LIB文件中包含DLL<br>文件名和DLL文件中的函数名等，该LIB文件只是对应该DLL文件的”映像文件”，与DLL文件中，LIB文件的长度要小的多，在进行隐式链接DLL时要用到它。读者可能已经注意到在MyDll.h中有关键字”extern<br>C”，它可以使其他编程语言访问你编写的DLL中的函数。  </p>
<p>　　2）用.def文件创建工程MyDll  </p>
<p>　　为了用.def文件创建DLL，请先删除上个例子创建的工程中的MyDll.h文件，保留MyDll.cpp并在该文件头删除#include<br>MyDll.h语句，同时往该工程中加入一个文本文件，命名为MyDll.def，再在该文件中加入如下代码：  </p>
<p>LIBRARY MyDll  //注意这里的MyDll是工程名如果不同则应用程序连接库时会发生连接错误<br>EXPORTS<br>Max @1,<br>Min @2,  </p>
<p>　　其中LIBRARY语句说明该def文件是属于相应DLL的，EXPORTS语句下列出要导出的函数名称。我们可以在.def文件中的导出函数后加<br>@n，如Max@1，Min@2，表示要导出的函数顺序号，在进行显式连时可以用到它。该DLL编译成功后，打开工程中的Debug目录，同样也会看到<br>MyDll.dll和MyDll.lib文件。  </p>
<p>　　2．MFC AppWizard[dll]方式生成常规/扩展DLL  </p>
<p>　　在MFC<br>AppWizard[dll]下生成DLL文件又有三种方式，在创建DLL是，要根据实际情况选择创建DLL的方式。一种是常规DLL静态链接到MFC，另一种是常规DLL动态链接到MFC。两者的区别是：前者使用的是MFC的静态链接库，生成的DLL文件长度大，一般不使用这种方式，后者使用MFC的动态链接库，生成的DLL文件长度小；动态链接到MFC的规则DLL所有输出的函数应该以如下语句开始：  </p>
<p>AFX_MANAGE_STATE(AfxGetStaticModuleState( )) //此语句用来正确地切换MFC模块状态  </p>
<p>　　最后一种是MFC扩展DLL，这种DLL特点是用来建立MFC的派生类，Dll只被用MFC类库所编写的应用程序所调用。前面我们已经介绍过，<br>Extension DLLs 和Regular<br>DLLs不一样，它没有一个从CWinApp继承而来的类的对象，编译器默认了一个DLL入口函数DLLMain()作为对DLL的初始化，你可以在此函数中实现初始化,代码如下：  </p>
<p>BOOL WINAPI APIENTRY DLLMain(HINSTANCE hinstDll，DWORD reason ，LPVOID flmpload)<br>{<br>switch(reason)<br>{<br>……………//初始化代码；<br>}<br>return true;<br>}  </p>
<p>参数hinstDll存放DLL的句柄，参数reason指明调用函数的原因，lpReserved是一个被系统所保留的参数。对于隐式链接是一个非零值，对于显式链接值是零。  </p>
<p>　　在MFC下建立DLL文件，会自动生成def文件框架，其它与建立传统的Non-MFC<br>DLL没有什么区别，只要在相应的头文件写入关键字_declspec(dllexport)函数类型和函数名等，或在生成的def文件中EXPORTS<br>下输入函数名就可以了。需要注意的是在向其它开发人员分发MFC扩展DLL<br>时，不要忘记提供描述DLL中类的头文件以及相应的.LIB文件和DLL本身，此后开发人员就能充分利用你开发的扩展DLL了。<br>四、动态链接库DLL的链接  </p>
<p>　　应用程序使用DLL可以采用两种方式：一种是隐式链接，另一种是显式链接。在使用DLL之前首先要知道DLL中函数的结构信息。Visual<br>C++6.0在VC\bin目录下提供了一个名为Dumpbin.exe的小程序，用它可以查看DLL文件中的函数结构。另外，Windows系统将遵循下面的搜索顺序来定位DLL：<br>1．包含EXE文件的目录，2．进程的当前工作目录，3．Windows系统目录， 4．Windows目录，5．列在Path环境变量中的一系列目录。  </p>
<p>　　1．隐式链接  </p>
<p>　　隐式链接就是在程序开始执行时就将DLL文件加载到应用程序当中。实现隐式链接很容易，只要将导入函数关键字_declspec<br>(dllimport)函数名等写到应用程序相应的头文件中就可以了。下面的例子通过隐式链接调用MyDll.dll库中的Min函数。首先生成一个项目为TestDll，在DllTest.h、DllTest.cpp文件中分别输入如下代码：  </p>
<p>//Dlltest.h  </p>
<p>#pragma comment(lib，”MyDll.lib”)<br>extern “C”_declspec(dllimport) int Max(int a,int b);<br>extern “C”_declspec(dllimport) int Min(int a,int b);<br>//TestDll.cpp  </p>
<p>#include  </p>
<p>#include”Dlltest.h”<br>void main()<br>{int a;<br>a=min(8,10)<br>printf(“比较的结果为%d\n”，a);<br>}  </p>
<p>//注意如果程序发生连接错误则要把lib文件加要工程里去  </p>
<p>　　在创建DllTest.exe文件之前，要先将MyDll.dll和MyDll.lib拷贝到当前工程所在的目录下面，也可以拷贝到windows的<br>System目录下。如果DLL使用的是def文件，要删除TestDll.h文件中关键字extern “C”。TestDll.h文件中的关键字Progam<br>commit是要Visual C+的编译器在link时，链接到MyDll.lib文件，当然，开发人员也可以不使用#pragma<br>comment(lib，”MyDll.lib”)语句，而直接在工程的Setting-&gt;Link页的Object/Moduls栏填入<br>MyDll.lib既可。  </p>
<p>　　2．显式链接  </p>
<p>显式链接是应用程序在执行过程中随时可以加载DLL文件，也可以随时卸载DLL文件，这是隐式链接所无法作到的，所以显式链接具有更好的灵活性，对于解释性语言更为合适。不过实现显式链接要麻烦一些。在应用程序中用LoadLibrary或MFC提供的AfxLoadLibrary显式的将自己所做的动态链接库调进来，动态链接库的文件名即是上述两个函数的参数，此后再用GetProcAddress()获取想要引入的函数。自此，你就可以象使用如同在应用程序自定义的函数一样来调用此引入函数了。在应用程序退出之前，应该用FreeLibrary或MFC提供的AfxFreeLibrary释放动态链接库。下面是通过显式链接调用DLL中的Max函数的例子。  </p>
<p>#include  </p>
<p>#include<br>void main(void)<br>{<br>typedef int(<em>pMax)(int a,int b);<br>typedef int(</em>pMin)(int a,int b);<br>HINSTANCE hDLL;<br>PMax Max<br>HDLL=LoadLibrary(“MyDll.dll”);//加载动态链接库MyDll.dll文件；<br>Max=(pMax)GetProcAddress(hDLL,”Max”);<br>A=Max(5,8);<br>Printf(“比较的结果为%d\n”，a);<br>FreeLibrary(hDLL);//卸载MyDll.dll文件；<br>}  </p>
<p>在上例中使用类型定义关键字typedef，定义指向和DLL中相同的函数原型指针，然后通过LoadLibray()将DLL加载到当前的应用程序中并返回当前DLL文件的句柄，然后通过GetProcAddress()函数获取导入到应用程序中的函数指针，函数调用完毕后，使用<br>FreeLibrary()卸载DLL文件。在编译程序之前，首先要将DLL文件拷贝到工程所在的目录或Windows系统目录下。  </p>
<p>　　使用显式链接应用程序编译时不需要使用相应的Lib文件。另外，使用GetProcAddress()函数时，可以利用<br>MAKEINTRESOURCE()函数直接使用DLL中函数出现的顺序号，如将GetProcAddress(hDLL,”Min”)改为<br>GetProcAddress(hDLL,<br>MAKEINTRESOURCE(2))（函数Min()在DLL中的顺序号是2），这样调用DLL中的函数速度很快，但是要记住函数的使用序号，否则会发生错误。  </p>
<p>本文通过通俗易懂的方式，全面介绍了动态链接库的概念、动态链接库的创建和动态链接库的链接，并给出个简单明了的例子，相信读者看了本文后，能够创建自己的动态链接库并应用到后续的软件开发当中去了，当然，读者要熟练操作DLL，还需要在大量的实践中不断摸索，希望本文能起到抛砖引玉的作用。</p>
<pre><code>转自：&lt;http://www.cnblogs.com/daocaoren/archive/2012/05/30/2526495.html&gt;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在Windows上开发PHP扩展模块]]></title>
      <url>https://shijingjing07.github.io/2016/04/26/%E5%9C%A8Windows%E4%B8%8A%E5%BC%80%E5%8F%91PHP%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<p>环境: window + php + apache + vc6 + cygwin</p>
<p>下载：php二进制文件： php-5.3.10-Win32-VC9-x86<br>        php源码包：php-5.3.10</p>
<p><strong>操作第一步:</strong><br>PHP源代码生成 main/config.w32.h<br>详见：<a href="http://www.cnblogs.com/shijingjing07/p/5420902.html" target="_blank" rel="external">http://www.cnblogs.com/shijingjing07/p/5420902.html</a></p>
<p><strong>操作第二步:</strong><br>把PHP二进制根目录加入到环境变量下。在cmd命令行,进入PHP源码包中ext文件下。<br>执行php ext_skel_win32.php –extname=test命令生成扩展骨架。</p>
<p>把PHP二进制包中dev目录php5ts.lib文件复制到你扩展目录test中。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201604/300946-20160426142103533-311736746.png" alt=""></p>
<p>命令执行后,生成如下图示的文件:</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201604/300946-20160426142808830-541720256.png" alt=""></p>
<p><strong>操作第三步:</strong></p>
<p>编辑php_test.h内容,找到:</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201604/300946-20160426142936267-2055583038.png" alt=""></p>
<pre><code>在下面编写:
</code></pre><p>   PHP_FUNCTION(hello);   //添加方法</p>
<p>编辑test.c内容,找到:  </p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201604/300946-20160426143000236-1532883051.png" alt=""></p>
<pre><code>在里面添加你的要的添加的方法:

   PHP_FE(hello,NULL)  //最好的跟上面写的一样。

   变为:
</code></pre><p><img src="http://images2015.cnblogs.com/blog/300946/201604/300946-20160426143019455-258945384.png" alt=""></p>
<pre><code>再找到:
</code></pre><p><img src="http://images2015.cnblogs.com/blog/300946/201604/300946-20160426143039877-726059326.png" alt=""></p>
<p>在下面实现你的方法:</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201604/300946-20160426143101595-1915175175.png" alt=""></p>
<pre><code>简单些。你我需要更深入php内核才能写好的php扩展。
</code></pre><p><strong>操作第四步:</strong></p>
<p> 接下来就是对扩展文件进行编译。</p>
<p> 进入扩展的目录，执行以下命令。</p>
<p>  msdev test.dsp /MAKE “test - Win32 Release_TS”  //命令</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201604/300946-20160426143153830-836596253.png" alt=""></p>
<p>如果没有错误,在D:/PHP目录中会产生一个Release_TS目录,php_test.dll就在其中。</p>
<p><strong>操作第五步:</strong></p>
<p>把php_test.dll复制到二进制PHP中的etc文件中.</p>
<pre><code> 修改php.ini文件,添加extension=php_test.dll文件。

 重启服务。

 &amp;lt;?php

       echo hello();//test

?&amp;gt;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[windows下apache+php+mysql 环境配置方法]]></title>
      <url>https://shijingjing07.github.io/2016/04/25/windows%E4%B8%8Bapache+php+mysql%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>转自：<a href="http://www.jb51.net/article/30128.htm" target="_blank" rel="external">http://www.jb51.net/article/30128.htm</a></p>
<p><strong>一 准备</strong><br>1 下载apache <a href="http://httpd.apache.org/download.cgi#apache24" target="_blank" rel="external">http://httpd.apache.org/download.cgi#apache24</a><br>httpd-2.2.22-win32-x86-openssl-0.9.8t.msi  </p>
<p>openssl表示带有openssl模块，利用openssl可给Apache配置SSL安全链接  </p>
<p>2 下载php <a href="http://windows.php.net/downloads/releases/archives/" target="_blank" rel="external">http://windows.php.net/downloads/releases/archives/</a><br>php-5.3.5-Win32-VC6-x86.zip  </p>
<p>下载vc6版本<br>VC6:legacy Visual Studio 6 compiler，就是使用这个编译器编译的。  </p>
<p>VC9:the Visual Studio 2008 compiler，就是用微软的VS编辑器编译的。  </p>
<p>3 下载mysql <a href="http://mysql.llarian.net/Downloads/MySQL-5.5/mysql-5.5.23-winx64.msi" target="_blank" rel="external">http://mysql.llarian.net/Downloads/MySQL-5.5/mysql-5.5.23-winx64.msi</a></p>
<p><strong>二 安装</strong><br>1 apache 比较简单,一路next完成.</p>
<p><img src="http://files.jb51.net/upload/201204/20120419200854919.png" alt="image"></p>
<p>浏览器验证,出现一下页面,成功</p>
<p><img src="http://files.jb51.net/upload/201204/20120419200856377.png" alt="image"></p>
<p>2 php安装</p>
<p>下载zip包,直接解压到一个目录,目录重命名为php</p>
<p><img src="http://files.jb51.net/upload/201204/20120419200856628.png" alt="image"></p>
<p>3 mysql<br>略</p>
<p>三 配置<br>php配置<br>php.ini-development 文件重命名为 php.ini<br>指定PHP扩展包的具体目录，以便调用相应的DLL文件</p>
<pre><code>; Directory in which the loadable extensions (modules) reside. 
; http://php.net/extension-dir 
; extension_dir = &quot;./&quot; 
; On windows: 
; extension_dir = &quot;ext&quot; 
</code></pre><p>修改为</p>
<pre><code>; Directory in which the loadable extensions (modules) reside. 
; http://php.net/extension-dir 
; extension_dir = &quot;./&quot; 
; On windows: 
extension_dir = &quot;D:/servers/php/ext&quot; 
</code></pre><p>去掉以下配置注释,支持mysql</p>
<p>代码如下:</p>
<pre><code>extension=php_curl.dll 
extension=php_gd2.dll 
extension=php_mysql.dll 
extension=php_pdo_mysql.dll 
extension=php_pdo_odbc.dll 
</code></pre><p>支持session</p>
<pre><code>session.save_path = &quot;e:/temp&quot; 
</code></pre><p>上传文件目录配置</p>
<pre><code>upload_tmp_dir =&quot;e:/temp&quot; 
</code></pre><p>时区配置</p>
<pre><code>date.timezone =Asia/Shanghai 
</code></pre><p>apache配置</p>
<p>进入apache安装目录，打开配置文件 /conf/httpd.conf<br>在#LoadModule vhost_alias_module modules/mod_vhost_alias.so下添加</p>
<pre><code>LoadModule php5_module &quot;e:/servers/php/php5apache2_2.dll&quot; 
PHPIniDir &quot;e:/servers/php&quot; 
AddType application/x-httpd-php .php .html .htm 
</code></pre><p> web主目录修改</p>
<pre><code>DocumentRoot &quot;D:/servers/Apache2.2/htdocs&quot; 
</code></pre><p>改为</p>
<pre><code>DocumentRoot &quot;D:/servers/phpweb&quot; 
</code></pre><p>代码如下:</p>
<pre><code>&lt;Directory &quot;D:/servers/Apache2.2/htdocs&quot;&gt; 
</code></pre><p>改为</p>
<pre><code>&lt;Directory &quot;D:/phpweb&quot;&gt; 
</code></pre><p>代码如下:</p>
<pre><code>&lt;IfModule dir_module&gt; 
DirectoryIndex index.html 
&lt;/IfModule&gt; 
</code></pre><p> 改为</p>
<pre><code>&lt;IfModule dir_module&gt; 
DirectoryIndex index.php index.html 
&lt;/IfModule&gt; 
</code></pre><p>重启apache  </p>
<p>mysql配置<br>略<br>四 测试<br>建立phpweb目录 D:\servers\phpweb</p>
<p>创建测试文件 index.php</p>
<pre><code>&lt;?php 
phpinfo(); 
?&gt; 
</code></pre><p>浏览:<a href="http://localhost" target="_blank" rel="external">http://localhost</a><br>显示如下信息,说明配置成功:</p>
<p><img src="http://files.jb51.net/upload/201204/20120419200857735.png" alt="image"></p>
<p>创建mysql连接测试文件</p>
<pre><code>&lt;?php 
$connect=mysql_connect(&quot;10.71.196.147&quot;,&quot;user&quot;,&quot;&quot;); 
if(!$connect) echo &quot;Mysql Connect Error!&quot;; 
else echo &quot;mysql 连接成功&quot;; 
mysql_close(); 
?&gt; 
</code></pre><p>浏览:<a href="http://localhost/mysqltest.php" target="_blank" rel="external">http://localhost/mysqltest.php</a> 测试mysql连接</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu搭建LAMP环境]]></title>
      <url>https://shijingjing07.github.io/2016/04/23/Ubuntu%E6%90%AD%E5%BB%BALAMP%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<p><strong>安装过程</strong></p>
<p><em>  
</em>第一步 安装Apache2<br>sudo apt-get install apache2</p>
<p>第二步 安装PHP模块<br>sudo apt-get install php5</p>
<p>第三步 安装Mysql<br>sudo apt-get install mysql-server<br>sudo apt-get install mysql-client</p>
<p>第四步 其他模块安装<br>sudo apt-get install libapache2-mod-php5<br>sudo apt-get install libapache2-mod-auth-mysql<br>sudo apt-get install php5-mysql<br>sudo apt-get install php5-gd</p>
<p>第五步 测试Apache是否正常工作<br>打开浏览器，输入localhost，看看是否有It Works!网页展示。目录为/var/www</p>
<p>第六步 修改权限/var/www<br>sudo chmod 777 /var/www</p>
<p>第七步 安装phpmyadmin<br>sudo apt-get install phpmyadmin<br>安装过程中选择apache2，点击确定。下一步选择是要配置数据库，并输入密码。</p>
<p>第八步 测试phpmyadmin<br>sudo ln -s /usr/share/phpmyadmin /var/www<br>然后直接运行<a href="http://localhost/phpmyadmin，看有没有数据库管理软件出现。" target="_blank" rel="external">http://localhost/phpmyadmin，看有没有数据库管理软件出现。</a></p>
<p><strong>配置过程</strong>  </p>
<p>第一步 启用mod_rewrite模块<br>sudo a2enmod rewrite<br>重启Apache服务器：sudo /etc/init.d/apache2 restart或者sudo service apache2 restart</p>
<p>第二步 设置Apache支持.htm .html .php<br>sudo gedit /etc/apache2/apache2.conf&amp;<br>添加以下句子：AddType application/x-httpd-php .php .htm .html</p>
<p>第三步 测试php网页<br>编辑mysql_test.php代码如下：<br>&lt;?php<br>$link = mysql_connect(“localhost”, “root”, “password”);<br>if(!$link)<br>die(‘Could not connect: ‘ . mysql_error());<br>else<br>echo “Mysql 配置正确!”;<br>mysql_close($link);<br>?&gt;<br>访问 <a href="http://localhost/mysql_test.php" target="_blank" rel="external">http://localhost/mysql_test.php</a> 显示’Mysql 配置正确’就代表配置正确。</p>
<p>第四步 第三步这里出现了乱码以后解决方法<br>打开配置文件sudo gedit /etc/apache2/apache2.conf&amp;<br>添加如下代码：AddDefaultCharset UTF-8<br>到此为止配置OK。</p>
<p>转自：<a href="http://blog.csdn.net/callmeback/article/details/8130190" target="_blank" rel="external">http://blog.csdn.net/callmeback/article/details/8130190</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[go--Ubuntu下安装GO LANG，测试输入hello world]]></title>
      <url>https://shijingjing07.github.io/2016/04/20/go--Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85GO%20LANG%EF%BC%8C%E6%B5%8B%E8%AF%95%E8%BE%93%E5%85%A5hello%20world/</url>
      <content type="html"><![CDATA[<p>1.下载go语言源码，<a href="https://storage.googleapis.com/golang/go1.6.1.linux-amd64.tar.gz" target="_blank" rel="external">https://storage.googleapis.com/golang/go1.6.1.linux-amd64.tar.gz</a></p>
<p>2.解压缩源码包<br>tar zxvf go1.6.1.linux-amd64.tar.gz</p>
<p>3.移动源码包到安装目录<br>sudo mv go /usr/local/go  </p>
<p>4.设置系统环境变量<br>sudo vi /etc/profile</p>
<p>在文件最后添加如下代码<br>export GOROOT=/usr/local/go<br>export GOBIN=$GOROOT/bin<br>export GOPKG=$GOROOT/pkg/tool/linux_amd64<br>export GOARCH=amd64<br>export GOOS=linux<br>export PATH=.:$PATH:$GOBIN:$GOPKG</p>
<p>编译，使环境变量生效<br>source /etc/profile</p>
<p>5.测试安装是否成功<br>go version<br>go version go1.6.1 linux/amd64</p>
<p>6.代码测试，输入”hello world”<br>package main<br>import “fmt”<br>func main(){<br>fmt.Printf(“Hello World!\n”)<br>}</p>
<p>输出：Hello World!</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[posix多线程--线程私有数据]]></title>
      <url>https://shijingjing07.github.io/2016/04/18/posix%E5%A4%9A%E7%BA%BF%E7%A8%8B--%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<p>1.当多个线程共享一个变量时，将该变量定义为静态或外部变量，使用互斥量确保共享变量的安全访问。<br>如果每个线程都需要一个私有变量值，则该值成为线程的私有数据。程序创建一个键，每个线程独立地设定或得到自己的键值，各线程间私有数据互不影响。</p>
<p>2.建立线程私有数据<br>int pthread_key_create(pthread_key_t <em>key,void (</em>destructor)(void <em>));<br>int pthread_key_delete(pthread_key_t key);<br>int pthread_setspecific(pthread_key_t key,void </em>value);<br>void *pthread_getspecific(pthread_key_t key);</p>
<p>私有数据键，若多次创建，会覆盖掉前面创建的键，对应的键值也将永远丢失。</p>
<p>使用pthread_key_delete释放一个私有数据键时，必须保证所有线程都不在持有该键的值。<br>更好的做法是不释放线程私有数据键，因为线程私有数据键最多可达128个，很少有程序需要这么多的树木，没有必要手动释放。</p>
<p>代码示例如下：<br>创建数据键，设置键值，获取键值</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<pre><code>#include&lt;stdio.h&gt;                                                                
#include&lt;pthread.h&gt;
typedef struct tsd_tag
{
        pthread_t tid;
        char *string;
}tsd_t;
pthread_key_t tsd_key;
pthread_once_t key_once = PTHREAD_ONCE_INIT;
void one_routine(void)
{
        pthread_key_create(&amp;tsd_key,NULL);;
}
void *thread_routine(void *arg)
{
        pthread_once(&amp;key_once,one_routine);
        tsd_t *value;
        value = (tsd_t*)malloc(sizeof(tsd_t));
        pthread_setspecific(tsd_key,value);
        value-&gt;tid = pthread_self();
        value-&gt;string = (char*)arg;
        value=(tsd_t*)pthread_getspecific(tsd_key);
        sleep(2);
        value=(tsd_t*)pthread_getspecific(tsd_key);
        printf(&quot;%s done...\n&quot;,value-&gt;string);
}
int main(void)
{
        pthread_t tid1,tid2;
        pthread_create(&amp;tid1,NULL,thread_routine,&quot;thread 1&quot;);
        pthread_create(&amp;tid2,NULL,thread_routine,&quot;thread 2&quot;);
        pthread_exit(NULL);
}         
</code></pre><p>View Code</p>
<p>3.destructor函数<br>destructor函数仅仅当线程终止时被调用。当线程终止时，pthreads调用键的destructor函数前，将线程私有数据置为NULL,所以若线程私有数据值是堆存储的地址，并且想在destructor函数中释放，必须使用传递给destructor的参数，而不是pthread_getspecific的参数。可以自定义destructor函数。</p>
<p>键值为NULL意味着线程对应该键值不再有值，而不是赋空值。否则若随后调用pthread_key_create建立该键，线程将会收到旧值。</p>
<p>线程私有数据键的destructor函数在键值替换的时候不会被调用。即，如果在堆中将一个结构的指针作为键值，又分配一个新结构，并将新结构指针赋给相同数据键，则指向旧结构的指针不会调用destructor函数。</p>
<p>代码示例如下：</p>
<p>三个线程的私有变量数据，自定义destructor函数，在线程结束后，释放堆存储，在所有线程结束后，销毁私有数据键。</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<pre><code>#include&lt;stdio.h&gt;                                                                
#include&lt;pthread.h&gt;
typedef struct private_tag
{
        pthread_t tid;
        char *string;
}private_t;
pthread_key_t key;
pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER;
long counter = 0;
void key_destructor(void *value)
{
        private_t *private = (private_t*)value;
        printf(&quot;thread \&quot;%s\&quot; exiting...\n&quot;,private-&gt;string);
        free(value);
        pthread_mutex_lock(&amp;mutex);
        counter--;
        if(counter&lt;=0)
        {
                pthread_key_delete(key);
                printf(&quot;key deleted...\n&quot;);
        }
        pthread_mutex_unlock(&amp;mutex);
}
void *key_get(void)
{
        void *value;
        value = pthread_getspecific(key);
        if(value==NULL)
        {
printf(&quot;malloc\n&quot;);
value = malloc(sizeof(private_t));
                pthread_setspecific(key,(void*)value);
        }
        return value;
}
void *thread_routine(void *arg)
{
        private_t *value;
        value = (private_t*)key_get();
        value-&gt;tid = pthread_self();
        value-&gt;string = (char*)arg;
        printf(&quot;thread \&quot;%s\&quot; starting...\n&quot;,value-&gt;string);
        sleep(2);
        return NULL;
}
int main(void)
{
        pthread_t tid1,tid2;
        private_t *value;
        pthread_key_create(&amp;key,key_destructor);
        counter = 3;
        value = (private_t *)key_get();
        value-&gt;tid = pthread_self();
        value-&gt;string = &quot;Main thread&quot;;
        pthread_create(&amp;tid1,NULL,thread_routine,&quot;Thread 1&quot;);
        pthread_create(&amp;tid2,NULL,thread_routine,&quot;Thread 2&quot;);
        printf(&quot;exiting\n&quot;);
        pthread_exit(NULL);
}                        
</code></pre><p>View Code</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[posix多线程--线程取消]]></title>
      <url>https://shijingjing07.github.io/2016/04/17/posix%E5%A4%9A%E7%BA%BF%E7%A8%8B--%E7%BA%BF%E7%A8%8B%E5%8F%96%E6%B6%88/</url>
      <content type="html"><![CDATA[<p>1.三种取消状态<br>Off                   禁用取消<br>Deferred           推迟取消：在下一个取消点执行取消<br>Asynchronous   异步取消：可以随时执行取消</p>
<p>int pthread_cancel(pthread_t thread)</p>
<p>2.推迟取消：在下一个取消点执行取消</p>
<p>Pthreads系统上的某些函数会被作为取消点，如pthread_testcancel,sleep,pthread_cond_wait等。<br>线程调用pthread_cancel函数后，被取消线程不会立即取消，仅仅在到达取消点时响应取消请求。</p>
<p>代码示例如下：</p>
<p>在pthread_testcancel取消点，响应线程取消请求。</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<pre><code>#include&lt;stdio.h&gt;                                                                
#include&lt;pthread.h&gt;
#include&lt;errno.h&gt;
int counter;
pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER;
void *thread_route(void *arg)
{
        pthread_mutex_lock(&amp;mutex);
        for(counter=0;;counter++)
        {
                if(counter%2000==0){
                        printf(&quot;calling testcancel\n&quot;);
                        pthread_testcancel();
                }

        }
        pthread_mutex_unlock(&amp;mutex);
}
int main(void)
{
        pthread_t tid;
        void *result;
        pthread_create(&amp;tid,NULL,thread_route,NULL);
        sleep(1);
        printf(&quot;call cancel\n&quot;);
        pthread_cancel(tid);
        printf(&quot;call joining\n&quot;);
        pthread_join(tid,&amp;result);
        if(result==PTHREAD_CANCELED)
        {
            printf(&quot;Thread cancelled at %d\n&quot;,counter);
        }
        else{
                printf(&quot;Thread was not canceled\n&quot;);
        }
        pthread_mutex_lock(&amp;mutex);
        printf(&quot;main thread locked&quot;);
        pthread_mutex_unlock(&amp;mutex);
} 
</code></pre><p>View Code</p>
<p>3.如果要保证取消不在一个特别的取消点发生，可以暂时在代码的那个区域停用取消。<br>int pthread_setcancelstate(PTHREAD_CANCEL_DISABLE,int *state)</p>
<p>代码示例如下：</p>
<p>在sleep()时，禁用取消。</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<pre><code>#include&lt;stdio.h&gt;                                                                
#include&lt;pthread.h&gt;
#include&lt;errno.h&gt;
int counter;
pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER;
void *thread_route(void *arg)
{
        int state;
        pthread_mutex_lock(&amp;mutex);
        for(counter=0;;counter++)
        {
                if(counter%582==0)
                {
                        pthread_setcancelstate(PTHREAD_CANCEL_DISABLE,&amp;state)
;
                        sleep(1);
                        pthread_setcancelstate(state,&amp;state);
                }
                if(counter%2000==0){
                        printf(&quot;calling testcancel\n&quot;);
                        pthread_testcancel();
                }

        }
        pthread_mutex_unlock(&amp;mutex);
}
int main(void)
{
        pthread_t tid;
        void *result;
        pthread_create(&amp;tid,NULL,thread_route,NULL);
        sleep(1);
        printf(&quot;call cancel\n&quot;);
        pthread_cancel(tid);
        printf(&quot;call joining\n&quot;);
        pthread_join(tid,&amp;result);
        if(result==PTHREAD_CANCELED)
        {
                printf(&quot;Thread cancelled at %d\n&quot;,counter);
        }
        else{
                printf(&quot;Thread was not canceled\n&quot;);
        }
        pthread_mutex_lock(&amp;mutex);
        printf(&quot;main thread locked&quot;);
        pthread_mutex_unlock(&amp;mutex);
}           
</code></pre><p>View Code</p>
<p>4.异步取消：可以随时执行取消<br>异步取消不需要使用取消点来查询取消请求。异步取消不能获得任何资源，应避免异步的取消<br>代码示例如下：</p>
<p>矩阵相乘线程取消</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<pre><code>#include&lt;stdio.h&gt;                                                                
#include&lt;pthread.h&gt;
#define SIZE 10
int arr_a[SIZE][SIZE];
int arr_b[SIZE][SIZE];
int arr_c[SIZE][SIZE];
void printarr(int arr[SIZE][SIZE])
{
        int i,j;
        for(i=0;i&lt;SIZE;i++)
        {
                for(j=0;j&lt;SIZE;j++)
                {
                        printf(&quot;%x &quot;,arr[i][j]);    
                }
                printf(&quot;\n&quot;);
        }
}
void *thread_routine(void *arg)
{
        int i,j,cancel_type;
        for(i=0;i&lt;SIZE;i++)
                for(j=0;j&lt;SIZE;j++)
                {
                        arr_a[i][j] = i;
                        arr_b[i][j] = j;
                }
        while(1)
        {
                pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS,&amp;cancel_type);
                 for(i=0;i&lt;SIZE;i++)
                        for(j=0;j&lt;SIZE;j++)
                        {
                                arr_c[i][j] = arr_a[i][j]*arr_b[i][j];
                        }
                pthread_setcanceltype(cancel_type,&amp;cancel_type);
                for(i=0;i&lt;SIZE;i++)
                        for(j=0;j&lt;SIZE;j++)
                                arr_a[i][j] = arr_c[i][j];
        }
}
int main(void)
{
        pthread_t tid;                                                           
        void *result;
        pthread_create(&amp;tid,NULL,thread_routine,NULL);
        sleep(1);
        printf(&quot;canceling!&quot;);
        pthread_cancel(tid);
        printf(&quot;joining&quot;);
        pthread_join(tid,&amp;result);
        if(result==PTHREAD_CANCELED)
                printf(&quot;thread cancelled\n&quot;);
        else    
                printf(&quot;thread was not cancelled\n&quot;);
        printarr(arr_a);
        printarr(arr_b);
        printarr(arr_c);
}
</code></pre><p>View Code</p>
<p>5.清除<br>在编写代码时，应将其设计为可以推迟取消，在不适当的地方停用取消，在取消点使用清除处理器。</p>
<p>清除处理器可以理解为每个线程有一个活动的清除处理函数的栈，调用pthread_cleanup_push将清除函数加到栈中，调用pthread_cleanup_pop删除最近增加的处理函数。当所有活动的清除处理函数返回时，线程被终止。当pthread_cleanup_pop以非零值被调用时，即使线程没被取消，清除处理函数也要被执行。</p>
<p>代码示例如下：<br>当一个条件变量等待被取消时，使用一个清除处理函数来释放互斥量。</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<pre><code>#include&lt;stdio.h&gt;                                                                
#include&lt;pthread.h&gt;
#define THREADS 5
typedef struct work_tag
{
        pthread_mutex_t mutex;
        pthread_cond_t cond;
        int counter;
        int busy;
}work_t;
work_t work = {PTHREAD_MUTEX_INITIALIZER,PTHREAD_COND_INITIALIZER,0,1};
void cleanup_handler(void *arg)
{
        work_t *work_p = (work_t*)arg;
        work_p-&gt;counter--;
        pthread_mutex_unlock(&amp;work_p-&gt;mutex);
}
void *thread_routine(void *arg)
{
        pthread_cleanup_push(cleanup_handler,(void *)&amp;work);
        pthread_mutex_lock(&amp;work.mutex);
        work.counter++;
        while(work.busy)
        {
                pthread_cond_wait(&amp;work.cond,&amp;work.mutex);
        }
        pthread_cleanup_pop(1);
        return NULL;
}
int main(void)
{
        pthread_t tid[THREADS];
        void *result;
        int i;
        for(i=0;i&lt;THREADS;i++)
        {
                pthread_create(&amp;tid[i],NULL,thread_routine,NULL);
        }
        sleep(2);
        for(i=0;i&lt;THREADS;i++)
        {
                pthread_cancel(tid[i]);
                pthread_join(tid[i],&amp;result);
                if(result == PTHREAD_CANCELED)
                        printf(&quot;thread %d cancelled\n&quot;,i);
                else
                        printf(&quot;thread %d was not cancelled\n&quot;,i);
        }
        return 0;
}       
</code></pre><p>View Code</p>
<p>在一套”转包”功能的程序中，当分包线程在进行中时，承包线程被取消，这时不希望分包线程继续运行。可以在承包线程清除处理函数中取消每个分包线程，<br>如果原来是连接分包线程，它们将继续消费一些资源直到它们被连接或分离。这时应在承包线程清除处理函数中使用pthread_detach立即分离它。</p>
<p>代码示例如下：</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<pre><code>#include&lt;stdio.h&gt;                                                                
#include&lt;pthread.h&gt;
#define THREADS 5
typedef struct send_tag
{
        pthread_t sid[THREADS];
}send_t;
void *send_routine(void *arg)
{
        int counter;
        for(counter=0;;counter++)
                if(counter%1000==0)
                        pthread_testcancel();
}
void cleanup(void *arg)
{
        send_t *send = (send_t*)arg;
        int i;
        for(i=0;i&lt;THREADS;i++)
        {
                pthread_cancel(send-&gt;sid[i]);
                pthread_detach(send-&gt;sid[i]);
                printf(&quot;cleanup:cancelled %d\n&quot;,i);
        }
}
void *thread_routine(void *arg)
{
        send_t send;
        int i;
        void *result;
        for(i=0;i&lt;THREADS;i++)
        {
                pthread_create(&amp;send.sid[i],NULL,send_routine,NULL);
        }
        pthread_cleanup_push(cleanup,(void*)&amp;send);
        for(i=0;i&lt;THREADS;i++)
                pthread_join(send.sid[i],&amp;result);
        pthread_cleanup_pop(0);
}
int main(void)
{
        pthread_t tid;
        void *result;
        pthread_create(&amp;tid,NULL,thread_routine,NULL);
        sleep(5);
        pthread_cancel(tid);
        pthread_join(tid,&amp;result);
        return 0;
}                                                                                
</code></pre><p>View Code</p>
<p>参考资料：《POSIX多线程程序设计》 pp.120-137</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[posix多线程--三种基本线程编程模型]]></title>
      <url>https://shijingjing07.github.io/2016/04/15/posix%E5%A4%9A%E7%BA%BF%E7%A8%8B--%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>本文介绍了三种构建线程解决方案的方式。</p>
<p>一、流水线：每个线程执行同一种操作，并把操作结果传递给下一步骤的线程。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201604/300946-20160415151918473-1467930339.png" alt=""></p>
<p>代码示例如下：<br>终端输入一个int值，每个线程将该值加1，并将结果传给下一个线程。</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<pre><code>#include&lt;stdio.h&gt;                                                                
#include&lt;pthread.h&gt;
typedef struct stage_tag
 {
          pthread_mutex_t mutex;
          pthread_cond_t cond;
          int data;
          int ready;
          pthread_t tid;
          struct stage_tag *next;
}stage_t;
typedef struct pipe_tag
{
        pthread_mutex_t mutex;
        stage_t *head;
        stage_t *tail;
        int stages;
}pipe_t;
void pipe_send(stage_t *stage,int data)
{
        stage-&gt;data =data;
        stage-&gt;ready = 1;
        pthread_cond_signal(&amp;stage-&gt;cond);
}
void *thread_route(void *arg)
{
        stage_t *stage = (stage_t *)arg;
        while(!stage-&gt;ready)
        {
                pthread_cond_wait(&amp;stage-&gt;cond,&amp;stage-&gt;mutex);
 }
        int data = stage-&gt;data+1;
        stage_t *next = stage-&gt;next;
        if(next!=NULL)
        {
                pipe_send(next,data);
        }
        return NULL;
}
void create_pipe(pipe_t *pipe,int stages)
{
//      pipe = (pipe_t *)malloc(sizeof(pipe_t));
        pipe-&gt;stages = stages;
        int i;
        stage_t *stage;
        stage_t *last;
        for(i=0;i&lt;=stages;i++)
        {
                stage = (stage_t *)malloc(sizeof(stage_t));
                stage-&gt;data = i;
                if(i==0)
                {
                        pipe-&gt;head = stage;
                }
                if(last!=NULL)
                {
                        last-&gt;next = stage;
                }
last = stage;
        }
        last-&gt;next=NULL;
        pipe-&gt;tail = last;
        for(stage=pipe-&gt;head;stage-&gt;next!=NULL;stage=stage-&gt;next)
        {
                pthread_create(&amp;stage-&gt;tid,NULL,thread_route,(void *)stage);
                printf(&quot;stage %d\n&quot;,stage-&gt;data);
        }
/*      free(pipe);
        for(stage=pipe-&gt;head;stage!=NULL;stage=stage-&gt;next)
        {
                  free(stage);
        }       
        */
}
int main(void)
{
        pipe_t my_pipe;
        long value,result;
        char line[128];
        create_pipe(&amp;my_pipe,10);
        pipe_send(my_pipe.head,5);
        sleep(10);
        printf(&quot;result is %d\n&quot;,my_pipe.tail-&gt;data);
        return 0;
} 
</code></pre><p>View Code</p>
<p>二、工作组：数据由一组线程分别独立地处理。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201604/300946-20160415151935551-2032798922.png" alt=""></p>
<p>代码示例如下：<br>程序有两个参数：filepath：文件或目录路径；search：待查找字符串</p>
<p>程序将文件路径排队给工作组，工作组线程判断该路径是文件还是目录，如果是文件，它将在文件中搜索字符串；如果是目录，它将使用readdir_r查找该目录中的所有子目录和文件，并将每一项添加到工作队列。</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<pre><code>#include&lt;stdio.h&gt;                                                                
#include&lt;pthread.h&gt;
#include&lt;dirent.h&gt;
#include&lt;sys/stat.h&gt;
typedef struct work_tag
{
        struct work_tag *next;
        char *path;
        char *search;
}work_t,*work_p;
typedef struct worker_tag
{
        int index;
        pthread_t tid;
        struct crew_tag *crew;

}worker_t,*worker_p;
typedef struct crew_tag
{
        pthread_mutex_t mutex;
        pthread_cond_t cond;
        pthread_cond_t done;
        long work_count;
        work_t *first,*last;
        worker_t workers[4];
}crew_t,*crew_p;
void *thread_route(void *arg)
{
worker_p worker = (worker_t *)arg;
        crew_p crew = worker-&gt;crew;
struct dirent *entry;
        entry = (struct dirent*)malloc(sizeof(struct dirent)+sizeof(size_t));   
pthread_mutex_lock(&amp;crew-&gt;mutex);
while(crew-&gt;work_count ==0)
        {
                pthread_cond_wait(&amp;crew-&gt;cond,&amp;crew-&gt;mutex);
        }
        pthread_mutex_unlock(&amp;crew-&gt;mutex);
        printf(&quot;worker is running: %d\n&quot;,worker-&gt;index);
        while(1)
        {
                pthread_mutex_lock(&amp;crew-&gt;mutex);
                while(crew-&gt;first==NULL)
                {
                        pthread_cond_wait(&amp;crew-&gt;cond,&amp;crew-&gt;mutex);
                }
                printf(&quot;worker %d woke %#lx %d\n&quot;,worker-&gt;index,crew-&gt;first,crew-&gt;work_count);
                work_p work = crew-&gt;first;
                crew-&gt;first = work-&gt;next;
                if(crew-&gt;first==NULL)
                        crew-&gt;last = NULL;
                printf(&quot;worker %d took %#lx,leave first %#lx,last %#lx\n&quot;,worker-&gt;index,work,crew-&gt;first,crew-&gt;last);
                pthread_mutex_unlock(&amp;crew-&gt;mutex);
                struct stat filestat;
                lstat(work-&gt;path,&amp;filestat);
                if(S_ISLNK(filestat.st_mode))
printf(&quot;worker %d:%s is a link,skipping.\n&quot;,worker-&gt;index,work-&gt;path);
                else if(S_ISDIR(filestat.st_mode)){
                        DIR *dir;
                        struct dirent *result;
                        dir = opendir(work-&gt;path);
                        while(1){
                                readdir_r(dir,entry,&amp;result);
                if(result==NULL)
                                        break;
                                if(strcmp(entry-&gt;d_name,&quot;.&quot;)==0)
                                        continue;
                                if(strcmp(entry-&gt;d_name,&quot;..&quot;)==0)

                                        continue;
                                work_p new_work = (work_p)malloc(sizeof(work_t));
                printf(&quot;test\n&quot;);
                 path_max = pathconf (work-&gt;path, _PC_PATH_MAX);
new_work-&gt;path = (char*)malloc (path_max);
strcpy (new_work-&gt;path, work-&gt;path);
                strcat (new_work-&gt;path, &quot;/&quot;);
                strcat (new_work-&gt;path, entry-&gt;d_name);                 
//       char *new_dir = strcat(work-&gt;path,entry-&gt;d_name);
                                //new_work-&gt;path = new_dir;
                                 new_work-&gt;search = work-&gt;search;
                                 new_work-&gt;next = NULL;
                                 pthread_mutex_lock(&amp;crew-&gt;mutex);
                                 if(crew-&gt;first==NULL)
{
                                        crew-&gt;first = new_work;
                                        crew-&gt;last = new_work;
                                 }
                                 else{
                                        crew-&gt;last-&gt;next = new_work;
                                        crew-&gt;last = new_work;
                                 }
                                 crew-&gt;work_count++;
                                 printf(&quot;worker %d add work %#lx,first %#lx,last %#lx,%d\n&quot;,worker-&gt;index,new_work,crew-&gt;first,crew-&gt;last,crew-&gt;work_count);
                                 pthread_cond_signal(&amp;crew-&gt;cond);
                                 pthread_mutex_unlock(&amp;crew-&gt;mutex);
                        }
                        closedir(dir);
                }
                else if(S_ISREG(filestat.st_mode)){
                        FILE *file;
                        char buffer[256];
                        file = fopen(work-&gt;path,&quot;r&quot;);
                        fgets(buffer,sizeof(buffer),file);
                        char *search_ptr;
                        search_ptr = strstr(buffer,work-&gt;search);
                        if(search_ptr!=NULL){
                                printf(&quot;worker %d found \&quot;%s\&quot; in %s\n &quot;,worker-&gt;index,work-&gt;search,work-&gt;path);              
                                 }
                        fclose(file);

                }
                else{
                        printf(&quot;worker %d:%s format is error.\n&quot;,worker-&gt;index,work-&gt;path);
                }
                free(work-&gt;path);
                free(work);

                pthread_mutex_lock(&amp;crew-&gt;mutex);
                crew-&gt;work_count--;
                printf(&quot;worker %d decremented work to %d\n&quot;,worker-&gt;index,crew-&gt;work_count);
                if(crew-&gt;work_count&lt;=0){
                        pthread_cond_broadcast(&amp;crew-&gt;done);
                }                                                                
                pthread_mutex_unlock(&amp;crew-&gt;mutex);
        }
        free(entry);
        return NULL;
}
void crew_create(crew_t *crew)
{
        int worker_index;
        crew-&gt;work_count = 0;
        crew-&gt;first = NULL;
        crew-&gt;last = NULL;
        pthread_mutex_init(&amp;crew-&gt;mutex,NULL);
pthread_cond_init(&amp;crew-&gt;cond,NULL);
        pthread_cond_init(&amp;crew-&gt;done,NULL);
        for(worker_index=0;worker_index&lt;4;worker_index++){
                crew-&gt;workers[worker_index].index = worker_index;
                crew-&gt;workers[worker_index].crew = crew;
                pthread_create(&amp;crew-&gt;workers[worker_index].tid,
                NULL,thread_route,(void *)&amp;crew-&gt;workers[worker_index]);
        }
}
void crew_start(crew_t *crew,char *filepath,char *search)
{
        pthread_mutex_lock(&amp;crew-&gt;mutex);
        work_p work = (work_p)malloc(sizeof(work_t));
        work-&gt;path = filepath;
        work-&gt;search = search;
        work-&gt;next = NULL;
        crew-&gt;first = work;
        crew-&gt;last = work;
        crew-&gt;work_count++;
        pthread_cond_signal(&amp;crew-&gt;cond);
        while(crew-&gt;work_count&gt;0)
        {
                pthread_cond_wait(&amp;crew-&gt;done,&amp;crew-&gt;mutex);
        }
        printf(&quot;crew is done!\n&quot;);
        pthread_mutex_unlock(&amp;crew-&gt;mutex);
}
int main(void)             
{
        crew_t crew;
        crew_create(&amp;crew);
        char *filepath = &quot;/home/ubuntu/programs&quot;;
        char *search = &quot;errno&quot;;
        crew_start(&amp;crew,filepath,search);
        return 0;
}   
</code></pre><p>View Code</p>
<p>三、客户端/服务器：客户端线程将工作排队，交给一个服务器线程去处理。客户端或者以同步方式等待服务器执行，或异步执行并在后面需要时查找结果。</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201604/300946-20160415151946160-1569950158.png" alt=""></p>
<p>代码示例如下：<br>一组线程都需要从stdin中读取输入，这将导致提示-读(prompt-and-<br>read)操作可能有些混乱。一个方法是使用flockfile和funlockfile函数来锁住stdin和stdout。，另一个方式是，使用服务器线程，将客户端读写操作排队，由服务器线程依次处理读写操作队列。</p>
<p><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""></p>
<pre><code>#include&lt;stdio.h&gt;                                                                
#include&lt;pthread.h&gt;
#define REQ_READ 1
#define REQ_WRITE 2
#define REQ_QUIT 3
typedef struct client_tag
{
        struct client_tag *next;
        int oper;
        int sync;
        int done_flag;
        char prompt[32];
        char text[128];
        pthread_mutex_t mutex;
        pthread_cond_t mutex;
}client_t;
typedef struct server_tag
{
        client_t *first,*last;
        pthread_mutex_t mutex;
        pthread_cond_t cond;
}server_t;
server_t server={NULL,NULL,PTHREAD_MUTEX_INITIALIZER,PTHREAD_COND_INITIALIZER};
pthread_mutex_t main_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t main_cond = PTHREAD_COND_INITIALIZER;
int thread_count = 4;
void client_request(int oper,int sync,const char *prompt,char *string)
{
        pthread_mutex_lock(&amp;server.mutex);
        client_t *client;
client = (client_t *)malloc(sizeof(client_t));
        client-&gt;next = NULL;
        client-&gt;oper  = oper;
        client-&gt;sync = sync;
        if(prompt!=NULL)
                strncpy(client-&gt;prompt,prompt,32);
        if(oper==REQ_WRITE&amp;&amp;string!=NULL)
                strncpy(client-&gt;text,string,128);
        if(server.first==NULL)
        {
                server.first = client;
                server.last = client;
        }else{
                server.last-&gt;next = client;
                server.last = client;
        }
        pthread_cond_signal(&amp;server.cond);
        if(sync)
        {
                while(!client-&gt;done_flag)
                {
                        pthread_cond_wait(&amp;client-&gt;cond,&amp;server.mutex);
                }
                if(oper==REQ_READ)
                {
                        if(strlen(client-&gt;text)&gt;0)
                                strcpy(string,client-&gt;text);
                }
}
                pthread_cond_destroy(&amp;client-&gt;cond);
                free(request);
        }
        pthread_mutex_unlock(&amp;server.mutex);
}
void *client_route(void *arg)
{
        int index = (int)arg;
        int loops;
        char prompt[32];
        char string[128],formatted[128];
        sprintf(prompt,&quot;Client %d&gt;&quot;,index);
        while(1)
        {
                client_request(REQ_READ,1,prompt,string);
                if(strlen(string)==0)
                        break;
                for(loops=0;loops&lt;4;loops++)
                {
                        sprintf(formatted,&quot;(%d#%d) %s&quot;,index,loops,string);
                        client_request(REQ_WRITE,0,NULL,formatted);
                        sleep(1);
                }                 
 }
}
void *server_route(void *arg)
{
        client_t *client;
        int oper;
        while(1)
        {
                pthread_mutex_lock(&amp;server.mutex);
                while(server.first==NULL)
                {
                        pthread_cond_wait(&amp;server.cond,&amp;server.mutex);
                }
                client = server.first;
                server.first = client.next;
                if(server.first==NULL)
                        server.last = NULL;
                pthread_mutex_unlock(&amp;server.mutex);
                oper = client-&gt;oper;
                switch(oper){
                        case REQ_QUIT:
                                break;
                        case REQ_READ:
                                if(strlen(client-&gt;prompt)&gt;0)
                                        printf(client-&gt;prompt);
                                fgets(client-&gt;text,128,stdin);
                                break;
                        case REQ_WRITE:       
                                puts(client-&gt;text);
                                break;
                        default:
                                break;
                }
                free(client);
                if(oper==REQ_QUIT)
                        break;
        }
        return NULL;
}
int main(void)
{
        pthread_t sid;
        pthread_create(&amp;sid,NULL,server_route,NULL);

        pthread_t cid;
        int i;
        for(i=0;i&lt;thread_count;i++)
        {
                pthread_create(&amp;cid,NULL,client_route,(void *)count);
        }
        pthread_mutex_lock(&amp;main_mutex);
        while(thread_count&gt;0)
        {
                pthread_cond_wait(&amp;main_cond,&amp;main_mutex);
        }
        pthread_mutex_unlock(&amp;main_mutex);        
        printf(&quot;Done!\n&quot;);
        client_request(REQ_QUIT,1,NULL,NULL);
        return 0;
}    
</code></pre><p>View Code</p>
<p>参考资料：《POSIX多线程程序设计》 pp.81-110</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[posix多线程--条件变量]]></title>
      <url>https://shijingjing07.github.io/2016/04/13/posix%E5%A4%9A%E7%BA%BF%E7%A8%8B--%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<p>条件变量是用来通知共享数据状态信息的。</p>
<p>1.条件变量初始化两种方式：<br>（1）静态初始化<br>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;<br>代码示例如下：</p>
<pre><code>#include &lt;pthread.h&gt;
typedef struct my_struct_tag {
    pthread_mutex_t     mutex;  /* Protects access to value */
    pthread_cond_t      cond;   /* Signals change to value */
    int                 value;  /* Access protected by mutex */
} my_struct_t;

my_struct_t data = {
    PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, 0};

int main (int argc, char *argv[])
{
    return 0;
}
</code></pre><p>（2）动态初始化<br>int pthread_cond_init(pthread_cond_t <em>cond,pthread_condattr_t </em>condattr);<br>int pthread_cond_destroy(pthread_cond_t *cond);<br>代码示例如下：</p>
<pre><code>#include &lt;pthread.h&gt;

typedef struct my_struct_tag {
    pthread_mutex_t     mutex;  /* Protects access to value */
    pthread_cond_t      cond;   /* Signals change to value */
    int                 value;  /* Access protected by mutex */
} my_struct_t;

int main (int argc, char *argv[])
{
    my_struct_t *data;
    int status;
    data = malloc (sizeof (my_struct_t));
    status = pthread_mutex_init (&amp;data-&gt;mutex, NULL);
    status = pthread_cond_init (&amp;data-&gt;cond, NULL);
    status = pthread_cond_destroy (&amp;data-&gt;cond);
    status = pthread_mutex_destroy (&amp;data-&gt;mutex);
    (void)free (data);
    return status;
}
</code></pre><p>2.等待条件变量<br>int pthread_cond_wait(pthread_cond_t <em>cond,pthread_mutex_t </em>mutex);<br>int pthread_cond_timedwait(pthread_cond_t <em>cond,pthread_mutex_t </em>mutex,struct<br>timespec *expiration);<br>当线程等待条件变量时，它必须将相关互斥量锁住。在阻塞线程之前，条件变量等待操作将解锁互斥量，而在重新返回线程之前，会再次锁住互斥量。</p>
<p>3.唤醒条件变量<br>int pthread_cond_signal(pthread_cond_t <em>cond);<br>int pthread_cond_broadcast(pthread_cond_t </em>cond);<br>在发送信号时也必须锁住互斥量，如果互斥量不被锁住，任何线程可以在被唤醒线程之前锁住互斥量。这将是一个产生被拦截唤醒的根源。例如，一个低优先级的线程可能锁住了互斥量，使高优先级的线程无法被其他线程唤醒，延迟了高优先级线程的调度。</p>
<p>4.需要在等待条件变量线程被唤醒后，检测条件<br>（1）被拦截的唤醒：等待条件变量被唤醒并加锁相关互斥量，若一个其他线程获得了互斥量，它可能在等待之前先检查条件。由于条件为真，所以它不需等待，直接处理工作，当它解锁时，已经没有可做的工作了。我们的第一个等待条件变量线程加锁互斥量后，再次检测条件，很有必要。<br>（2）松散的条件：使用不确定的条件时，循环检测条件，代码会更加健壮。<br>（3）假唤醒：在某些多处理器系统，会发生假唤醒的情况。</p>
<p>5.使用示例</p>
<p>主线程等待条件信号2S，子线程睡眠1S，改变共享数据值，发送信号，主线程接收信号，继续运行。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;pthread.h&gt;
#include&lt;errno.h&gt;                                                                
typedef struct cond_tag
{
        pthread_mutex_t mutex;
        pthread_cond_t cond;
        int valid;
}cond_t;
cond_t data = {
        PTHREAD_MUTEX_INITIALIZER,
        PTHREAD_COND_INITIALIZER,
        0
};
void *thread_route(void *arg)
{
        sleep(1);
        pthread_mutex_lock(&amp;data.mutex);
        data.valid = 1;
        pthread_cond_signal(&amp;data.cond);
        pthread_mutex_unlock(&amp;data.mutex);
        return NULL;
}
int main(void)
{
        int status;
        pthread_t pid;
        pthread_create(&amp;pid,NULL,thread_route,NULL);
        struct timespec timeout;
        timeout.tv_sec = time(NULL)+2;
        timeout.tv_nsec = 0;
        pthread_mutex_lock(&amp;data.mutex);
        while(data.valid==0)
        {
                status = pthread_cond_timedwait(&amp;data.cond,&amp;data.mutex,&amp;timeout);
                if(status==ETIMEDOUT)
                {
                        printf(&quot;wait timed out\n&quot;);
                        break;
                }
        }
        if(data.valid==1)
        {
                printf(&quot;cond is signaled\n&quot;);
        }
        pthread_mutex_unlock(&amp;data.mutex);

        return 0;
}  
</code></pre><p>参考资料：《POSIX多线程程序设计》 pp.59-74</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[posix多线程--互斥量]]></title>
      <url>https://shijingjing07.github.io/2016/04/12/posix%E5%A4%9A%E7%BA%BF%E7%A8%8B--%E4%BA%92%E6%96%A5%E9%87%8F/</url>
      <content type="html"><![CDATA[<p>多线程程序在线程间共享数据时，如果多个线程同时访问共享数据就可能有问题。互斥量是解决多个线程间共享数据的方法之一。</p>
<p>1.互斥量初始化两种方式：<br>（1）静态初始化</p>
<pre><code>#include &lt;pthread.h&gt;

typedef struct my_struct_tag {
pthread_mutex_t mutex; /* Protects access to value */
int value; /* Access protected by mutex */
} my_struct_t;

my_struct_t data = {PTHREAD_MUTEX_INITIALIZER, 0};

int main (int argc, char *argv[])
{
return 0;
}
</code></pre><p>（2）动态初始化</p>
<pre><code>#include &lt;pthread.h&gt;

typedef struct my_struct_tag {
pthread_mutex_t mutex; /* Protects access to value */
int value; /* Access protected by mutex */
} my_struct_t;

int main (int argc, char *argv[])
{
my_struct_t *data;
data = malloc (sizeof (my_struct_t));
pthread_mutex_init (&amp;data-&gt;mutex, NULL);
pthread_mutex_destroy (&amp;data-&gt;mutex);
(void)free (data);
return 0;
}
</code></pre><p>2.加锁和解锁<br>int pthread_mutex_lock(pthread_mutex_t <em>mutex)<br>int pthread_mutex_trylock(pthread_mutex_t </em>mutex)<br>int pthread_mutex_unlock(pthread_mutex_t *mutex)</p>
<p>3.非阻塞式互斥量锁<br>int pthread_mutex_trylock(pthread_mutex_t *mutex)</p>
<p>4.使用多个互斥量<br>使用多个互斥量易发生死锁的问题，如一个线程锁住互斥量A后，加锁互斥量B；同时另一个线程锁住互斥量B而等待互斥量A，则发生死锁现象。针对死锁，有两种解决方法：<br>（1）固定加锁层次：即所有同时需要加锁互斥量A和互斥量B的代码，必须先加锁A，后加锁B<br>（2）试加锁和回退：在锁住某个集合中的第一个互斥量后，使用pthread_mutex_trylock来加锁集合中的其他互斥量，如果失败，则将集合中所有已加锁互斥量释放，并重新加锁。</p>
<p>5.链锁<br>链锁的作用范围互相交叠。当锁住第一个互斥量后，代码进入一个区域，该区域需要另一个互斥量。当锁住另一个互斥量后，第一个互斥量就不再需要，可以释放它了。<br>链锁在遍历如树型结构或链表结构是很有用。</p>
<p>参考资料：《POSIX多线程程序设计》 pp.39-59</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c--日期和时间函数]]></title>
      <url>https://shijingjing07.github.io/2016/04/07/c--%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>C的标准库&lt;time.h&gt;包含了一些处理时间与日期的函数。</p>
<p>1.clock_t clock(void);</p>
<p>函数返回程序自开始执行后的处理器时间，类型是clock_t，单位是tick。如果有错误，clock()函数就返回-1。</p>
<p>类型clock_t在&lt;time.h&gt;中定义，等价于size_t类型。CLOCKS_PER_SEC是&lt;time.h&gt;中定义的宏，表示一秒内的tick数，且是clock_t类型。将clock()函数返回值除以CLOCKS_PER_SEC，得到处理器运行时间。</p>
<p>代码示例：</p>
<pre><code>#include &lt;stdio.h&gt;
#include&lt;time.h&gt;
#include&lt;windows.h&gt;
#include&lt;stdlib.h&gt;
main()
{
    clock_t start,end;
    double cpu_time;
    start = clock();
    Sleep(2000);
    end = clock();
    cpu_time = (double)(end-start)/CLOCKS_PER_SEC;
    printf(&quot;%.2lf&quot;,cpu_time);
    system(&quot;pause&quot;);
}
</code></pre><p>输出结果：2.00</p>
<p>2. time_t time(time_t *time_t)<br>time()函数返回从1970年1月1日格林威治时间0点0分0秒到现在的秒数。类型time_t在&lt;time.h&gt;中定义，等价于long。<br>如果变元不是NULL，则返回值就存在time_t变元指向的位置中。</p>
<p>double difftime(time_t T2,time_t T1)<br>返回T2-T1的数值，类型是double，单位是秒。</p>
<p>代码示例：</p>
<pre><code>#include &lt;stdio.h&gt;
#include&lt;time.h&gt;
#include&lt;windows.h&gt;
#include&lt;stdlib.h&gt;
main()
{
    time_t calendar_start,calendar_end;
    calendar_start = time(NULL);
    Sleep(2000);
    calendar_end = time(NULL);
    printf(&quot;start:%d\n&quot;,calendar_start);
    printf(&quot;end:%d\n&quot;,calendar_end);
    printf(&quot;diff:%.0lf\n&quot;,difftime(calendar_end,calendar_start));
    system(&quot;pause&quot;);
}
</code></pre><p>输出结果：<br>start:1460010918<br>end:1460010920<br>diff:2</p>
<p>3.char <em>ctime(const time_t </em>timer)<br>函数接收一个time_t变量的指针作为变元，返回一个指向26个字符的字符串指针。其中有星期，日期，时间以及年，最后用一个\n和\0终止。如：”Mon Aug<br>25 10:45:36 2015\n\0”</p>
<p>代码示例：</p>
<pre><code>#include &lt;stdio.h&gt;
#include&lt;time.h&gt;
#include&lt;stdlib.h&gt;
main()
{
    time_t calendar;
    calendar = time(NULL);
    printf(&quot;%s\n&quot;,ctime(&amp;calendar));
    system(&quot;pause&quot;);
}
</code></pre><p>输出结果：Thu Apr 07 14:34:10 2016</p>
<p>4.struct tm <em>localtime(const time_t</em> timer)<br>函数接收一个time_t值的指针，返回结构类型tm的指针。</p>
<p>tm结构如下：<br>struct tm {<br>int tm_sec; /<em> 秒 - 取值区间为[0,59] </em>/<br>int tm_min; /<em> 分 - 取值区间为[0,59] </em>/<br>int tm_hour; /<em> 时 - 取值区间为[0,23] </em>/<br>int tm_mday; /<em> 一个月中的日期 - 取值区间为[1,31] </em>/<br>int tm_mon; /<em> 月份（从一月开始，0代表一月） - 取值区间为[0,11] </em>/<br>int tm_year; /<em> 年份，其值等于实际年份减去1900 </em>/<br>int tm_wday; /<em> 星期 - 取值区间为[0,6]，其中0代表星期天，1代表星期一 </em>/<br>int tm_yday; /<em> 从每年的1月1日开始的天数 </em>/<br>int tm_isdst; /<em> 夏令时标识符。</em>/<br>}</p>
<p>代码示例：</p>
<pre><code>#include &lt;stdio.h&gt;
#include&lt;time.h&gt;
#include&lt;stdlib.h&gt;
main()
{
    time_t calendar;
    struct tm *time_data;
    char *month[] = {&quot;一月&quot;,&quot;二月&quot;,&quot;三月&quot;,&quot;四月&quot;,&quot;五月&quot;,&quot;六月&quot;,&quot;七月&quot;,&quot;八月&quot;,&quot;九月&quot;,&quot;十月&quot;,&quot;十一月&quot;,&quot;十二月&quot;};
    char *week[] = {&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;,&quot;星期日&quot;};
    char *suffix[] = {&quot;st&quot;,&quot;nd&quot;,&quot;rd&quot;,&quot;th&quot;};
    enum suffixIndex {st,nd,rd,th} sufsel = th;
    calendar = time(NULL);
    time_data = localtime(&amp;calendar);
    printf(&quot;format date:%d/%d/%d\n&quot;,time_data-&gt;tm_year+1900,time_data-&gt;tm_mon,time_data-&gt;tm_mday);
    switch(time_data-&gt;tm_mday)
    {
    case 1:
    case 21:
    case 31:
        sufsel = st;
        break;
    case 2:
    case 22:
        sufsel = nd;
        break;
    case 3:
    case 23:
        sufsel = rd;
        break;
    default:
        sufsel = th;
        break;
    }
    printf(&quot;today is %s,%s,%d%s,%d&quot;,week[time_data-&gt;tm_wday],month[time_data-&gt;tm_mon],time_data-&gt;tm_mday,suffix[sufsel],time_data-&gt;tm_year+1900);
    system(&quot;pause&quot;);
}
</code></pre><p>输出结果：<br>format date:2016/3/7<br>today is 星期五,四月,7th,2016</p>
<p>4.localtime()函数生成的是本地时间，若要使用UTC(世界调整时间)，可使用gmtime()函数</p>
<p>5.time_t mktime(struct tm *ptime)<br>函数接收一个tm结构的变元指针，返回值类型为timt_t。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mysql--Ubuntu下设置MySQL字符集为utf8]]></title>
      <url>https://shijingjing07.github.io/2016/04/01/mysql--Ubuntu%E4%B8%8B%E8%AE%BE%E7%BD%AEMySQL%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%BAutf8/</url>
      <content type="html"><![CDATA[<p>1.mysql配置文件地址<br>/etc/mysql/my.cnf</p>
<p>2.在[mysqld]在下方添加以下代码<br>[mysqld]<br>init_connect=’SET collation_connection = utf8_unicode_ci’<br>init_connect=’SET NAMES utf8’<br>character-set-server=utf8<br>collation-server=utf8_unicode_ci<br>skip-character-set-client-handshake</p>
<p>3.重启mysql服务<br>sudo service mysql restart</p>
<p>4.检测字符集是否更新成utf8.<br>进入mysql，mysql -u root -p,输入show variables like ‘%character%’ 查看字符集<br>+————————–+—————————-+<br>| Variable_name | Value |<br>+————————–+—————————-+<br>| character_set_client | utf8 |<br>| character_set_connection | utf8 |<br>| character_set_database | utf8 |<br>| character_set_filesystem | binary |<br>| character_set_results | utf8 |<br>| character_set_server | utf8 |<br>| character_set_system | utf8 |<br>| character_sets_dir | /usr/share/mysql/charsets/ |<br>+————————–+—————————-+</p>
<p>注意事项：在修改字符集之前已经建立的数据库，character_set_database值不会发生改变，往数据库中插入中文数据仍然会显示乱码，所以最好在安装完MySQL后就将字符集改成utf8，否则后续修改会较麻烦。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python--使用MySQL数据库]]></title>
      <url>https://shijingjing07.github.io/2016/04/01/python--%E4%BD%BF%E7%94%A8MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>1.安装mysql<br>sudo apt-get install mysql-server<br>Sudo apt-get install mysql-client</p>
<p>2.安装MySQL-python驱动<br>sudo apt-get install mysql-python</p>
<p>3.测试是否安装成功<br>python解释器命令下运行 import MySQLdb<br>没有报错，说明安装已成功。</p>
<p>4.python使用mysql数据库常见操作 exmysql.py</p>
<pre><code># -*- coding: utf-8 -*-                                                                                                                                 
import MySQLdb

try:
        #mysql连接
        conn = MySQLdb.connect(host=&apos;localhost&apos;,user=&apos;root&apos;,passwd=&apos;password&apos;,port=3306,charset=&apos;utf8&apos;)

        #创建游标
        cur = conn.cursor()

        #创建数据库
        cur.execute(&apos;create database if not exists  pythondb&apos;)

        #切换到数据库
        conn.select_db(&apos;pythondb&apos;)   

        #创建表
        cur.execute(&quot;create table student(id int,name varchar(20),age int)&quot;)

        #插入单条数据
        cur.execute(&quot;insert into student values(9,&apos;张三&apos;,28)&quot;)

        #插入多条数据
        cur.execute(&quot;insert into student values(2,&apos;shijingjing08&apos;,21),(3,&apos;shijingjing09&apos;,30),(4,&apos;shijingjing10&apos;,12)&quot;)

        #更新数据
        cur.execute(&quot;update student set age=27 where name=&apos;shijingjing07&apos; &quot;)

        #删除数据
        cur.execute(&quot;delete from student where name=&apos;shijingjing10&apos; &quot;)

        #查找数据
        count = cur.execute(&quot;select * from student &quot;)
        print &quot;总条数&quot;
        print count

        result = cur.fetchone()
        print &quot;查找一条&quot;
        print result

        results = cur.fetchmany(5)
        print &quot;查找多条&quot;
        for r in results:
                print r

        cur.scroll(0,mode=&apos;absolute&apos;)

        #游标定位到表中第一条数据
        results = cur.fetchall()

        print &quot;查找所有数据，第二列的值&quot;
        for r in results:
                print r[1]

        #在再次执行select查询返回结果集时，需要执行nextset()操作，移动到下一结果集，否则会报2014错误
        cur.nextset()


        #执行存储过程的两种方法
        #cur.execute(&quot;call get_student(&apos;shijingjing&apos;,20)&quot;)
        cur.callproc(&quot;get_student&quot;,(&apos;shijingjing&apos;,20))
        print &quot;执行存储过程&quot;
        data=cur.fetchall()
        for d in data:
                print d


        #关闭游标
        cur.close()

        #提交
        conn.commit()
        #关闭数据库连接
        conn.close()

except MySQLdb.Error,e:
        print &quot;Mysql Error %d:%s&quot;%(e.args[0],e.args[1]) 
</code></pre><p> 存储过程get_student(in p_name varchar(20),in p_age<br>int),输入name,age参数，模糊查找name,以及age&gt;p_age的学生。</p>
<pre><code>delimiter $
create procedure get_student(in p_name varchar(20),in p_age int) 
     begin
          select * from student where name like concat(p_name,&apos;%&apos;) and age&gt;p_age;
     end;
$
</code></pre><p>5.运行结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201604/300946-20160401160447816-1857114613.png" alt=""></p>
<p>6.常用的操作：<br>commit() 提交<br>rollback() 回滚</p>
<p>callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数<br>execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数<br>executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数<br>nextset(self):移动到下一个结果集</p>
<p>fetchall(self):接收全部的返回结果行.<br>fetchmany(self,<br>size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.<br>fetchone(self):返回一条结果行.<br>scroll(self, value,<br>mode=’relative’):移动指针到某一行.如果mode=’relative’,则表示从当前所在行移动value条,如果<br>mode=’absolute’,则表示从结果集的第一行移动value条.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python--笨方法学python 习题52]]></title>
      <url>https://shijingjing07.github.io/2016/03/31/python--%E7%AC%A8%E6%96%B9%E6%B3%95%E5%AD%A6python%20%E4%B9%A0%E9%A2%9852/</url>
      <content type="html"><![CDATA[<p>笨方法学python是一本不错的python入门书籍。<br>书的最后一节是一个web版的游戏程序，以下是程序代码：</p>
<p>1.项目的目录结构如下所示：<br>skeleton\<br>　　　　app.py<br>　　　　map.py<br>　　　　templates\<br>　　　　　　　　layout.html<br>　　　　　　　　show_room.html<br>　　　　　　　　you_died.html</p>
<p>2.游戏地图结构 map.py<br>其中Room类是游戏场景，包括场景名称 name，描述 description，通往下一场景的可能路径集合 paths。</p>
<p>定义了游戏中设计到的7个场景。</p>
<pre><code># -*- coding:utf-8 -*-                                                                                                                                  
class Room(object):
        def __init__(self, name, description): 
                self.name = name 
                self.description = description 
                self.paths = {}  

        def go(self, direction): 
                return self.paths.get(direction, None) 

        def add_paths(self, paths): 
                self.paths.update(paths)

central_corridor = Room(&quot;Central Corridor&quot;,
&quot;&quot;&quot;
#25外星战机入侵了你的飞船，并且摧毁了你的部队。你是最后一个幸存者，你的最终任务是从武器室拿到炸弹，将炸弹放在驾驶舱，跳进分离仓之后，炸掉飞船。
你现在正在往武器室跑去，这时，一个外星人跳了出来，可怕的红色皮肤，暗淡肮脏的牙齿，丑陋的服装围绕着他那充满憎恶的身体。他正在关闭通往武器室的大门，并且掏
出武器对准了你。
&quot;&quot;&quot;
)

laser_weapon_armory=Room(&quot;Laser Weapon Armory&quot;,
&quot;&quot;&quot;
幸运的是你知道外星人是由意念组成的。
你讲了一个你知道的外星笑话。
&amp;$%@#$#%#@*&amp;^$%$@#^&amp;@%~$@%%!@~^^@#
外星人停止了动作，试着不发出笑声，最终禁不住大笑起来，并且停不下来。
当他笑的时候，你跑上前去，一枪命中他的眉心，将他放倒。然后跳进武器室。
你一个前空翻进入武器室，仔细地检查武器室是否藏有更多的外星人。死一般的寂静，太安静了。
你站起来，跑向武器室的角落，在盒子里找到了炸弹。盒子上有一个键盘，你需要输入密码才能将炸弹取出来。如果你输错10次，炸弹将永远被锁住无法取出。密码是4位数&gt;字。
&quot;&quot;&quot;
)

the_bridge=Room(&quot;The Bridge&quot;,
&quot;&quot;&quot;
盒子咔哒一声打开了，密封破裂，毒气逸出。
你一把抓起炸弹，尽可能快递跑向驾驶舱，你必须把炸弹安置在合适的地点。
你闯入驾驶舱，手臂下夹着炸弹，惊奇地发现有5个外星人正在试图控制飞船。他们中的每一个都比上一个拥有更加丑陋的服装。他们没有拿出武器，因为他们看见了你手臂&gt;下的炸弹，并且不希望引爆它。
&quot;&quot;&quot;
)

escape_pod=Room(&quot;Escape Pod&quot;,
&quot;&quot;&quot;
你拉出手臂下炸弹的导火线，外星人们举起手来，开始流汗。
你缓慢地退向门口，打开门，然后小心翼翼地把炸弹放在地上，拉出导火线。然后跳出驾驶舱，按下关闭按钮，门锁住了，外星人们无法逃出去。
现在炸弹已经安放好了，你跑向逃生通道。
你不顾一切地冲过飞船，以确保在整个飞船爆炸之前到达分离仓。看起来没有外星人在船上了，所以几乎没有遇到任何阻碍。你成功到达分离仓，然后你需要选择一个。他们
中的一些已经被摧毁了，但是你没有时间去检查。总共有5个分离仓，你将选择哪一个呢？
&quot;&quot;&quot;
)

the_end_winner=Room(&quot;The End&quot;,
&quot;&quot;&quot;
你跳进了2号分离舱 ，按下发动按钮。分离舱很容易地向下方的地球滑去。当它飞向地球时，你往回看，发现你的飞船像一颗明亮的星星一样炸开了，同时炸掉了恶灵的飞船
。你赢了！
&quot;&quot;&quot;
)

the_end_loser=Room(&quot;The End&quot;,
&quot;&quot;&quot;
你随便跳进一个分离舱，按下发动按钮。分离舱逃向未知的空间，然后因为外壳破裂而爆炸，把你的身体压成肉酱。
&quot;&quot;&quot;
)
escape_pod.add_paths({
        &apos;2&apos;:the_end_winner,
        &apos;*&apos;:the_end_loser
})

generic_death=Room(&quot;death&quot;,&quot;You died.&quot;)

the_bridge.add_paths({
        &apos;throw the bomb&apos;:generic_death,
        &apos;slowly place the bomb&apos;:escape_pod
})

laser_weapon_armory.add_paths({
        &apos;0132&apos;:the_bridge,
        &apos;*&apos;:generic_death
})

central_corridor.add_paths({
        &apos;shoot!&apos;:generic_death,
        &apos;dodge!&apos;:generic_death,
        &apos;tell a joke&apos;:laser_weapon_armory
})

START=central_corridor
</code></pre><p>3.游戏引擎设计<br>游戏引擎，也就是我们的web应用程序入口，定义了起始场景。将场景作为参数传递给场景信息显示模板show_room.html，显示当前场景描述信息。玩家输入动作指令，提交表单后，根据当前场景以及输入的指令，确定下一场景并显示。因为Http协议的无状态性，当前场景可以通过两种方式传递：(1)通过web.py框架的session机制<br>(2)通过&lt;input type=”hidden” value=””&gt;隐藏域的方式。这里我们选择第一种方式。</p>
<pre><code>import web                                                                                                                                              
from map import *
import pdb 
urls=(
        &apos;/game&apos;,&apos;GameEngine&apos;,
        &apos;/&apos;,&apos;Index&apos;,
)

app=web.application(urls,globals())

if web.config.get(&apos;_session&apos;) is None:
        store = web.session.DiskStore(&apos;sessions&apos;)
        session = web.session.Session(app,store,initializer={&apos;room&apos;:None,&apos;count&apos;:0})
        web.config._session = session
else:
        session = web.config._session
render = web.template.render(&apos;templates/&apos;,base=&quot;layout&quot;)

class Index(object):
        def GET(self):
                session.room = START
                #输入错误密码次数初始化
                session.count = 0 
                web.seeother(&quot;/game&quot;)

class GameEngine(object):
        def GET(self):
            if session.room:
                return render.show_room(room=session.room)
            else:
                #场景为None，则跳转到death界面
                return render.you_died()

        def POST(self):
                form = web.input(action=None)
                if session.room and form.action:
                        result = session.room.go(form.action)
#                       pdb.set_trace()
                        #如果你输错10次，炸弹将永远被锁住无法取出
                        if session.room.name==&apos;Laser Weapon Armory&apos; and (result==None or result.name==&apos;death&apos;) and session.count&lt;10:
                                #输入错误密码次数累计
                                session.count=session.count+1
                        else:
                                session.room = result
                web.seeother(&quot;/game&quot;)

if __name__==&quot;__main__&quot;:
        app.run()
</code></pre><p>4.接着创建模板页，模板放在templates文件夹下.<br>mkdir templates<br>首先创建一个基础模板页 layout.html</p>
<pre><code>$def with (content)                                                                                                                                     
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Gothons From Planet Percal #25&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
$:content
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>场景信息显示页面  show_room.html</p>
<pre><code>$def with (room)                                                                                                                                        
&lt;h1&gt;$room.name&lt;/h1&gt;
&lt;pre&gt;
$room.description
&lt;/pre&gt;
$if room.name==&quot;death&quot;:
        &lt;p&gt;&lt;a href=&quot;/&quot;&gt;Play Again?&lt;/a&gt;&lt;/p&gt;
$else:
        &lt;p&gt;
        &lt;form action=&quot;/game&quot; method=&quot;POST&quot;&gt;
        -&lt;input type=&quot;text&quot; name=&quot;action&quot;&gt;
        &lt;input type=&quot;SUBMIT&quot;&gt;
        &lt;/form&gt;
        &lt;/p&gt;
</code></pre><p>场景为None失败，提示界面 you_died.html</p>
<pre><code>&lt;h1&gt;You Died!&lt;/h1&gt;                                                                                                                                      
&lt;p&gt;Looks like you bit the dust&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/&quot;&gt;Play Again&lt;/a&gt;&lt;/p&gt;
</code></pre><p>5.运行：python app.py</p>
<p>6.结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201603/300946-20160331172346129-267934389.png" alt=""></p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201603/300946-20160331172410801-1185294461.png" alt=""></p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201603/300946-20160331172428785-1970529617.png" alt=""></p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201603/300946-20160331172445973-1703021698.png" alt=""></p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201603/300946-20160331172459863-415540435.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python--web.py使用]]></title>
      <url>https://shijingjing07.github.io/2016/03/30/python--web.py%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>web.py 是一个轻量级Python web框架。</p>
<p>下面我将使用web.py框架，创建一个简单的html页面示例。</p>
<p>1.项目的目录结构如下所示：</p>
<p>exweb2\<br>  uniqueenv\<br>  app.py<br>  templates\</p>
<p>　　　　　　base.html</p>
<p>　　　　　　hello_form.html<br>                 index.html</p>
<p>2.创建网站根目录exweb2<br>mkdir exweb2</p>
<p>3.在网站根目录下创建一个虚拟环境<br>cd exweb2<br>virtualenv uniqueenv</p>
<p>4.安装flask<br>uniqueenv/bin/pip install lpthw.web</p>
<p>5.web.py使用，app.py代码如下</p>
<pre><code>#-*- coding: UTF-8 -*-                                                           
import web 

urls =(
        &apos;/&apos;,&apos;Index&apos;
)

app = web.application(urls,globals())
 #base为基础模板页
render = web.template.render(&apos;templates/&apos;,base=&quot;base&quot;)

class Index(object):
         #get方式提交，若url参数不为空,直接跳转到显示界面,否则跳转到输入信息界面
        def GET(self):
                form = web.input(name=&quot;&quot;,greet=&quot;&quot;)
                if form.greet!=&quot;&quot; and form.name!=&quot;&quot;:
                        greeting=&quot;%s,%s&quot;%(form.greet,form.name)
                        return render.index(greeting=greeting)
                return render.hello_form()
        #post方式提交表单,
        def POST(self):
                form = web.input(name=&quot;Nobody&quot;,greet=&quot;Hello&quot;)
                greeting=&quot;%s,%s&quot;%(form.greet,form.name)
                return render.index(greeting=greeting)
if __name__ == &quot;__main__&quot;:
        app.run() 
</code></pre><p>6.接着创建模板页，模板放在templates文件夹下.</p>
<p><strong>mkdir templates</strong></p>
<p>首先创建一个基础模板页 base.html</p>
<pre><code>$def with (content)                                                              
&lt;html&gt;                                                                               
        &lt;head&gt;
                &lt;title&gt;
                &lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
                $:content
        &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>输入信息页 hello_form.html</p>
<pre><code>&lt;h1&gt;Fill out this form&lt;/h1&gt;                                                      
&lt;form action=&quot;/&quot; method=&quot;POST&quot;&gt;
A Greeting:&lt;input type=&quot;text&quot; name=&quot;greet&quot;&gt;
&lt;br/&gt;
Your Name:&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;
&lt;br/&gt;
&lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre><p>显示信息页 index.html</p>
<pre><code>$def with (greeting)                                                             

$if greeting: 
        I just wanted to say &lt;em style=&quot;color: green; font-size: 2em;&quot;&gt;$greeting&lt;/em&gt;. 
$else: 
        &lt;em&gt;Hello&lt;/em&gt;, world!
</code></pre><p> <em>7.运行：uniqueenv/bin/python app.py</em></p>
<p>注意运行的时候要使用虚拟目录中的python解释器</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201603/300946-20160330134039535-1709829164.png" alt=""></p>
<p>8.结果：</p>
<p>(1)Get方式</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201603/300946-20160330134104035-42679323.png" alt=""></p>
<p>(2)Post方式</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201603/300946-20160330134340254-2054116773.png" alt=""></p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201603/300946-20160330134351738-986870576.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python--flask使用]]></title>
      <url>https://shijingjing07.github.io/2016/03/29/python--flask%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>Flask是一个使用 Python 编写的轻量级 Web 应用框架。<br>下面我将使用Flask框架，创建一个简单的html页面示例。</p>
<p>1.项目的目录结构如下所示：<br>exweb\<br>  uniqueenv\<br>  app.py<br>  templates\</p>
<p>　　　　　　base.html</p>
<p>　　　　　　hello_form.html<br>                 index.html</p>
<p>2.创建网站根目录exweb<br>mkdir exweb</p>
<p>3.在网站根目录下创建一个虚拟环境，虚拟环境是主python的一份拷贝，好处是你可以只安装flask包到该虚拟目录，你的主python不会受到影响，另一个好处是你不需要再有root权限<br>cd exweb<br>virtualenv uniqueenv</p>
<p>4.安装flask<br>uniqueenv/bin/pip install flask</p>
<p>5.flask使用，app.py代码如下</p>
<pre><code>#-*- coding: UTF-8 -*-                                                                                                                                  
from flask import Flask,render_template,request
from flask.ext.wtf import Form
from wtforms import TextField, BooleanField, TextAreaField
from wtforms.validators import Required, Length

app = Flask(__name__)

#CSRF_ENABLED 配置是为了激活 跨站点请求伪造 保护
app.config[&apos;CSRF_ENABLED&apos;]=True
app.config[&apos;SECRET_KEY&apos;]=&apos;xxx&apos;

#form表单类
class HelloForm(Form):
    name = TextField(&apos;name&apos;,validators = [Required()])
    greet=TextField(&apos;greet&apos;,validators=[Required()])


@app.route(&apos;/&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])
def index():
        #get方式提交，若url参数不为空,直接跳转到显示界面
        name = request.args.get(&apos;name&apos;)
        greet = request.args.get(&apos;greet&apos;)
        if name!=&apos;&apos; and name!=None and greet!=&apos;&apos; and greet!=None:
                greeting=&quot;%s,%s&quot;%(name,greet)
                return render_template(&apos;index.html&apos;,
                        title=u&apos;显示信息&apos;,
                        greeting = greeting)


        #否则为post方式提交表单,跳转到输入信息界面
        form = HelloForm()
        if form.validate_on_submit():
                greeting=&quot;%s,%s&quot;%(form.name.data,form.greet.data)
                return render_template(&apos;index.html&apos;,
                        title=u&apos;显示信息&apos;,
                        greeting = greeting)
        return render_template(&apos;hello_form.html&apos;,
                title=u&apos;输入信息&apos;,
                form = form)

app.run(debug=True)
</code></pre><p>6.上一步我们从 Flask 框架中导入一个名为 render_template 的新函数，在内部，render_template 调用了 Jinja2<br>模板引擎，Jinja2 会把模板参数提供的相应的值替换。<br>模板放在templates文件夹下.<br>mkdir templates</p>
<p>首先创建一个基础模板页 base.html</p>
<pre><code>&lt;html&gt;                                                                                                                 
         &lt;head&gt;
                &lt;title&gt;{{title}}&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
                {% block content %}{% endblock %}
            
    



输入信息页 hello_form.html

    
    
    {% extends "base.html" %}                                                                                                 
    
    {% block content %}
    <h1>Fill out this form</h1>    
    <form action="" method="POST">
    {{form.hidden_tag()}}
    A Greeting:
    {{form.greet(size=30,maxlength=140)}}
    <br>
    Your Name:
    {{form.name(size=30,maxlength=140)}}
    <br>
    <input type="submit">
    </form>
    {% endblock %}
</code></pre><p>显示信息页 index.html</p>
<pre><code>{% extends "base.html" %}                                                                                                                            

{% block content %}
    {%if greeting:%}
     I just wanted to say <em style="color:green;font-size:2em;">{{greeting}}</em>
    {%endif%}
    {% endblock %}
</code></pre><p>7.运行：uniqueenv/bin/python app.py</p>
<p>注意运行的时候要使用虚拟目录中的python解释器</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201603/300946-20160330095956098-476888447.png" alt=""></p>
<p>8.结果：</p>
<p>(1)Get方式</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201603/300946-20160330095846504-570096275.png" alt=""></p>
<p>(2)Post方式</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201603/300946-20160330100036348-1915660279.png" alt=""></p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201603/300946-20160330100106379-1591817480.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python--类方法、对象方法、静态方法]]></title>
      <url>https://shijingjing07.github.io/2016/03/25/python--%E7%B1%BB%E6%96%B9%E6%B3%95%E3%80%81%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p> 1、我们已经讨论了类/对象可以拥有像函数一样的方法，这些对象方法与函数的区别只是一个额外的self变量</p>
<pre><code># -*- coding:utf-8 -*-
#!/usr/bin/python
# Filename: method.py

class Person:
    grade=1
    def __init__(self,name):
        self.name = name
    def sayHi(self):#加self区别于普通函数
        print &apos;Hello, your name is?&apos;,self.name

    @staticmethod #声明静态，去掉则编译报错;还有静态方法不能访问类变量和实例变量
    def sayName():#使用了静态方法，则不能再使用self
        print &quot;my name is king&quot;#,grade,#self.name

    @classmethod #类方法
    def classMethod(cls):
        print(&quot;class method&quot;)

p = Person(&quot;king&quot;)
p.sayHi()
p.sayName()
p.classMethod()
Person.classMethod()

输出：
Hello, your name is? king
my name is king
class method
class method
</code></pre><p>2、静态方法<br>要在类中使用静态方法，需在类成员函数前面加上@staticmethod标记符，以表示下面的成员函数是静态函数。使用静态方法的好处是，不需要定义实例即可使用这个方法。另外，多个实例共享此静态方法。  </p>
<p>3、 类方法<br>类方法与普通的成员函数和静态函数有不同之处，在接触的语言中好像也没见过这种语义，看它的定义：<br>一个类方法就可以通过类或它的实例来调用的方法, 不管你是用类来调用这个方法还是类实例调用这个方法,该方法的第一个参数总是定义该方法的类对象。<br>记住:方法的第一个参数都是类对象而不是实例对象.<br>按照惯例,类方法的第一个形参被命名为<br>cls.任何时候定义类方法都不是必须的（类方法能实现的功能都可以通过定义一个普通函数来实现,只要这个函数接受一个类对象做为参数就可以了）.  </p>
<p>python中实现静态方法和类方法都是依赖于python的修饰器来实现的。 对象方法有self参数，类方法有cls参数，静态方法是不需要这些附加参数的。</p>
<p>转自：<a href="http://blog.chinaunix.net/uid-26602509-id-3087296.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-26602509-id-3087296.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python--类定义]]></title>
      <url>https://shijingjing07.github.io/2016/03/25/Python--%E7%B1%BB%E5%AE%9A%E4%B9%89/</url>
      <content type="html"><![CDATA[<p>转自：<a href="http://kanwoerzi.iteye.com/blog/1304466" target="_blank" rel="external">http://kanwoerzi.iteye.com/blog/1304466</a></p>
<p>Python笔记—-类定义</p>
<p>一、类定义：</p>
<p>class &lt;类名&gt;:</p>
<p>&lt;语句&gt;</p>
<p>类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性</p>
<p>如果直接使用类名修改其属性，那么将直接影响到已经实例化的对象</p>
<p>类的私有属性：</p>
<p>__private_attrs 两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问</p>
<p>在类内部的方法中使用时 self.__private_attrs</p>
<p>类的方法</p>
<p>在类地内部，使用def关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self,且为第一个参数</p>
<p>私有的类方法</p>
<p>__private_method 两个下划线开头，声明该方法为私有方法，不能在类地外部调用</p>
<p>在类的内部调用slef.__private_methods</p>
<p>类的专有方法：</p>
<p><strong>init</strong> 构造函数，在生成对象时调用</p>
<p><strong>del</strong> 析构函数，释放对象时使用</p>
<p><strong>repr</strong> 打印，转换</p>
<p><strong>setitem</strong>按照索引赋值</p>
<p><strong>getitem</strong>按照索引获取值</p>
<p><strong>len</strong>获得长度</p>
<p><strong>cmp</strong>比较运算</p>
<p><strong>call</strong>函数调用</p>
<p><strong>add</strong>加运算</p>
<p><strong>sub</strong>减运算</p>
<p><strong>mul</strong>乘运算</p>
<p><strong>div</strong>除运算</p>
<p><strong>mod</strong>求余运算</p>
<p><strong>pow</strong>称方</p>
<p>示例:</p>
<pre><code>class people:  
    #定义基本属性  
    name = &apos;&apos;  
    age = 0  
    #定义私有属性,私有属性在类外部无法直接进行访问  
    __weight = 0  
    #定义构造方法  
    def __init__(self,n,a,w):  
        self.name = n  
        self.age = a  
        self.__weight = w  
    def speak(self):  
        print(&quot;%s is speaking: I am %d years old&quot; %(self.name,self.age))  


p = people(&apos;tom&apos;,10,30)  
p.speak()  
</code></pre><p>二、继承类定义：</p>
<p>1.单继承</p>
<p>class &lt;类名&gt;(父类名)</p>
<p>&lt;语句&gt;</p>
<p>eg.</p>
<p>class childbook(book)</p>
<p>age = 10</p>
<pre><code>#单继承示例  
class student(people):  
    grade = &apos;&apos;  
    def __init__(self,n,a,w,g):  
        #调用父类的构函  
        people.__init__(self,n,a,w)  
        self.grade = g  
    #覆写父类的方法  
    def speak(self):  
        print(&quot;%s is speaking: I am %d years old,and I am in grade %d&quot;%(self.name,self.age,self.grade))  



s = student(&apos;ken&apos;,20,60,3)  
s.speak()  
</code></pre><p>2.类的多重继承</p>
<p>class 类名(父类1,父类2,….,父类n)</p>
<p>&lt;语句1&gt;</p>
<p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索</p>
<p>即方法在子类中未找到时，从左到右查找父类中是否包含方法</p>
<pre><code>#另一个类，多重继承之前的准备  
class speaker():  
    topic = &apos;&apos;  
    name = &apos;&apos;  
    def __init__(self,n,t):  
        self.name = n  
        self.topic = t  
    def speak(self):  
        print(&quot;I am %s,I am a speaker!My topic is %s&quot;%(self.name,self.topic))  

#多重继承  
class sample(speaker,student):  
    a =&apos;&apos;  
    def __init__(self,n,a,w,g,t):  
        student.__init__(self,n,a,w,g)  
        speaker.__init__(self,n,t)  

test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)  
test.speak()#方法名同，默认调用的是在括号中排前地父类的方法  
</code></pre><p>类方法的覆写—-子类覆盖掉父类的方法</p>
<p>def 方法名与父类一致</p>
<p>若是在方法中要使用到父类方法 父类名.方法名</p>
<p>若是将类放到了模块中</p>
<p>使用时</p>
<p>import A</p>
<p>l = A.类()</p>
<p>以上三段程序的执行结果:</p>
<p>类方法的覆写—-子类覆盖掉父类的方法</p>
<p>def 方法名与父类一致</p>
<p>若是在方法中要使用到父类方法 父类名.方法名</p>
<p>若是将类放到了模块中</p>
<p>使用时</p>
<p>import A</p>
<p>l = A.类()</p>
<p>以上三段程序的执行结果:</p>
<p>类方法的覆写—-子类覆盖掉父类的方法</p>
<p>def 方法名与父类一致</p>
<p>若是在方法中要使用到父类方法 父类名.方法名</p>
<p>若是将类放到了模块中</p>
<p>使用时</p>
<p>import A</p>
<p>l = A.类()</p>
<p>以上三段程序的执行结果:</p>
<p><img src="http://images2015.cnblogs.com/blog/300946/201603/300946-20160325210542370-292640845.jpg" alt=""></p>
]]></content>
    </entry>
    
  
  
</search>
